/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/ansi-styles/index.js":
/*!********************************************!*\
  !*** ../node_modules/ansi-styles/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\nconst colorConvert = __webpack_require__(/*! color-convert */ \"../node_modules/color-convert/index.js\");\n\nconst wrapAnsi16 = (fn, offset) => function () {\n\tconst code = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${code + offset}m`;\n};\n\nconst wrapAnsi256 = (fn, offset) => function () {\n\tconst code = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${38 + offset};5;${code}m`;\n};\n\nconst wrapAnsi16m = (fn, offset) => function () {\n\tconst rgb = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n};\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\t\t\tgray: [90, 39],\n\n\t\t\t// Bright color\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Fix humans\n\tstyles.color.grey = styles.color.gray;\n\n\tfor (const groupName of Object.keys(styles)) {\n\t\tconst group = styles[groupName];\n\n\t\tfor (const styleName of Object.keys(group)) {\n\t\t\tconst style = group[styleName];\n\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\n\t\tObject.defineProperty(styles, 'codes', {\n\t\t\tvalue: codes,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tconst ansi2ansi = n => n;\n\tconst rgb2rgb = (r, g, b) => [r, g, b];\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tstyles.color.ansi = {\n\t\tansi: wrapAnsi16(ansi2ansi, 0)\n\t};\n\tstyles.color.ansi256 = {\n\t\tansi256: wrapAnsi256(ansi2ansi, 0)\n\t};\n\tstyles.color.ansi16m = {\n\t\trgb: wrapAnsi16m(rgb2rgb, 0)\n\t};\n\n\tstyles.bgColor.ansi = {\n\t\tansi: wrapAnsi16(ansi2ansi, 10)\n\t};\n\tstyles.bgColor.ansi256 = {\n\t\tansi256: wrapAnsi256(ansi2ansi, 10)\n\t};\n\tstyles.bgColor.ansi16m = {\n\t\trgb: wrapAnsi16m(rgb2rgb, 10)\n\t};\n\n\tfor (let key of Object.keys(colorConvert)) {\n\t\tif (typeof colorConvert[key] !== 'object') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst suite = colorConvert[key];\n\n\t\tif (key === 'ansi16') {\n\t\t\tkey = 'ansi';\n\t\t}\n\n\t\tif ('ansi16' in suite) {\n\t\t\tstyles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);\n\t\t\tstyles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);\n\t\t}\n\n\t\tif ('ansi256' in suite) {\n\t\t\tstyles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);\n\t\t\tstyles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);\n\t\t}\n\n\t\tif ('rgb' in suite) {\n\t\t\tstyles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);\n\t\t\tstyles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);\n\t\t}\n\t}\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"../node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///../node_modules/ansi-styles/index.js?");

/***/ }),

/***/ "../node_modules/balanced-match/index.js":
/*!***********************************************!*\
  !*** ../node_modules/balanced-match/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n\n\n//# sourceURL=webpack:///../node_modules/balanced-match/index.js?");

/***/ }),

/***/ "../node_modules/brace-expansion/index.js":
/*!************************************************!*\
  !*** ../node_modules/brace-expansion/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var concatMap = __webpack_require__(/*! concat-map */ \"../node_modules/concat-map/index.js\");\nvar balanced = __webpack_require__(/*! balanced-match */ \"../node_modules/balanced-match/index.js\");\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n\n\n//# sourceURL=webpack:///../node_modules/brace-expansion/index.js?");

/***/ }),

/***/ "../node_modules/chalk/index.js":
/*!**************************************!*\
  !*** ../node_modules/chalk/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst escapeStringRegexp = __webpack_require__(/*! escape-string-regexp */ \"../node_modules/escape-string-regexp/index.js\");\nconst ansiStyles = __webpack_require__(/*! ansi-styles */ \"../node_modules/ansi-styles/index.js\");\nconst stdoutColor = __webpack_require__(/*! supports-color */ \"../node_modules/supports-color/index.js\").stdout;\n\nconst template = __webpack_require__(/*! ./templates.js */ \"../node_modules/chalk/templates.js\");\n\nconst isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');\n\n// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping\nconst levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];\n\n// `color-convert` models to exclude from the Chalk API due to conflicts and such\nconst skipModels = new Set(['gray']);\n\nconst styles = Object.create(null);\n\nfunction applyOptions(obj, options) {\n\toptions = options || {};\n\n\t// Detect level if not set manually\n\tconst scLevel = stdoutColor ? stdoutColor.level : 0;\n\tobj.level = options.level === undefined ? scLevel : options.level;\n\tobj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;\n}\n\nfunction Chalk(options) {\n\t// We check for this.template here since calling `chalk.constructor()`\n\t// by itself will have a `this` of a previously constructed chalk object\n\tif (!this || !(this instanceof Chalk) || this.template) {\n\t\tconst chalk = {};\n\t\tapplyOptions(chalk, options);\n\n\t\tchalk.template = function () {\n\t\t\tconst args = [].slice.call(arguments);\n\t\t\treturn chalkTag.apply(null, [chalk.template].concat(args));\n\t\t};\n\n\t\tObject.setPrototypeOf(chalk, Chalk.prototype);\n\t\tObject.setPrototypeOf(chalk.template, chalk);\n\n\t\tchalk.template.constructor = Chalk;\n\n\t\treturn chalk.template;\n\t}\n\n\tapplyOptions(this, options);\n}\n\n// Use bright blue on Windows as the normal blue color is illegible\nif (isSimpleWindowsTerm) {\n\tansiStyles.blue.open = '\\u001B[94m';\n}\n\nfor (const key of Object.keys(ansiStyles)) {\n\tansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n\n\tstyles[key] = {\n\t\tget() {\n\t\t\tconst codes = ansiStyles[key];\n\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);\n\t\t}\n\t};\n}\n\nstyles.visible = {\n\tget() {\n\t\treturn build.call(this, this._styles || [], true, 'visible');\n\t}\n};\n\nansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');\nfor (const model of Object.keys(ansiStyles.color.ansi)) {\n\tif (skipModels.has(model)) {\n\t\tcontinue;\n\t}\n\n\tstyles[model] = {\n\t\tget() {\n\t\t\tconst level = this.level;\n\t\t\treturn function () {\n\t\t\t\tconst open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);\n\t\t\t\tconst codes = {\n\t\t\t\t\topen,\n\t\t\t\t\tclose: ansiStyles.color.close,\n\t\t\t\t\tcloseRe: ansiStyles.color.closeRe\n\t\t\t\t};\n\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n\t\t\t};\n\t\t}\n\t};\n}\n\nansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');\nfor (const model of Object.keys(ansiStyles.bgColor.ansi)) {\n\tif (skipModels.has(model)) {\n\t\tcontinue;\n\t}\n\n\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\tstyles[bgModel] = {\n\t\tget() {\n\t\t\tconst level = this.level;\n\t\t\treturn function () {\n\t\t\t\tconst open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);\n\t\t\t\tconst codes = {\n\t\t\t\t\topen,\n\t\t\t\t\tclose: ansiStyles.bgColor.close,\n\t\t\t\t\tcloseRe: ansiStyles.bgColor.closeRe\n\t\t\t\t};\n\t\t\t\treturn build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n\t\t\t};\n\t\t}\n\t};\n}\n\nconst proto = Object.defineProperties(() => {}, styles);\n\nfunction build(_styles, _empty, key) {\n\tconst builder = function () {\n\t\treturn applyStyle.apply(builder, arguments);\n\t};\n\n\tbuilder._styles = _styles;\n\tbuilder._empty = _empty;\n\n\tconst self = this;\n\n\tObject.defineProperty(builder, 'level', {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn self.level;\n\t\t},\n\t\tset(level) {\n\t\t\tself.level = level;\n\t\t}\n\t});\n\n\tObject.defineProperty(builder, 'enabled', {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn self.enabled;\n\t\t},\n\t\tset(enabled) {\n\t\t\tself.enabled = enabled;\n\t\t}\n\t});\n\n\t// See below for fix regarding invisible grey/dim combination on Windows\n\tbuilder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';\n\n\t// `__proto__` is used because we must return a function, but there is\n\t// no way to create a function with a different prototype\n\tbuilder.__proto__ = proto; // eslint-disable-line no-proto\n\n\treturn builder;\n}\n\nfunction applyStyle() {\n\t// Support varags, but simply cast to string in case there's only one arg\n\tconst args = arguments;\n\tconst argsLen = args.length;\n\tlet str = String(arguments[0]);\n\n\tif (argsLen === 0) {\n\t\treturn '';\n\t}\n\n\tif (argsLen > 1) {\n\t\t// Don't slice `arguments`, it prevents V8 optimizations\n\t\tfor (let a = 1; a < argsLen; a++) {\n\t\t\tstr += ' ' + args[a];\n\t\t}\n\t}\n\n\tif (!this.enabled || this.level <= 0 || !str) {\n\t\treturn this._empty ? '' : str;\n\t}\n\n\t// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,\n\t// see https://github.com/chalk/chalk/issues/58\n\t// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.\n\tconst originalDim = ansiStyles.dim.open;\n\tif (isSimpleWindowsTerm && this.hasGrey) {\n\t\tansiStyles.dim.open = '';\n\t}\n\n\tfor (const code of this._styles.slice().reverse()) {\n\t\t// Replace any instances already present with a re-opening code\n\t\t// otherwise only the part of the string until said closing code\n\t\t// will be colored, and the rest will simply be 'plain'.\n\t\tstr = code.open + str.replace(code.closeRe, code.open) + code.close;\n\n\t\t// Close the styling before a linebreak and reopen\n\t\t// after next line to fix a bleed issue on macOS\n\t\t// https://github.com/chalk/chalk/pull/92\n\t\tstr = str.replace(/\\r?\\n/g, `${code.close}$&${code.open}`);\n\t}\n\n\t// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue\n\tansiStyles.dim.open = originalDim;\n\n\treturn str;\n}\n\nfunction chalkTag(chalk, strings) {\n\tif (!Array.isArray(strings)) {\n\t\t// If chalk() was called by itself or with a string,\n\t\t// return the string itself as a string.\n\t\treturn [].slice.call(arguments, 1).join(' ');\n\t}\n\n\tconst args = [].slice.call(arguments, 2);\n\tconst parts = [strings.raw[0]];\n\n\tfor (let i = 1; i < strings.length; i++) {\n\t\tparts.push(String(args[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'));\n\t\tparts.push(String(strings.raw[i]));\n\t}\n\n\treturn template(chalk, parts.join(''));\n}\n\nObject.defineProperties(Chalk.prototype, styles);\n\nmodule.exports = Chalk(); // eslint-disable-line new-cap\nmodule.exports.supportsColor = stdoutColor;\nmodule.exports.default = module.exports; // For TypeScript\n\n\n//# sourceURL=webpack:///../node_modules/chalk/index.js?");

/***/ }),

/***/ "../node_modules/chalk/templates.js":
/*!******************************************!*\
  !*** ../node_modules/chalk/templates.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst TEMPLATE_REGEX = /(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n\nconst ESCAPES = new Map([\n\t['n', '\\n'],\n\t['r', '\\r'],\n\t['t', '\\t'],\n\t['b', '\\b'],\n\t['f', '\\f'],\n\t['v', '\\v'],\n\t['0', '\\0'],\n\t['\\\\', '\\\\'],\n\t['e', '\\u001B'],\n\t['a', '\\u0007']\n]);\n\nfunction unescape(c) {\n\tif ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {\n\t\treturn String.fromCharCode(parseInt(c.slice(1), 16));\n\t}\n\n\treturn ESCAPES.get(c) || c;\n}\n\nfunction parseArguments(name, args) {\n\tconst results = [];\n\tconst chunks = args.trim().split(/\\s*,\\s*/g);\n\tlet matches;\n\n\tfor (const chunk of chunks) {\n\t\tif (!isNaN(chunk)) {\n\t\t\tresults.push(Number(chunk));\n\t\t} else if ((matches = chunk.match(STRING_REGEX))) {\n\t\t\tresults.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));\n\t\t} else {\n\t\t\tthrow new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction parseStyle(style) {\n\tSTYLE_REGEX.lastIndex = 0;\n\n\tconst results = [];\n\tlet matches;\n\n\twhile ((matches = STYLE_REGEX.exec(style)) !== null) {\n\t\tconst name = matches[1];\n\n\t\tif (matches[2]) {\n\t\t\tconst args = parseArguments(name, matches[2]);\n\t\t\tresults.push([name].concat(args));\n\t\t} else {\n\t\t\tresults.push([name]);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction buildStyle(chalk, styles) {\n\tconst enabled = {};\n\n\tfor (const layer of styles) {\n\t\tfor (const style of layer.styles) {\n\t\t\tenabled[style[0]] = layer.inverse ? null : style.slice(1);\n\t\t}\n\t}\n\n\tlet current = chalk;\n\tfor (const styleName of Object.keys(enabled)) {\n\t\tif (Array.isArray(enabled[styleName])) {\n\t\t\tif (!(styleName in current)) {\n\t\t\t\tthrow new Error(`Unknown Chalk style: ${styleName}`);\n\t\t\t}\n\n\t\t\tif (enabled[styleName].length > 0) {\n\t\t\t\tcurrent = current[styleName].apply(current, enabled[styleName]);\n\t\t\t} else {\n\t\t\t\tcurrent = current[styleName];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn current;\n}\n\nmodule.exports = (chalk, tmp) => {\n\tconst styles = [];\n\tconst chunks = [];\n\tlet chunk = [];\n\n\t// eslint-disable-next-line max-params\n\ttmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {\n\t\tif (escapeChar) {\n\t\t\tchunk.push(unescape(escapeChar));\n\t\t} else if (style) {\n\t\t\tconst str = chunk.join('');\n\t\t\tchunk = [];\n\t\t\tchunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));\n\t\t\tstyles.push({inverse, styles: parseStyle(style)});\n\t\t} else if (close) {\n\t\t\tif (styles.length === 0) {\n\t\t\t\tthrow new Error('Found extraneous } in Chalk template literal');\n\t\t\t}\n\n\t\t\tchunks.push(buildStyle(chalk, styles)(chunk.join('')));\n\t\t\tchunk = [];\n\t\t\tstyles.pop();\n\t\t} else {\n\t\t\tchunk.push(chr);\n\t\t}\n\t});\n\n\tchunks.push(chunk.join(''));\n\n\tif (styles.length > 0) {\n\t\tconst errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n\t\tthrow new Error(errMsg);\n\t}\n\n\treturn chunks.join('');\n};\n\n\n//# sourceURL=webpack:///../node_modules/chalk/templates.js?");

/***/ }),

/***/ "../node_modules/color-convert/conversions.js":
/*!****************************************************!*\
  !*** ../node_modules/color-convert/conversions.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* MIT license */\nvar cssKeywords = __webpack_require__(/*! color-name */ \"../node_modules/color-name/index.js\");\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n\tif (cssKeywords.hasOwnProperty(key)) {\n\t\treverseKeywords[cssKeywords[key]] = key;\n\t}\n}\n\nvar convert = module.exports = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\n// hide .channels and .labels properties\nfor (var model in convert) {\n\tif (convert.hasOwnProperty(model)) {\n\t\tif (!('channels' in convert[model])) {\n\t\t\tthrow new Error('missing channels property: ' + model);\n\t\t}\n\n\t\tif (!('labels' in convert[model])) {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\n\t\tif (convert[model].labels.length !== convert[model].channels) {\n\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t\t}\n\n\t\tvar channels = convert[model].channels;\n\t\tvar labels = convert[model].labels;\n\t\tdelete convert[model].channels;\n\t\tdelete convert[model].labels;\n\t\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\t\tObject.defineProperty(convert[model], 'labels', {value: labels});\n\t}\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar s;\n\tvar l;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tvar rdif;\n\tvar gdif;\n\tvar bdif;\n\tvar h;\n\tvar s;\n\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar v = Math.max(r, g, b);\n\tvar diff = v - Math.min(r, g, b);\n\tvar diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = s = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tvar r = rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert.rgb.hsl(rgb)[0];\n\tvar w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\n\tk = Math.min(1 - r, 1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k) || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\n/**\n * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n * */\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0], 2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\n\tfor (var keyword in cssKeywords) {\n\t\tif (cssKeywords.hasOwnProperty(keyword)) {\n\t\t\tvar value = cssKeywords[keyword];\n\n\t\t\t// Compute comparative distance\n\t\t\tvar distance = comparativeDistance(rgb, value);\n\n\t\t\t// Check if its less, if so set as closest\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tvar xyz = convert.rgb.xyz(rgb);\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar rgb;\n\tvar val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tt1 = 2 * l - t2;\n\n\trgb = [0, 0, 0];\n\tfor (var i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tvar h = hsv[0] / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h) % 6;\n\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q = 255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\n\tl = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\n\t// wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\ti = Math.floor(6 * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tn = wh + f * (v - wh); // linear interpolation\n\n\tvar r;\n\tvar g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r = wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4: r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tvar c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = 1 - Math.min(1, c * (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tvar y2 = Math.pow(y, 3);\n\tvar x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar c;\n\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tc = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar a;\n\tvar b;\n\tvar hr;\n\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tvar ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\n\t// we use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tvar ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tvar color = args % 10;\n\n\t// handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tvar mult = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g = (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// handle greyscale\n\tif (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tvar colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(function (char) {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tvar integer = parseInt(colorString, 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r, g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar f = 0;\n\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s * (1.0 - l);\n\t}\n\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\n\tvar c = s * v;\n\tvar f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1) * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar v = c + g * (1.0 - c);\n\tvar f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] / 100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = convert.gray.hsv = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer = (val << 16) + (val << 8) + val;\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n\n\n//# sourceURL=webpack:///../node_modules/color-convert/conversions.js?");

/***/ }),

/***/ "../node_modules/color-convert/index.js":
/*!**********************************************!*\
  !*** ../node_modules/color-convert/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var conversions = __webpack_require__(/*! ./conversions */ \"../node_modules/color-convert/conversions.js\");\nvar route = __webpack_require__(/*! ./route */ \"../node_modules/color-convert/route.js\");\n\nvar convert = {};\n\nvar models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\tvar result = fn(args);\n\n\t\t// we're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(function (fromModel) {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tvar routes = route(fromModel);\n\tvar routeModels = Object.keys(routes);\n\n\trouteModels.forEach(function (toModel) {\n\t\tvar fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n\n\n//# sourceURL=webpack:///../node_modules/color-convert/index.js?");

/***/ }),

/***/ "../node_modules/color-convert/route.js":
/*!**********************************************!*\
  !*** ../node_modules/color-convert/route.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var conversions = __webpack_require__(/*! ./conversions */ \"../node_modules/color-convert/conversions.js\");\n\n/*\n\tthis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tvar graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tvar models = Object.keys(conversions);\n\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tvar graph = deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n\n\n//# sourceURL=webpack:///../node_modules/color-convert/route.js?");

/***/ }),

/***/ "../node_modules/color-name/index.js":
/*!*******************************************!*\
  !*** ../node_modules/color-name/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n\n\n//# sourceURL=webpack:///../node_modules/color-name/index.js?");

/***/ }),

/***/ "../node_modules/concat-map/index.js":
/*!*******************************************!*\
  !*** ../node_modules/concat-map/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n//# sourceURL=webpack:///../node_modules/concat-map/index.js?");

/***/ }),

/***/ "../node_modules/core-util-is/lib/util.js":
/*!************************************************!*\
  !*** ../node_modules/core-util-is/lib/util.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n//# sourceURL=webpack:///../node_modules/core-util-is/lib/util.js?");

/***/ }),

/***/ "../node_modules/escape-string-regexp/index.js":
/*!*****************************************************!*\
  !*** ../node_modules/escape-string-regexp/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n\n\n//# sourceURL=webpack:///../node_modules/escape-string-regexp/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/copy-sync/copy-sync.js":
/*!***********************************************************!*\
  !*** ../node_modules/fs-extra/lib/copy-sync/copy-sync.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdirpSync = __webpack_require__(/*! ../mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\").mkdirsSync\nconst utimesSync = __webpack_require__(/*! ../util/utimes.js */ \"../node_modules/fs-extra/lib/util/utimes.js\").utimesMillisSync\n\nconst notExist = Symbol('notExist')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = {filter: opts}\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const destStat = checkPaths(src, dest)\n\n  if (opts.filter && !opts.filter(src, dest)) return\n\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (destStat === notExist) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest)\n    fs.chmodSync(dest, srcStat.mode)\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\n    }\n    return\n  }\n  return copyFileFallback(srcStat, src, dest, opts)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = __webpack_require__(/*! ../util/buffer */ \"../node_modules/fs-extra/lib/util/buffer.js\")(BUF_LENGTH)\n\n  const fdr = fs.openSync(src, 'r')\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\n  let pos = 0\n\n  while (pos < srcStat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return fs.chmodSync(dest, srcStat.mode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const destStat = checkPaths(srcItem, destItem)\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (destStat === notExist) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\n// return true if dest is a subdir of src, otherwise false.\nfunction isSrcSubdir (src, dest) {\n  const srcArray = path.resolve(src).split(path.sep)\n  const destArray = path.resolve(dest).split(path.sep)\n  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)\n}\n\nfunction checkStats (src, dest) {\n  const srcStat = fs.statSync(src)\n  let destStat\n  try {\n    destStat = fs.statSync(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return {srcStat, destStat: notExist}\n    throw err\n  }\n  return {srcStat, destStat}\n}\n\nfunction checkPaths (src, dest) {\n  const {srcStat, destStat} = checkStats(src, dest)\n  if (destStat.ino && destStat.ino === srcStat.ino) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`)\n  }\n  return destStat\n}\n\nmodule.exports = copySync\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/copy-sync/copy-sync.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/copy-sync/index.js":
/*!*******************************************************!*\
  !*** ../node_modules/fs-extra/lib/copy-sync/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  copySync: __webpack_require__(/*! ./copy-sync */ \"../node_modules/fs-extra/lib/copy-sync/copy-sync.js\")\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/copy-sync/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/copy/copy.js":
/*!*************************************************!*\
  !*** ../node_modules/fs-extra/lib/copy/copy.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdirp = __webpack_require__(/*! ../mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\").mkdirs\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst utimes = __webpack_require__(/*! ../util/utimes */ \"../node_modules/fs-extra/lib/util/utimes.js\").utimesMillis\n\nconst notExist = Symbol('notExist')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = {filter: opts}\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  checkPaths(src, dest, (err, destStat) => {\n    if (err) return cb(err)\n    if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n    return checkParentDir(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirp(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) {\n      if (destStat) return onInclude(destStat, src, dest, opts, cb)\n      return onInclude(src, dest, opts, cb)\n    }\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err)\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\n    })\n  }\n  return copyFileFallback(srcStat, src, dest, opts, cb)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src)\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\n    ws.on('error', err => cb(err))\n      .on('open', () => rs.pipe(ws))\n      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\n  })\n}\n\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\n    }\n    return cb()\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return fs.chmod(dest, srcStat.mode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  checkPaths(srcItem, destItem, (err, destStat) => {\n    if (err) return cb(err)\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (destStat === notExist) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\n// return true if dest is a subdir of src, otherwise false.\nfunction isSrcSubdir (src, dest) {\n  const srcArray = path.resolve(src).split(path.sep)\n  const destArray = path.resolve(dest).split(path.sep)\n  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)\n}\n\nfunction checkStats (src, dest, cb) {\n  fs.stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n    fs.stat(dest, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb(null, {srcStat, destStat: notExist})\n        return cb(err)\n      }\n      return cb(null, {srcStat, destStat})\n    })\n  })\n}\n\nfunction checkPaths (src, dest, cb) {\n  checkStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const {srcStat, destStat} = stats\n    if (destStat.ino && destStat.ino === srcStat.ino) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`))\n    }\n    return cb(null, destStat)\n  })\n}\n\nmodule.exports = copy\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/copy/copy.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/copy/index.js":
/*!**************************************************!*\
  !*** ../node_modules/fs-extra/lib/copy/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nmodule.exports = {\n  copy: u(__webpack_require__(/*! ./copy */ \"../node_modules/fs-extra/lib/copy/copy.js\"))\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/copy/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/empty/index.js":
/*!***************************************************!*\
  !*** ../node_modules/fs-extra/lib/empty/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst remove = __webpack_require__(/*! ../remove */ \"../node_modules/fs-extra/lib/remove/index.js\")\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch (err) {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/empty/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/ensure/file.js":
/*!***************************************************!*\
  !*** ../node_modules/fs-extra/lib/ensure/file.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    pathExists(dir, (err, dirExists) => {\n      if (err) return callback(err)\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, err => {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch (e) {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/ensure/file.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/ensure/index.js":
/*!****************************************************!*\
  !*** ../node_modules/fs-extra/lib/ensure/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst file = __webpack_require__(/*! ./file */ \"../node_modules/fs-extra/lib/ensure/file.js\")\nconst link = __webpack_require__(/*! ./link */ \"../node_modules/fs-extra/lib/ensure/link.js\")\nconst symlink = __webpack_require__(/*! ./symlink */ \"../node_modules/fs-extra/lib/ensure/symlink.js\")\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/ensure/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/ensure/link.js":
/*!***************************************************!*\
  !*** ../node_modules/fs-extra/lib/ensure/link.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/ensure/link.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/ensure/symlink-paths.js":
/*!************************************************************!*\
  !*** ../node_modules/fs-extra/lib/ensure/symlink-paths.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/ensure/symlink-paths.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/ensure/symlink-type.js":
/*!***********************************************************!*\
  !*** ../node_modules/fs-extra/lib/ensure/symlink-type.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch (e) {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/ensure/symlink-type.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/ensure/symlink.js":
/*!******************************************************!*\
  !*** ../node_modules/fs-extra/lib/ensure/symlink.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nconst path = __webpack_require__(/*! path */ \"path\")\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst _mkdirs = __webpack_require__(/*! ../mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = __webpack_require__(/*! ./symlink-paths */ \"../node_modules/fs-extra/lib/ensure/symlink-paths.js\")\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = __webpack_require__(/*! ./symlink-type */ \"../node_modules/fs-extra/lib/ensure/symlink-type.js\")\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/ensure/symlink.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/fs/index.js":
/*!************************************************!*\
  !*** ../node_modules/fs-extra/lib/fs/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchown',\n  'lchmod',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'readFile',\n  'readdir',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.copyFile was added in Node.js v8.5.0\n  // fs.mkdtemp was added in Node.js v5.10.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read() & fs.write need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/fs/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/index.js":
/*!*********************************************!*\
  !*** ../node_modules/fs-extra/lib/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = Object.assign(\n  {},\n  // Export promiseified graceful-fs:\n  __webpack_require__(/*! ./fs */ \"../node_modules/fs-extra/lib/fs/index.js\"),\n  // Export extra methods:\n  __webpack_require__(/*! ./copy-sync */ \"../node_modules/fs-extra/lib/copy-sync/index.js\"),\n  __webpack_require__(/*! ./copy */ \"../node_modules/fs-extra/lib/copy/index.js\"),\n  __webpack_require__(/*! ./empty */ \"../node_modules/fs-extra/lib/empty/index.js\"),\n  __webpack_require__(/*! ./ensure */ \"../node_modules/fs-extra/lib/ensure/index.js\"),\n  __webpack_require__(/*! ./json */ \"../node_modules/fs-extra/lib/json/index.js\"),\n  __webpack_require__(/*! ./mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\"),\n  __webpack_require__(/*! ./move-sync */ \"../node_modules/fs-extra/lib/move-sync/index.js\"),\n  __webpack_require__(/*! ./move */ \"../node_modules/fs-extra/lib/move/index.js\"),\n  __webpack_require__(/*! ./output */ \"../node_modules/fs-extra/lib/output/index.js\"),\n  __webpack_require__(/*! ./path-exists */ \"../node_modules/fs-extra/lib/path-exists/index.js\"),\n  __webpack_require__(/*! ./remove */ \"../node_modules/fs-extra/lib/remove/index.js\")\n)\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, 'promises', {\n    get () { return fs.promises }\n  })\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/json/index.js":
/*!**************************************************!*\
  !*** ../node_modules/fs-extra/lib/json/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"../node_modules/fs-extra/lib/json/jsonfile.js\")\n\njsonFile.outputJson = u(__webpack_require__(/*! ./output-json */ \"../node_modules/fs-extra/lib/json/output-json.js\"))\njsonFile.outputJsonSync = __webpack_require__(/*! ./output-json-sync */ \"../node_modules/fs-extra/lib/json/output-json-sync.js\")\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/json/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/json/jsonfile.js":
/*!*****************************************************!*\
  !*** ../node_modules/fs-extra/lib/json/jsonfile.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nconst jsonFile = __webpack_require__(/*! jsonfile */ \"../node_modules/fs-extra/node_modules/jsonfile/index.js\")\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: u(jsonFile.readFile),\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: u(jsonFile.writeFile),\n  writeJsonSync: jsonFile.writeFileSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/json/jsonfile.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/json/output-json-sync.js":
/*!*************************************************************!*\
  !*** ../node_modules/fs-extra/lib/json/output-json-sync.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"../node_modules/fs-extra/lib/json/jsonfile.js\")\n\nfunction outputJsonSync (file, data, options) {\n  const dir = path.dirname(file)\n\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  jsonFile.writeJsonSync(file, data, options)\n}\n\nmodule.exports = outputJsonSync\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/json/output-json-sync.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/json/output-json.js":
/*!********************************************************!*\
  !*** ../node_modules/fs-extra/lib/json/output-json.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\nconst jsonFile = __webpack_require__(/*! ./jsonfile */ \"../node_modules/fs-extra/lib/json/jsonfile.js\")\n\nfunction outputJson (file, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  const dir = path.dirname(file)\n\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n      jsonFile.writeJson(file, data, options, callback)\n    })\n  })\n}\n\nmodule.exports = outputJson\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/json/output-json.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/mkdirs/index.js":
/*!****************************************************!*\
  !*** ../node_modules/fs-extra/lib/mkdirs/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nconst mkdirs = u(__webpack_require__(/*! ./mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/mkdirs.js\"))\nconst mkdirsSync = __webpack_require__(/*! ./mkdirs-sync */ \"../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js\")\n\nmodule.exports = {\n  mkdirs,\n  mkdirsSync,\n  // alias\n  mkdirp: mkdirs,\n  mkdirpSync: mkdirsSync,\n  ensureDir: mkdirs,\n  ensureDirSync: mkdirsSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/mkdirs/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js":
/*!**********************************************************!*\
  !*** ../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst invalidWin32Path = __webpack_require__(/*! ./win32 */ \"../node_modules/fs-extra/lib/mkdirs/win32.js\").invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    throw errInval\n  }\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  } catch (err0) {\n    if (err0.code === 'ENOENT') {\n      if (path.dirname(p) === p) throw err0\n      made = mkdirsSync(path.dirname(p), opts, made)\n      mkdirsSync(p, opts, made)\n    } else {\n      // In the case of any other error, just see if there's a dir there\n      // already. If so, then hooray!  If not, then something is borked.\n      let stat\n      try {\n        stat = xfs.statSync(p)\n      } catch (err1) {\n        throw err0\n      }\n      if (!stat.isDirectory()) throw err0\n    }\n  }\n\n  return made\n}\n\nmodule.exports = mkdirsSync\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/mkdirs/mkdirs.js":
/*!*****************************************************!*\
  !*** ../node_modules/fs-extra/lib/mkdirs/mkdirs.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst invalidWin32Path = __webpack_require__(/*! ./win32 */ \"../node_modules/fs-extra/lib/mkdirs/win32.js\").invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirs (p, opts, callback, made) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    return callback(errInval)\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  callback = callback || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, er => {\n    if (!er) {\n      made = made || p\n      return callback(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) return callback(er)\n        mkdirs(path.dirname(p), opts, (er, made) => {\n          if (er) callback(er, made)\n          else mkdirs(p, opts, callback, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, (er2, stat) => {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) callback(er, made)\n          else callback(null, made)\n        })\n        break\n    }\n  })\n}\n\nmodule.exports = mkdirs\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/mkdirs/mkdirs.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/mkdirs/win32.js":
/*!****************************************************!*\
  !*** ../node_modules/fs-extra/lib/mkdirs/win32.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// get drive on windows\nfunction getRootPath (p) {\n  p = path.normalize(path.resolve(p)).split(path.sep)\n  if (p.length > 0) return p[0]\n  return null\n}\n\n// http://stackoverflow.com/a/62888/10333 contains more accurate\n// TODO: expand to include the rest\nconst INVALID_PATH_CHARS = /[<>:\"|?*]/\n\nfunction invalidWin32Path (p) {\n  const rp = getRootPath(p)\n  p = p.replace(rp, '')\n  return INVALID_PATH_CHARS.test(p)\n}\n\nmodule.exports = {\n  getRootPath,\n  invalidWin32Path\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/mkdirs/win32.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/move-sync/index.js":
/*!*******************************************************!*\
  !*** ../node_modules/fs-extra/lib/move-sync/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst copySync = __webpack_require__(/*! ../copy-sync */ \"../node_modules/fs-extra/lib/copy-sync/index.js\").copySync\nconst removeSync = __webpack_require__(/*! ../remove */ \"../node_modules/fs-extra/lib/remove/index.js\").removeSync\nconst mkdirpSync = __webpack_require__(/*! ../mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\").mkdirsSync\nconst buffer = __webpack_require__(/*! ../util/buffer */ \"../node_modules/fs-extra/lib/util/buffer.js\")\n\nfunction moveSync (src, dest, options) {\n  options = options || {}\n  const overwrite = options.overwrite || options.clobber || false\n\n  src = path.resolve(src)\n  dest = path.resolve(dest)\n\n  if (src === dest) return fs.accessSync(src)\n\n  if (isSrcSubdir(src, dest)) throw new Error(`Cannot move '${src}' into itself '${dest}'.`)\n\n  mkdirpSync(path.dirname(dest))\n  tryRenameSync()\n\n  function tryRenameSync () {\n    if (overwrite) {\n      try {\n        return fs.renameSync(src, dest)\n      } catch (err) {\n        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM') {\n          removeSync(dest)\n          options.overwrite = false // just overwriteed it, no need to do it again\n          return moveSync(src, dest, options)\n        }\n\n        if (err.code !== 'EXDEV') throw err\n        return moveSyncAcrossDevice(src, dest, overwrite)\n      }\n    } else {\n      try {\n        fs.linkSync(src, dest)\n        return fs.unlinkSync(src)\n      } catch (err) {\n        if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {\n          return moveSyncAcrossDevice(src, dest, overwrite)\n        }\n        throw err\n      }\n    }\n  }\n}\n\nfunction moveSyncAcrossDevice (src, dest, overwrite) {\n  const stat = fs.statSync(src)\n\n  if (stat.isDirectory()) {\n    return moveDirSyncAcrossDevice(src, dest, overwrite)\n  } else {\n    return moveFileSyncAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveFileSyncAcrossDevice (src, dest, overwrite) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = buffer(BUF_LENGTH)\n\n  const flags = overwrite ? 'w' : 'wx'\n\n  const fdr = fs.openSync(src, 'r')\n  const stat = fs.fstatSync(fdr)\n  const fdw = fs.openSync(dest, flags, stat.mode)\n  let pos = 0\n\n  while (pos < stat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n  return fs.unlinkSync(src)\n}\n\nfunction moveDirSyncAcrossDevice (src, dest, overwrite) {\n  const options = {\n    overwrite: false\n  }\n\n  if (overwrite) {\n    removeSync(dest)\n    tryCopySync()\n  } else {\n    tryCopySync()\n  }\n\n  function tryCopySync () {\n    copySync(src, dest, options)\n    return removeSync(src)\n  }\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// extract dest base dir and check if that is the same as src basename\nfunction isSrcSubdir (src, dest) {\n  try {\n    return fs.statSync(src).isDirectory() &&\n           src !== dest &&\n           dest.indexOf(src) > -1 &&\n           dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] === path.basename(src)\n  } catch (e) {\n    return false\n  }\n}\n\nmodule.exports = {\n  moveSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/move-sync/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/move/index.js":
/*!**************************************************!*\
  !*** ../node_modules/fs-extra/lib/move/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst copy = __webpack_require__(/*! ../copy */ \"../node_modules/fs-extra/lib/copy/index.js\").copy\nconst remove = __webpack_require__(/*! ../remove */ \"../node_modules/fs-extra/lib/remove/index.js\").remove\nconst mkdirp = __webpack_require__(/*! ../mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\").mkdirp\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  src = path.resolve(src)\n  dest = path.resolve(dest)\n\n  if (src === dest) return fs.access(src, cb)\n\n  fs.stat(src, (err, st) => {\n    if (err) return cb(err)\n\n    if (st.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`))\n    }\n    mkdirp(path.dirname(dest), err => {\n      if (err) return cb(err)\n      return doRename(src, dest, overwrite, cb)\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nfunction isSrcSubdir (src, dest) {\n  const srcArray = src.split(path.sep)\n  const destArray = dest.split(path.sep)\n\n  return srcArray.reduce((acc, current, i) => {\n    return acc && destArray[i] === current\n  }, true)\n}\n\nmodule.exports = {\n  move: u(move)\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/move/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/output/index.js":
/*!****************************************************!*\
  !*** ../node_modules/fs-extra/lib/output/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ../mkdirs */ \"../node_modules/fs-extra/lib/mkdirs/index.js\")\nconst pathExists = __webpack_require__(/*! ../path-exists */ \"../node_modules/fs-extra/lib/path-exists/index.js\").pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/output/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/path-exists/index.js":
/*!*********************************************************!*\
  !*** ../node_modules/fs-extra/lib/path-exists/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromPromise\nconst fs = __webpack_require__(/*! ../fs */ \"../node_modules/fs-extra/lib/fs/index.js\")\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/path-exists/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/remove/index.js":
/*!****************************************************!*\
  !*** ../node_modules/fs-extra/lib/remove/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst u = __webpack_require__(/*! universalify */ \"../node_modules/universalify/index.js\").fromCallback\nconst rimraf = __webpack_require__(/*! ./rimraf */ \"../node_modules/fs-extra/lib/remove/rimraf.js\")\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/remove/index.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/remove/rimraf.js":
/*!*****************************************************!*\
  !*** ../node_modules/fs-extra/lib/remove/rimraf.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst assert = __webpack_require__(/*! assert */ \"assert\")\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch (er) { }\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/remove/rimraf.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/util/buffer.js":
/*!***************************************************!*\
  !*** ../node_modules/fs-extra/lib/util/buffer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable node/no-deprecated-api */\nmodule.exports = function (size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    try {\n      return Buffer.allocUnsafe(size)\n    } catch (e) {\n      return new Buffer(size)\n    }\n  }\n  return new Buffer(size)\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/util/buffer.js?");

/***/ }),

/***/ "../node_modules/fs-extra/lib/util/utimes.js":
/*!***************************************************!*\
  !*** ../node_modules/fs-extra/lib/util/utimes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\nconst os = __webpack_require__(/*! os */ \"os\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\nfunction hasMillisResSync () {\n  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\n  const fd = fs.openSync(tmpfile, 'r+')\n  fs.futimesSync(fd, d, d)\n  fs.closeSync(fd)\n  return fs.statSync(tmpfile).mtime > 1435410243000\n}\n\nfunction hasMillisRes (callback) {\n  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {\n    if (err) return callback(err)\n    fs.open(tmpfile, 'r+', (err, fd) => {\n      if (err) return callback(err)\n      fs.futimes(fd, d, d, err => {\n        if (err) return callback(err)\n        fs.close(fd, err => {\n          if (err) return callback(err)\n          fs.stat(tmpfile, (err, stats) => {\n            if (err) return callback(err)\n            callback(null, stats.mtime > 1435410243000)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction timeRemoveMillis (timestamp) {\n  if (typeof timestamp === 'number') {\n    return Math.floor(timestamp / 1000) * 1000\n  } else if (timestamp instanceof Date) {\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\n  } else {\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\n  }\n}\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  hasMillisRes,\n  hasMillisResSync,\n  timeRemoveMillis,\n  utimesMillis,\n  utimesMillisSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/lib/util/utimes.js?");

/***/ }),

/***/ "../node_modules/fs-extra/node_modules/jsonfile/index.js":
/*!***************************************************************!*\
  !*** ../node_modules/fs-extra/node_modules/jsonfile/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _fs\ntry {\n  _fs = __webpack_require__(/*! graceful-fs */ \"../node_modules/graceful-fs/graceful-fs.js\")\n} catch (_) {\n  _fs = __webpack_require__(/*! fs */ \"fs\")\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  try {\n    var content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction stringify (obj, options) {\n  var spaces\n  var EOL = '\\n'\n  if (typeof options === 'object' && options !== null) {\n    if (options.spaces) {\n      spaces = options.spaces\n    }\n    if (options.EOL) {\n      EOL = options.EOL\n    }\n  }\n\n  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOL\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = ''\n  try {\n    str = stringify(obj, options)\n  } catch (err) {\n    // Need to return whether a callback was passed or not\n    if (callback) callback(err, null)\n    return\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n\n\n//# sourceURL=webpack:///../node_modules/fs-extra/node_modules/jsonfile/index.js?");

/***/ }),

/***/ "../node_modules/fs.realpath/index.js":
/*!********************************************!*\
  !*** ../node_modules/fs.realpath/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = __webpack_require__(/*! ./old.js */ \"../node_modules/fs.realpath/old.js\")\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/fs.realpath/index.js?");

/***/ }),

/***/ "../node_modules/fs.realpath/old.js":
/*!******************************************!*\
  !*** ../node_modules/fs.realpath/old.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = __webpack_require__(/*! path */ \"path\");\nvar isWindows = process.platform === 'win32';\nvar fs = __webpack_require__(/*! fs */ \"fs\");\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/fs.realpath/old.js?");

/***/ }),

/***/ "../node_modules/glob/common.js":
/*!**************************************!*\
  !*** ../node_modules/glob/common.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = __webpack_require__(/*! path */ \"path\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../node_modules/minimatch/minimatch.js\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../node_modules/path-is-absolute/index.js\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\n\n//# sourceURL=webpack:///../node_modules/glob/common.js?");

/***/ }),

/***/ "../node_modules/glob/glob.js":
/*!************************************!*\
  !*** ../node_modules/glob/glob.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar rp = __webpack_require__(/*! fs.realpath */ \"../node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar inherits = __webpack_require__(/*! inherits */ \"../node_modules/inherits/inherits.js\")\nvar EE = __webpack_require__(/*! events */ \"events\").EventEmitter\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../node_modules/path-is-absolute/index.js\")\nvar globSync = __webpack_require__(/*! ./sync.js */ \"../node_modules/glob/sync.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"../node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = __webpack_require__(/*! inflight */ \"../node_modules/inflight/inflight.js\")\nvar util = __webpack_require__(/*! util */ \"util\")\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = __webpack_require__(/*! once */ \"../node_modules/once/once.js\")\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n\n\n//# sourceURL=webpack:///../node_modules/glob/glob.js?");

/***/ }),

/***/ "../node_modules/glob/sync.js":
/*!************************************!*\
  !*** ../node_modules/glob/sync.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar rp = __webpack_require__(/*! fs.realpath */ \"../node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar Glob = __webpack_require__(/*! ./glob.js */ \"../node_modules/glob/glob.js\").Glob\nvar util = __webpack_require__(/*! util */ \"util\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../node_modules/path-is-absolute/index.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"../node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\n\n//# sourceURL=webpack:///../node_modules/glob/sync.js?");

/***/ }),

/***/ "../node_modules/graceful-fs/clone.js":
/*!********************************************!*\
  !*** ../node_modules/graceful-fs/clone.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n\n\n//# sourceURL=webpack:///../node_modules/graceful-fs/clone.js?");

/***/ }),

/***/ "../node_modules/graceful-fs/graceful-fs.js":
/*!**************************************************!*\
  !*** ../node_modules/graceful-fs/graceful-fs.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar polyfills = __webpack_require__(/*! ./polyfills.js */ \"../node_modules/graceful-fs/polyfills.js\")\nvar legacy = __webpack_require__(/*! ./legacy-streams.js */ \"../node_modules/graceful-fs/legacy-streams.js\")\nvar clone = __webpack_require__(/*! ./clone.js */ \"../node_modules/graceful-fs/clone.js\")\n\nvar queue = []\n\nvar util = __webpack_require__(/*! util */ \"util\")\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\nif (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n  process.on('exit', function() {\n    debug(queue)\n    __webpack_require__(/*! assert */ \"assert\").equal(queue.length, 0)\n  })\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\n// Always patch fs.close/closeSync, because we want to\n// retry() whenever a close happens *anywhere* in the program.\n// This is essential when multiple graceful-fs instances are\n// in play at the same time.\nmodule.exports.close = (function (fs$close) { return function (fd, cb) {\n  return fs$close.call(fs, fd, function (err) {\n    if (!err)\n      retry()\n\n    if (typeof cb === 'function')\n      cb.apply(this, arguments)\n  })\n}})(fs.close)\n\nmodule.exports.closeSync = (function (fs$closeSync) { return function (fd) {\n  // Note that graceful-fs also retries when fs.closeSync() fails.\n  // Looks like a bug to me, although it's probably a harmless one.\n  var rval = fs$closeSync.apply(fs, arguments)\n  retry()\n  return rval\n}})(fs.closeSync)\n\n// Only patch fs once, otherwise we'll run into a memory leak if\n// graceful-fs is loaded multiple times, such as in test environments that\n// reset the loaded modules between tests.\n// We look for the string `graceful-fs` from the comment above. This\n// way we are not adding any extra properties and it will detect if older\n// versions of graceful-fs are installed.\nif (!/\\bgraceful-fs\\b/.test(fs.closeSync.toString())) {\n  fs.closeSync = module.exports.closeSync;\n  fs.close = module.exports.close;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n  fs.FileReadStream = ReadStream;  // Legacy name.\n  fs.FileWriteStream = WriteStream;  // Legacy name.\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  fs.ReadStream = ReadStream\n  fs.WriteStream = WriteStream\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  queue.push(elem)\n}\n\nfunction retry () {\n  var elem = queue.shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n\n\n//# sourceURL=webpack:///../node_modules/graceful-fs/graceful-fs.js?");

/***/ }),

/***/ "../node_modules/graceful-fs/legacy-streams.js":
/*!*****************************************************!*\
  !*** ../node_modules/graceful-fs/legacy-streams.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\").Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///../node_modules/graceful-fs/legacy-streams.js?");

/***/ }),

/***/ "../node_modules/graceful-fs/polyfills.js":
/*!************************************************!*\
  !*** ../node_modules/graceful-fs/polyfills.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var constants = __webpack_require__(/*! constants */ \"constants\")\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {\n    var callback\n    if (callback_ && typeof callback_ === 'function') {\n      var eagCounter = 0\n      callback = function (er, _, __) {\n        if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n        }\n        callback_.apply(this, arguments)\n      }\n    }\n    return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n  }})(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, cb) {\n      return orig.call(fs, target, function (er, stats) {\n        if (!stats) return cb.apply(this, arguments)\n        if (stats.uid < 0) stats.uid += 0x100000000\n        if (stats.gid < 0) stats.gid += 0x100000000\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target) {\n      var stats = orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n\n\n//# sourceURL=webpack:///../node_modules/graceful-fs/polyfills.js?");

/***/ }),

/***/ "../node_modules/immediate/lib/index.js":
/*!**********************************************!*\
  !*** ../node_modules/immediate/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\nif (process.browser) {\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n} else {\n  scheduleDrain = function () {\n    process.nextTick(nextTick);\n  };\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n//# sourceURL=webpack:///../node_modules/immediate/lib/index.js?");

/***/ }),

/***/ "../node_modules/inflight/inflight.js":
/*!********************************************!*\
  !*** ../node_modules/inflight/inflight.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"../node_modules/wrappy/wrappy.js\")\nvar reqs = Object.create(null)\nvar once = __webpack_require__(/*! once */ \"../node_modules/once/once.js\")\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n\n\n//# sourceURL=webpack:///../node_modules/inflight/inflight.js?");

/***/ }),

/***/ "../node_modules/inherits/inherits.js":
/*!********************************************!*\
  !*** ../node_modules/inherits/inherits.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("try {\n  var util = __webpack_require__(/*! util */ \"util\");\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./inherits_browser.js */ \"../node_modules/inherits/inherits_browser.js\");\n}\n\n\n//# sourceURL=webpack:///../node_modules/inherits/inherits.js?");

/***/ }),

/***/ "../node_modules/inherits/inherits_browser.js":
/*!****************************************************!*\
  !*** ../node_modules/inherits/inherits_browser.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:///../node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "../node_modules/isarray/index.js":
/*!****************************************!*\
  !*** ../node_modules/isarray/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///../node_modules/isarray/index.js?");

/***/ }),

/***/ "../node_modules/jpeg-js/index.js":
/*!****************************************!*\
  !*** ../node_modules/jpeg-js/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var encode = __webpack_require__(/*! ./lib/encoder */ \"../node_modules/jpeg-js/lib/encoder.js\"),\n    decode = __webpack_require__(/*! ./lib/decoder */ \"../node_modules/jpeg-js/lib/decoder.js\");\n\nmodule.exports = {\n  encode: encode,\n  decode: decode\n};\n\n\n//# sourceURL=webpack:///../node_modules/jpeg-js/index.js?");

/***/ }),

/***/ "../node_modules/jpeg-js/lib/decoder.js":
/*!**********************************************!*\
  !*** ../node_modules/jpeg-js/lib/decoder.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nvar JpegImage = (function jpegImage() {\n  \"use strict\";\n  var dctZigZag = new Int32Array([\n     0,\n     1,  8,\n    16,  9,  2,\n     3, 10, 17, 24,\n    32, 25, 18, 11, 4,\n     5, 12, 19, 26, 33, 40,\n    48, 41, 34, 27, 20, 13,  6,\n     7, 14, 21, 28, 35, 42, 49, 56,\n    57, 50, 43, 36, 29, 22, 15,\n    23, 30, 37, 44, 51, 58,\n    59, 52, 45, 38, 31,\n    39, 46, 53, 60,\n    61, 54, 47,\n    55, 62,\n    63\n  ]);\n\n  var dctCos1  =  4017   // cos(pi/16)\n  var dctSin1  =   799   // sin(pi/16)\n  var dctCos3  =  3406   // cos(3*pi/16)\n  var dctSin3  =  2276   // sin(3*pi/16)\n  var dctCos6  =  1567   // cos(6*pi/16)\n  var dctSin6  =  3784   // sin(6*pi/16)\n  var dctSqrt2 =  5793   // sqrt(2)\n  var dctSqrt1d2 = 2896  // sqrt(2) / 2\n\n  function constructor() {\n  }\n\n  function buildHuffmanTable(codeLengths, values) {\n    var k = 0, code = [], i, j, length = 16;\n    while (length > 0 && !codeLengths[length - 1])\n      length--;\n    code.push({children: [], index: 0});\n    var p = code[0], q;\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < codeLengths[i]; j++) {\n        p = code.pop();\n        p.children[p.index] = values[k];\n        while (p.index > 0) {\n          p = code.pop();\n        }\n        p.index++;\n        code.push(p);\n        while (code.length <= i) {\n          code.push(q = {children: [], index: 0});\n          p.children[p.index] = q.children;\n          p = q;\n        }\n        k++;\n      }\n      if (i + 1 < length) {\n        // p here points to last code\n        code.push(q = {children: [], index: 0});\n        p.children[p.index] = q.children;\n        p = q;\n      }\n    }\n    return code[0].children;\n  }\n\n  function decodeScan(data, offset,\n                      frame, components, resetInterval,\n                      spectralStart, spectralEnd,\n                      successivePrev, successive) {\n    var precision = frame.precision;\n    var samplesPerLine = frame.samplesPerLine;\n    var scanLines = frame.scanLines;\n    var mcusPerLine = frame.mcusPerLine;\n    var progressive = frame.progressive;\n    var maxH = frame.maxH, maxV = frame.maxV;\n\n    var startOffset = offset, bitsData = 0, bitsCount = 0;\n    function readBit() {\n      if (bitsCount > 0) {\n        bitsCount--;\n        return (bitsData >> bitsCount) & 1;\n      }\n      bitsData = data[offset++];\n      if (bitsData == 0xFF) {\n        var nextByte = data[offset++];\n        if (nextByte) {\n          throw \"unexpected marker: \" + ((bitsData << 8) | nextByte).toString(16);\n        }\n        // unstuff 0\n      }\n      bitsCount = 7;\n      return bitsData >>> 7;\n    }\n    function decodeHuffman(tree) {\n      var node = tree, bit;\n      while ((bit = readBit()) !== null) {\n        node = node[bit];\n        if (typeof node === 'number')\n          return node;\n        if (typeof node !== 'object')\n          throw \"invalid huffman sequence\";\n      }\n      return null;\n    }\n    function receive(length) {\n      var n = 0;\n      while (length > 0) {\n        var bit = readBit();\n        if (bit === null) return;\n        n = (n << 1) | bit;\n        length--;\n      }\n      return n;\n    }\n    function receiveAndExtend(length) {\n      var n = receive(length);\n      if (n >= 1 << (length - 1))\n        return n;\n      return n + (-1 << length) + 1;\n    }\n    function decodeBaseline(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t);\n      zz[0]= (component.pred += diff);\n      var k = 1;\n      while (k < 64) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15)\n            break;\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n    function decodeDCFirst(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n      zz[0] = (component.pred += diff);\n    }\n    function decodeDCSuccessive(component, zz) {\n      zz[0] |= readBit() << successive;\n    }\n    var eobrun = 0;\n    function decodeACFirst(component, zz) {\n      if (eobrun > 0) {\n        eobrun--;\n        return;\n      }\n      var k = spectralStart, e = spectralEnd;\n      while (k <= e) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15) {\n            eobrun = receive(r) + (1 << r) - 1;\n            break;\n          }\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n    var successiveACState = 0, successiveACNextValue;\n    function decodeACSuccessive(component, zz) {\n      var k = spectralStart, e = spectralEnd, r = 0;\n      while (k <= e) {\n        var z = dctZigZag[k];\n        switch (successiveACState) {\n        case 0: // initial state\n          var rs = decodeHuffman(component.huffmanTableAC);\n          var s = rs & 15, r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1)\n              throw \"invalid ACn encoding\";\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue;\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z])\n            zz[z] += (readBit() << successive);\n          else {\n            r--;\n            if (r === 0)\n              successiveACState = successiveACState == 2 ? 3 : 0;\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z])\n            zz[z] += (readBit() << successive);\n          else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z])\n            zz[z] += (readBit() << successive);\n          break;\n        }\n        k++;\n      }\n      if (successiveACState === 4) {\n        eobrun--;\n        if (eobrun === 0)\n          successiveACState = 0;\n      }\n    }\n    function decodeMcu(component, decode, mcu, row, col) {\n      var mcuRow = (mcu / mcusPerLine) | 0;\n      var mcuCol = mcu % mcusPerLine;\n      var blockRow = mcuRow * component.v + row;\n      var blockCol = mcuCol * component.h + col;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n    function decodeBlock(component, decode, mcu) {\n      var blockRow = (mcu / component.blocksPerLine) | 0;\n      var blockCol = mcu % component.blocksPerLine;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n\n    var componentsLength = components.length;\n    var component, i, j, k, n;\n    var decodeFn;\n    if (progressive) {\n      if (spectralStart === 0)\n        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n      else\n        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    } else {\n      decodeFn = decodeBaseline;\n    }\n\n    var mcu = 0, marker;\n    var mcuExpected;\n    if (componentsLength == 1) {\n      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    } else {\n      mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n    if (!resetInterval) resetInterval = mcuExpected;\n\n    var h, v;\n    while (mcu < mcuExpected) {\n      // reset interval stuff\n      for (i = 0; i < componentsLength; i++)\n        components[i].pred = 0;\n      eobrun = 0;\n\n      if (componentsLength == 1) {\n        component = components[0];\n        for (n = 0; n < resetInterval; n++) {\n          decodeBlock(component, decodeFn, mcu);\n          mcu++;\n        }\n      } else {\n        for (n = 0; n < resetInterval; n++) {\n          for (i = 0; i < componentsLength; i++) {\n            component = components[i];\n            h = component.h;\n            v = component.v;\n            for (j = 0; j < v; j++) {\n              for (k = 0; k < h; k++) {\n                decodeMcu(component, decodeFn, mcu, j, k);\n              }\n            }\n          }\n          mcu++;\n\n          // If we've reached our expected MCU's, stop decoding\n          if (mcu === mcuExpected) break;\n        }\n      }\n\n      // find marker\n      bitsCount = 0;\n      marker = (data[offset] << 8) | data[offset + 1];\n      if (marker < 0xFF00) {\n        throw \"marker was not found\";\n      }\n\n      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n        offset += 2;\n      }\n      else\n        break;\n    }\n\n    return offset - startOffset;\n  }\n\n  function buildComponentData(frame, component) {\n    var lines = [];\n    var blocksPerLine = component.blocksPerLine;\n    var blocksPerColumn = component.blocksPerColumn;\n    var samplesPerLine = blocksPerLine << 3;\n    var R = new Int32Array(64), r = new Uint8Array(64);\n\n    // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n    function quantizeAndInverse(zz, dataOut, dataIn) {\n      var qt = component.quantizationTable;\n      var v0, v1, v2, v3, v4, v5, v6, v7, t;\n      var p = dataIn;\n      var i;\n\n      // dequant\n      for (i = 0; i < 64; i++)\n        p[i] = zz[i] * qt[i];\n\n      // inverse DCT on rows\n      for (i = 0; i < 8; ++i) {\n        var row = 8 * i;\n\n        // check for all-zero AC coefficients\n        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&\n            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&\n            p[7 + row] == 0) {\n          t = (dctSqrt2 * p[0 + row] + 512) >> 10;\n          p[0 + row] = t;\n          p[1 + row] = t;\n          p[2 + row] = t;\n          p[3 + row] = t;\n          p[4 + row] = t;\n          p[5 + row] = t;\n          p[6 + row] = t;\n          p[7 + row] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;\n        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;\n        v2 = p[2 + row];\n        v3 = p[6 + row];\n        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;\n        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;\n        v5 = p[3 + row] << 4;\n        v6 = p[5 + row] << 4;\n\n        // stage 3\n        t = (v0 - v1+ 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0 + row] = v0 + v7;\n        p[7 + row] = v0 - v7;\n        p[1 + row] = v1 + v6;\n        p[6 + row] = v1 - v6;\n        p[2 + row] = v2 + v5;\n        p[5 + row] = v2 - v5;\n        p[3 + row] = v3 + v4;\n        p[4 + row] = v3 - v4;\n      }\n\n      // inverse DCT on columns\n      for (i = 0; i < 8; ++i) {\n        var col = i;\n\n        // check for all-zero AC coefficients\n        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&\n            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&\n            p[7*8 + col] == 0) {\n          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;\n          p[0*8 + col] = t;\n          p[1*8 + col] = t;\n          p[2*8 + col] = t;\n          p[3*8 + col] = t;\n          p[4*8 + col] = t;\n          p[5*8 + col] = t;\n          p[6*8 + col] = t;\n          p[7*8 + col] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;\n        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;\n        v2 = p[2*8 + col];\n        v3 = p[6*8 + col];\n        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;\n        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;\n        v5 = p[3*8 + col];\n        v6 = p[5*8 + col];\n\n        // stage 3\n        t = (v0 - v1 + 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0*8 + col] = v0 + v7;\n        p[7*8 + col] = v0 - v7;\n        p[1*8 + col] = v1 + v6;\n        p[6*8 + col] = v1 - v6;\n        p[2*8 + col] = v2 + v5;\n        p[5*8 + col] = v2 - v5;\n        p[3*8 + col] = v3 + v4;\n        p[4*8 + col] = v3 - v4;\n      }\n\n      // convert to 8-bit integers\n      for (i = 0; i < 64; ++i) {\n        var sample = 128 + ((p[i] + 8) >> 4);\n        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;\n      }\n    }\n\n    var i, j;\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n      var scanLine = blockRow << 3;\n      for (i = 0; i < 8; i++)\n        lines.push(new Uint8Array(samplesPerLine));\n      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n        var offset = 0, sample = blockCol << 3;\n        for (j = 0; j < 8; j++) {\n          var line = lines[scanLine + j];\n          for (i = 0; i < 8; i++)\n            line[sample + i] = r[offset++];\n        }\n      }\n    }\n    return lines;\n  }\n\n  function clampTo8bit(a) {\n    return a < 0 ? 0 : a > 255 ? 255 : a;\n  }\n\n  constructor.prototype = {\n    load: function load(path) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", path, true);\n      xhr.responseType = \"arraybuffer\";\n      xhr.onload = (function() {\n        // TODO catch parse error\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        this.parse(data);\n        if (this.onload)\n          this.onload();\n      }).bind(this);\n      xhr.send(null);\n    },\n    parse: function parse(data) {\n      var offset = 0, length = data.length;\n      function readUint16() {\n        var value = (data[offset] << 8) | data[offset + 1];\n        offset += 2;\n        return value;\n      }\n      function readDataBlock() {\n        var length = readUint16();\n        var array = data.subarray(offset, offset + length - 2);\n        offset += array.length;\n        return array;\n      }\n      function prepareComponents(frame) {\n        var maxH = 0, maxV = 0;\n        var component, componentId;\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            if (maxH < component.h) maxH = component.h;\n            if (maxV < component.v) maxV = component.v;\n          }\n        }\n        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);\n            var blocksPerLineForMcu = mcusPerLine * component.h;\n            var blocksPerColumnForMcu = mcusPerColumn * component.v;\n            var blocks = [];\n            for (var i = 0; i < blocksPerColumnForMcu; i++) {\n              var row = [];\n              for (var j = 0; j < blocksPerLineForMcu; j++)\n                row.push(new Int32Array(64));\n              blocks.push(row);\n            }\n            component.blocksPerLine = blocksPerLine;\n            component.blocksPerColumn = blocksPerColumn;\n            component.blocks = blocks;\n          }\n        }\n        frame.maxH = maxH;\n        frame.maxV = maxV;\n        frame.mcusPerLine = mcusPerLine;\n        frame.mcusPerColumn = mcusPerColumn;\n      }\n      var jfif = null;\n      var adobe = null;\n      var pixels = null;\n      var frame, resetInterval;\n      var quantizationTables = [], frames = [];\n      var huffmanTablesAC = [], huffmanTablesDC = [];\n      var fileMarker = readUint16();\n      if (fileMarker != 0xFFD8) { // SOI (Start of Image)\n        throw \"SOI not found\";\n      }\n\n      fileMarker = readUint16();\n      while (fileMarker != 0xFFD9) { // EOI (End of image)\n        var i, j, l;\n        switch(fileMarker) {\n          case 0xFF00: break;\n          case 0xFFE0: // APP0 (Application Specific)\n          case 0xFFE1: // APP1\n          case 0xFFE2: // APP2\n          case 0xFFE3: // APP3\n          case 0xFFE4: // APP4\n          case 0xFFE5: // APP5\n          case 0xFFE6: // APP6\n          case 0xFFE7: // APP7\n          case 0xFFE8: // APP8\n          case 0xFFE9: // APP9\n          case 0xFFEA: // APP10\n          case 0xFFEB: // APP11\n          case 0xFFEC: // APP12\n          case 0xFFED: // APP13\n          case 0xFFEE: // APP14\n          case 0xFFEF: // APP15\n          case 0xFFFE: // COM (Comment)\n            var appData = readDataBlock();\n\n            if (fileMarker === 0xFFE0) {\n              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&\n                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n                jfif = {\n                  version: { major: appData[5], minor: appData[6] },\n                  densityUnits: appData[7],\n                  xDensity: (appData[8] << 8) | appData[9],\n                  yDensity: (appData[10] << 8) | appData[11],\n                  thumbWidth: appData[12],\n                  thumbHeight: appData[13],\n                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                };\n              }\n            }\n            // TODO APP1 - Exif\n            if (fileMarker === 0xFFEE) {\n              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&\n                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n                adobe = {\n                  version: appData[6],\n                  flags0: (appData[7] << 8) | appData[8],\n                  flags1: (appData[9] << 8) | appData[10],\n                  transformCode: appData[11]\n                };\n              }\n            }\n            break;\n\n          case 0xFFDB: // DQT (Define Quantization Tables)\n            var quantizationTablesLength = readUint16();\n            var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n            while (offset < quantizationTablesEnd) {\n              var quantizationTableSpec = data[offset++];\n              var tableData = new Int32Array(64);\n              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = data[offset++];\n                }\n              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = readUint16();\n                }\n              } else\n                throw \"DQT: invalid table spec\";\n              quantizationTables[quantizationTableSpec & 15] = tableData;\n            }\n            break;\n\n          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)\n            readUint16(); // skip data length\n            frame = {};\n            frame.extended = (fileMarker === 0xFFC1);\n            frame.progressive = (fileMarker === 0xFFC2);\n            frame.precision = data[offset++];\n            frame.scanLines = readUint16();\n            frame.samplesPerLine = readUint16();\n            frame.components = {};\n            frame.componentsOrder = [];\n            var componentsCount = data[offset++], componentId;\n            var maxH = 0, maxV = 0;\n            for (i = 0; i < componentsCount; i++) {\n              componentId = data[offset];\n              var h = data[offset + 1] >> 4;\n              var v = data[offset + 1] & 15;\n              var qId = data[offset + 2];\n              frame.componentsOrder.push(componentId);\n              frame.components[componentId] = {\n                h: h,\n                v: v,\n                quantizationIdx: qId\n              };\n              offset += 3;\n            }\n            prepareComponents(frame);\n            frames.push(frame);\n            break;\n\n          case 0xFFC4: // DHT (Define Huffman Tables)\n            var huffmanLength = readUint16();\n            for (i = 2; i < huffmanLength;) {\n              var huffmanTableSpec = data[offset++];\n              var codeLengths = new Uint8Array(16);\n              var codeLengthSum = 0;\n              for (j = 0; j < 16; j++, offset++)\n                codeLengthSum += (codeLengths[j] = data[offset]);\n              var huffmanValues = new Uint8Array(codeLengthSum);\n              for (j = 0; j < codeLengthSum; j++, offset++)\n                huffmanValues[j] = data[offset];\n              i += 17 + codeLengthSum;\n\n              ((huffmanTableSpec >> 4) === 0 ? \n                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =\n                buildHuffmanTable(codeLengths, huffmanValues);\n            }\n            break;\n\n          case 0xFFDD: // DRI (Define Restart Interval)\n            readUint16(); // skip data length\n            resetInterval = readUint16();\n            break;\n\n          case 0xFFDA: // SOS (Start of Scan)\n            var scanLength = readUint16();\n            var selectorsCount = data[offset++];\n            var components = [], component;\n            for (i = 0; i < selectorsCount; i++) {\n              component = frame.components[data[offset++]];\n              var tableSpec = data[offset++];\n              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n              components.push(component);\n            }\n            var spectralStart = data[offset++];\n            var spectralEnd = data[offset++];\n            var successiveApproximation = data[offset++];\n            var processed = decodeScan(data, offset,\n              frame, components, resetInterval,\n              spectralStart, spectralEnd,\n              successiveApproximation >> 4, successiveApproximation & 15);\n            offset += processed;\n            break;\n          default:\n            if (data[offset - 3] == 0xFF &&\n                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n              // could be incorrect encoding -- last 0xFF byte of the previous\n              // block was eaten by the encoder\n              offset -= 3;\n              break;\n            }\n            throw \"unknown JPEG marker \" + fileMarker.toString(16);\n        }\n        fileMarker = readUint16();\n      }\n      if (frames.length != 1)\n        throw \"only single frame JPEGs supported\";\n\n      // set each frame's components quantization table\n      for (var i = 0; i < frames.length; i++) {\n        var cp = frames[i].components;\n        for (var j in cp) {\n          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];\n          delete cp[j].quantizationIdx;\n        }\n      }\n\n      this.width = frame.samplesPerLine;\n      this.height = frame.scanLines;\n      this.jfif = jfif;\n      this.adobe = adobe;\n      this.components = [];\n      for (var i = 0; i < frame.componentsOrder.length; i++) {\n        var component = frame.components[frame.componentsOrder[i]];\n        this.components.push({\n          lines: buildComponentData(frame, component),\n          scaleX: component.h / frame.maxH,\n          scaleY: component.v / frame.maxV\n        });\n      }\n    },\n    getData: function getData(width, height) {\n      var scaleX = this.width / width, scaleY = this.height / height;\n\n      var component1, component2, component3, component4;\n      var component1Line, component2Line, component3Line, component4Line;\n      var x, y;\n      var offset = 0;\n      var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n      var colorTransform;\n      var dataLength = width * height * this.components.length;\n      var data = new Uint8Array(dataLength);\n      switch (this.components.length) {\n        case 1:\n          component1 = this.components[0];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 2:\n          // PDF might compress two component data in custom colorspace\n          component1 = this.components[0];\n          component2 = this.components[1];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n              data[offset++] = Y;\n              Y = component2Line[0 | (x * component2.scaleX * scaleX)];\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 3:\n          // The default transform for three components is true\n          colorTransform = true;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.colorTransform !== 'undefined')\n            colorTransform = !!this.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                R = component1Line[0 | (x * component1.scaleX * scaleX)];\n                G = component2Line[0 | (x * component2.scaleX * scaleX)];\n                B = component3Line[0 | (x * component3.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n\n                R = clampTo8bit(Y + 1.402 * (Cr - 128));\n                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                B = clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n\n              data[offset++] = R;\n              data[offset++] = G;\n              data[offset++] = B;\n            }\n          }\n          break;\n        case 4:\n          if (!this.adobe)\n            throw 'Unsupported color mode (4 components)';\n          // The default transform for four components is false\n          colorTransform = false;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.colorTransform !== 'undefined')\n            colorTransform = !!this.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          component4 = this.components[3];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                C = component1Line[0 | (x * component1.scaleX * scaleX)];\n                M = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n\n                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));\n                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n              data[offset++] = 255-C;\n              data[offset++] = 255-M;\n              data[offset++] = 255-Ye;\n              data[offset++] = 255-K;\n            }\n          }\n          break;\n        default:\n          throw 'Unsupported color mode';\n      }\n      return data;\n    },\n    copyToImageData: function copyToImageData(imageData) {\n      var width = imageData.width, height = imageData.height;\n      var imageDataArray = imageData.data;\n      var data = this.getData(width, height);\n      var i = 0, j = 0, x, y;\n      var Y, K, C, M, R, G, B;\n      switch (this.components.length) {\n        case 1:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              Y = data[i++];\n\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = 255;\n            }\n          }\n          break;\n        case 3:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              R = data[i++];\n              G = data[i++];\n              B = data[i++];\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              imageDataArray[j++] = 255;\n            }\n          }\n          break;\n        case 4:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              C = data[i++];\n              M = data[i++];\n              Y = data[i++];\n              K = data[i++];\n\n              R = 255 - clampTo8bit(C * (1 - K / 255) + K);\n              G = 255 - clampTo8bit(M * (1 - K / 255) + K);\n              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              imageDataArray[j++] = 255;\n            }\n          }\n          break;\n        default:\n          throw 'Unsupported color mode';\n      }\n    }\n  };\n\n  return constructor;\n})();\nmodule.exports = decode;\n\nfunction decode(jpegData, useTArray) {\n  var arr = new Uint8Array(jpegData);\n  var decoder = new JpegImage();\n  decoder.parse(arr);\n\n  var image = {\n    width: decoder.width,\n    height: decoder.height,\n    data: useTArray ?\n      new Uint8Array(decoder.width * decoder.height * 4) :\n      new Buffer(decoder.width * decoder.height * 4)\n  };\n\n  decoder.copyToImageData(image);\n\n  return image;\n}\n\n\n//# sourceURL=webpack:///../node_modules/jpeg-js/lib/decoder.js?");

/***/ }),

/***/ "../node_modules/jpeg-js/lib/encoder.js":
/*!**********************************************!*\
  !*** ../node_modules/jpeg-js/lib/encoder.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n  Copyright (c) 2008, Adobe Systems Incorporated\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without \n  modification, are permitted provided that the following conditions are\n  met:\n\n  * Redistributions of source code must retain the above copyright notice, \n    this list of conditions and the following disclaimer.\n  \n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the \n    documentation and/or other materials provided with the distribution.\n  \n  * Neither the name of Adobe Systems Incorporated nor the names of its \n    contributors may be used to endorse or promote products derived from \n    this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR \n  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\nJPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009\n\nBasic GUI blocking jpeg encoder\n*/\n\nvar btoa = btoa || function(buf) {\n  return new Buffer(buf).toString('base64');\n};\n\nfunction JPEGEncoder(quality) {\n  var self = this;\n\tvar fround = Math.round;\n\tvar ffloor = Math.floor;\n\tvar YTable = new Array(64);\n\tvar UVTable = new Array(64);\n\tvar fdtbl_Y = new Array(64);\n\tvar fdtbl_UV = new Array(64);\n\tvar YDC_HT;\n\tvar UVDC_HT;\n\tvar YAC_HT;\n\tvar UVAC_HT;\n\t\n\tvar bitcode = new Array(65535);\n\tvar category = new Array(65535);\n\tvar outputfDCTQuant = new Array(64);\n\tvar DU = new Array(64);\n\tvar byteout = [];\n\tvar bytenew = 0;\n\tvar bytepos = 7;\n\t\n\tvar YDU = new Array(64);\n\tvar UDU = new Array(64);\n\tvar VDU = new Array(64);\n\tvar clt = new Array(256);\n\tvar RGB_YUV_TABLE = new Array(2048);\n\tvar currentQuality;\n\t\n\tvar ZigZag = [\n\t\t\t 0, 1, 5, 6,14,15,27,28,\n\t\t\t 2, 4, 7,13,16,26,29,42,\n\t\t\t 3, 8,12,17,25,30,41,43,\n\t\t\t 9,11,18,24,31,40,44,53,\n\t\t\t10,19,23,32,39,45,52,54,\n\t\t\t20,22,33,38,46,51,55,60,\n\t\t\t21,34,37,47,50,56,59,61,\n\t\t\t35,36,48,49,57,58,62,63\n\t\t];\n\t\n\tvar std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];\n\tvar std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];\n\tvar std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];\n\tvar std_ac_luminance_values = [\n\t\t\t0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,\n\t\t\t0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,\n\t\t\t0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,\n\t\t\t0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,\n\t\t\t0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,\n\t\t\t0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,\n\t\t\t0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,\n\t\t\t0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,\n\t\t\t0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,\n\t\t\t0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,\n\t\t\t0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,\n\t\t\t0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,\n\t\t\t0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,\n\t\t\t0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,\n\t\t\t0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,\n\t\t\t0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,\n\t\t\t0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,\n\t\t\t0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,\n\t\t\t0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,\n\t\t\t0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,\n\t\t\t0xf9,0xfa\n\t\t];\n\t\n\tvar std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];\n\tvar std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];\n\tvar std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];\n\tvar std_ac_chrominance_values = [\n\t\t\t0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,\n\t\t\t0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,\n\t\t\t0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,\n\t\t\t0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,\n\t\t\t0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,\n\t\t\t0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,\n\t\t\t0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,\n\t\t\t0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,\n\t\t\t0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,\n\t\t\t0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,\n\t\t\t0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,\n\t\t\t0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,\n\t\t\t0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,\n\t\t\t0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,\n\t\t\t0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,\n\t\t\t0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,\n\t\t\t0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,\n\t\t\t0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,\n\t\t\t0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,\n\t\t\t0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,\n\t\t\t0xf9,0xfa\n\t\t];\n\t\n\tfunction initQuantTables(sf){\n\t\t\tvar YQT = [\n\t\t\t\t16, 11, 10, 16, 24, 40, 51, 61,\n\t\t\t\t12, 12, 14, 19, 26, 58, 60, 55,\n\t\t\t\t14, 13, 16, 24, 40, 57, 69, 56,\n\t\t\t\t14, 17, 22, 29, 51, 87, 80, 62,\n\t\t\t\t18, 22, 37, 56, 68,109,103, 77,\n\t\t\t\t24, 35, 55, 64, 81,104,113, 92,\n\t\t\t\t49, 64, 78, 87,103,121,120,101,\n\t\t\t\t72, 92, 95, 98,112,100,103, 99\n\t\t\t];\n\t\t\t\n\t\t\tfor (var i = 0; i < 64; i++) {\n\t\t\t\tvar t = ffloor((YQT[i]*sf+50)/100);\n\t\t\t\tif (t < 1) {\n\t\t\t\t\tt = 1;\n\t\t\t\t} else if (t > 255) {\n\t\t\t\t\tt = 255;\n\t\t\t\t}\n\t\t\t\tYTable[ZigZag[i]] = t;\n\t\t\t}\n\t\t\tvar UVQT = [\n\t\t\t\t17, 18, 24, 47, 99, 99, 99, 99,\n\t\t\t\t18, 21, 26, 66, 99, 99, 99, 99,\n\t\t\t\t24, 26, 56, 99, 99, 99, 99, 99,\n\t\t\t\t47, 66, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99\n\t\t\t];\n\t\t\tfor (var j = 0; j < 64; j++) {\n\t\t\t\tvar u = ffloor((UVQT[j]*sf+50)/100);\n\t\t\t\tif (u < 1) {\n\t\t\t\t\tu = 1;\n\t\t\t\t} else if (u > 255) {\n\t\t\t\t\tu = 255;\n\t\t\t\t}\n\t\t\t\tUVTable[ZigZag[j]] = u;\n\t\t\t}\n\t\t\tvar aasf = [\n\t\t\t\t1.0, 1.387039845, 1.306562965, 1.175875602,\n\t\t\t\t1.0, 0.785694958, 0.541196100, 0.275899379\n\t\t\t];\n\t\t\tvar k = 0;\n\t\t\tfor (var row = 0; row < 8; row++)\n\t\t\t{\n\t\t\t\tfor (var col = 0; col < 8; col++)\n\t\t\t\t{\n\t\t\t\t\tfdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));\n\t\t\t\t\tfdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction computeHuffmanTbl(nrcodes, std_table){\n\t\t\tvar codevalue = 0;\n\t\t\tvar pos_in_table = 0;\n\t\t\tvar HT = new Array();\n\t\t\tfor (var k = 1; k <= 16; k++) {\n\t\t\t\tfor (var j = 1; j <= nrcodes[k]; j++) {\n\t\t\t\t\tHT[std_table[pos_in_table]] = [];\n\t\t\t\t\tHT[std_table[pos_in_table]][0] = codevalue;\n\t\t\t\t\tHT[std_table[pos_in_table]][1] = k;\n\t\t\t\t\tpos_in_table++;\n\t\t\t\t\tcodevalue++;\n\t\t\t\t}\n\t\t\t\tcodevalue*=2;\n\t\t\t}\n\t\t\treturn HT;\n\t\t}\n\t\t\n\t\tfunction initHuffmanTbl()\n\t\t{\n\t\t\tYDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);\n\t\t\tUVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);\n\t\t\tYAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);\n\t\t\tUVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);\n\t\t}\n\t\n\t\tfunction initCategoryNumber()\n\t\t{\n\t\t\tvar nrlower = 1;\n\t\t\tvar nrupper = 2;\n\t\t\tfor (var cat = 1; cat <= 15; cat++) {\n\t\t\t\t//Positive numbers\n\t\t\t\tfor (var nr = nrlower; nr<nrupper; nr++) {\n\t\t\t\t\tcategory[32767+nr] = cat;\n\t\t\t\t\tbitcode[32767+nr] = [];\n\t\t\t\t\tbitcode[32767+nr][1] = cat;\n\t\t\t\t\tbitcode[32767+nr][0] = nr;\n\t\t\t\t}\n\t\t\t\t//Negative numbers\n\t\t\t\tfor (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {\n\t\t\t\t\tcategory[32767+nrneg] = cat;\n\t\t\t\t\tbitcode[32767+nrneg] = [];\n\t\t\t\t\tbitcode[32767+nrneg][1] = cat;\n\t\t\t\t\tbitcode[32767+nrneg][0] = nrupper-1+nrneg;\n\t\t\t\t}\n\t\t\t\tnrlower <<= 1;\n\t\t\t\tnrupper <<= 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction initRGBYUVTable() {\n\t\t\tfor(var i = 0; i < 256;i++) {\n\t\t\t\tRGB_YUV_TABLE[i]      \t\t=  19595 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+ 256)>>0] \t=  38470 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+ 512)>>0] \t=   7471 * i + 0x8000;\n\t\t\t\tRGB_YUV_TABLE[(i+ 768)>>0] \t= -11059 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+1024)>>0] \t= -21709 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+1280)>>0] \t=  32768 * i + 0x807FFF;\n\t\t\t\tRGB_YUV_TABLE[(i+1536)>>0] \t= -27439 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+1792)>>0] \t= - 5329 * i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// IO functions\n\t\tfunction writeBits(bs)\n\t\t{\n\t\t\tvar value = bs[0];\n\t\t\tvar posval = bs[1]-1;\n\t\t\twhile ( posval >= 0 ) {\n\t\t\t\tif (value & (1 << posval) ) {\n\t\t\t\t\tbytenew |= (1 << bytepos);\n\t\t\t\t}\n\t\t\t\tposval--;\n\t\t\t\tbytepos--;\n\t\t\t\tif (bytepos < 0) {\n\t\t\t\t\tif (bytenew == 0xFF) {\n\t\t\t\t\t\twriteByte(0xFF);\n\t\t\t\t\t\twriteByte(0);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteByte(bytenew);\n\t\t\t\t\t}\n\t\t\t\t\tbytepos=7;\n\t\t\t\t\tbytenew=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction writeByte(value)\n\t\t{\n\t\t\t//byteout.push(clt[value]); // write char directly instead of converting later\n      byteout.push(value);\n\t\t}\n\t\n\t\tfunction writeWord(value)\n\t\t{\n\t\t\twriteByte((value>>8)&0xFF);\n\t\t\twriteByte((value   )&0xFF);\n\t\t}\n\t\t\n\t\t// DCT & quantization core\n\t\tfunction fDCTQuant(data, fdtbl)\n\t\t{\n\t\t\tvar d0, d1, d2, d3, d4, d5, d6, d7;\n\t\t\t/* Pass 1: process rows. */\n\t\t\tvar dataOff=0;\n\t\t\tvar i;\n\t\t\tconst I8 = 8;\n\t\t\tconst I64 = 64;\n\t\t\tfor (i=0; i<I8; ++i)\n\t\t\t{\n\t\t\t\td0 = data[dataOff];\n\t\t\t\td1 = data[dataOff+1];\n\t\t\t\td2 = data[dataOff+2];\n\t\t\t\td3 = data[dataOff+3];\n\t\t\t\td4 = data[dataOff+4];\n\t\t\t\td5 = data[dataOff+5];\n\t\t\t\td6 = data[dataOff+6];\n\t\t\t\td7 = data[dataOff+7];\n\t\t\t\t\n\t\t\t\tvar tmp0 = d0 + d7;\n\t\t\t\tvar tmp7 = d0 - d7;\n\t\t\t\tvar tmp1 = d1 + d6;\n\t\t\t\tvar tmp6 = d1 - d6;\n\t\t\t\tvar tmp2 = d2 + d5;\n\t\t\t\tvar tmp5 = d2 - d5;\n\t\t\t\tvar tmp3 = d3 + d4;\n\t\t\t\tvar tmp4 = d3 - d4;\n\t\n\t\t\t\t/* Even part */\n\t\t\t\tvar tmp10 = tmp0 + tmp3;\t/* phase 2 */\n\t\t\t\tvar tmp13 = tmp0 - tmp3;\n\t\t\t\tvar tmp11 = tmp1 + tmp2;\n\t\t\t\tvar tmp12 = tmp1 - tmp2;\n\t\n\t\t\t\tdata[dataOff] = tmp10 + tmp11; /* phase 3 */\n\t\t\t\tdata[dataOff+4] = tmp10 - tmp11;\n\t\n\t\t\t\tvar z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */\n\t\t\t\tdata[dataOff+2] = tmp13 + z1; /* phase 5 */\n\t\t\t\tdata[dataOff+6] = tmp13 - z1;\n\t\n\t\t\t\t/* Odd part */\n\t\t\t\ttmp10 = tmp4 + tmp5; /* phase 2 */\n\t\t\t\ttmp11 = tmp5 + tmp6;\n\t\t\t\ttmp12 = tmp6 + tmp7;\n\t\n\t\t\t\t/* The rotator is modified from fig 4-8 to avoid extra negations. */\n\t\t\t\tvar z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */\n\t\t\t\tvar z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */\n\t\t\t\tvar z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */\n\t\t\t\tvar z3 = tmp11 * 0.707106781; /* c4 */\n\t\n\t\t\t\tvar z11 = tmp7 + z3;\t/* phase 5 */\n\t\t\t\tvar z13 = tmp7 - z3;\n\t\n\t\t\t\tdata[dataOff+5] = z13 + z2;\t/* phase 6 */\n\t\t\t\tdata[dataOff+3] = z13 - z2;\n\t\t\t\tdata[dataOff+1] = z11 + z4;\n\t\t\t\tdata[dataOff+7] = z11 - z4;\n\t\n\t\t\t\tdataOff += 8; /* advance pointer to next row */\n\t\t\t}\n\t\n\t\t\t/* Pass 2: process columns. */\n\t\t\tdataOff = 0;\n\t\t\tfor (i=0; i<I8; ++i)\n\t\t\t{\n\t\t\t\td0 = data[dataOff];\n\t\t\t\td1 = data[dataOff + 8];\n\t\t\t\td2 = data[dataOff + 16];\n\t\t\t\td3 = data[dataOff + 24];\n\t\t\t\td4 = data[dataOff + 32];\n\t\t\t\td5 = data[dataOff + 40];\n\t\t\t\td6 = data[dataOff + 48];\n\t\t\t\td7 = data[dataOff + 56];\n\t\t\t\t\n\t\t\t\tvar tmp0p2 = d0 + d7;\n\t\t\t\tvar tmp7p2 = d0 - d7;\n\t\t\t\tvar tmp1p2 = d1 + d6;\n\t\t\t\tvar tmp6p2 = d1 - d6;\n\t\t\t\tvar tmp2p2 = d2 + d5;\n\t\t\t\tvar tmp5p2 = d2 - d5;\n\t\t\t\tvar tmp3p2 = d3 + d4;\n\t\t\t\tvar tmp4p2 = d3 - d4;\n\t\n\t\t\t\t/* Even part */\n\t\t\t\tvar tmp10p2 = tmp0p2 + tmp3p2;\t/* phase 2 */\n\t\t\t\tvar tmp13p2 = tmp0p2 - tmp3p2;\n\t\t\t\tvar tmp11p2 = tmp1p2 + tmp2p2;\n\t\t\t\tvar tmp12p2 = tmp1p2 - tmp2p2;\n\t\n\t\t\t\tdata[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */\n\t\t\t\tdata[dataOff+32] = tmp10p2 - tmp11p2;\n\t\n\t\t\t\tvar z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */\n\t\t\t\tdata[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */\n\t\t\t\tdata[dataOff+48] = tmp13p2 - z1p2;\n\t\n\t\t\t\t/* Odd part */\n\t\t\t\ttmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */\n\t\t\t\ttmp11p2 = tmp5p2 + tmp6p2;\n\t\t\t\ttmp12p2 = tmp6p2 + tmp7p2;\n\t\n\t\t\t\t/* The rotator is modified from fig 4-8 to avoid extra negations. */\n\t\t\t\tvar z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */\n\t\t\t\tvar z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */\n\t\t\t\tvar z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */\n\t\t\t\tvar z3p2 = tmp11p2 * 0.707106781; /* c4 */\n\t\n\t\t\t\tvar z11p2 = tmp7p2 + z3p2;\t/* phase 5 */\n\t\t\t\tvar z13p2 = tmp7p2 - z3p2;\n\t\n\t\t\t\tdata[dataOff+40] = z13p2 + z2p2; /* phase 6 */\n\t\t\t\tdata[dataOff+24] = z13p2 - z2p2;\n\t\t\t\tdata[dataOff+ 8] = z11p2 + z4p2;\n\t\t\t\tdata[dataOff+56] = z11p2 - z4p2;\n\t\n\t\t\t\tdataOff++; /* advance pointer to next column */\n\t\t\t}\n\t\n\t\t\t// Quantize/descale the coefficients\n\t\t\tvar fDCTQuant;\n\t\t\tfor (i=0; i<I64; ++i)\n\t\t\t{\n\t\t\t\t// Apply the quantization and scaling factor & Round to nearest integer\n\t\t\t\tfDCTQuant = data[i]*fdtbl[i];\n\t\t\t\toutputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);\n\t\t\t\t//outputfDCTQuant[i] = fround(fDCTQuant);\n\n\t\t\t}\n\t\t\treturn outputfDCTQuant;\n\t\t}\n\t\t\n\t\tfunction writeAPP0()\n\t\t{\n\t\t\twriteWord(0xFFE0); // marker\n\t\t\twriteWord(16); // length\n\t\t\twriteByte(0x4A); // J\n\t\t\twriteByte(0x46); // F\n\t\t\twriteByte(0x49); // I\n\t\t\twriteByte(0x46); // F\n\t\t\twriteByte(0); // = \"JFIF\",'\\0'\n\t\t\twriteByte(1); // versionhi\n\t\t\twriteByte(1); // versionlo\n\t\t\twriteByte(0); // xyunits\n\t\t\twriteWord(1); // xdensity\n\t\t\twriteWord(1); // ydensity\n\t\t\twriteByte(0); // thumbnwidth\n\t\t\twriteByte(0); // thumbnheight\n\t\t}\n\t\n\t\tfunction writeSOF0(width, height)\n\t\t{\n\t\t\twriteWord(0xFFC0); // marker\n\t\t\twriteWord(17);   // length, truecolor YUV JPG\n\t\t\twriteByte(8);    // precision\n\t\t\twriteWord(height);\n\t\t\twriteWord(width);\n\t\t\twriteByte(3);    // nrofcomponents\n\t\t\twriteByte(1);    // IdY\n\t\t\twriteByte(0x11); // HVY\n\t\t\twriteByte(0);    // QTY\n\t\t\twriteByte(2);    // IdU\n\t\t\twriteByte(0x11); // HVU\n\t\t\twriteByte(1);    // QTU\n\t\t\twriteByte(3);    // IdV\n\t\t\twriteByte(0x11); // HVV\n\t\t\twriteByte(1);    // QTV\n\t\t}\n\t\n\t\tfunction writeDQT()\n\t\t{\n\t\t\twriteWord(0xFFDB); // marker\n\t\t\twriteWord(132);\t   // length\n\t\t\twriteByte(0);\n\t\t\tfor (var i=0; i<64; i++) {\n\t\t\t\twriteByte(YTable[i]);\n\t\t\t}\n\t\t\twriteByte(1);\n\t\t\tfor (var j=0; j<64; j++) {\n\t\t\t\twriteByte(UVTable[j]);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction writeDHT()\n\t\t{\n\t\t\twriteWord(0xFFC4); // marker\n\t\t\twriteWord(0x01A2); // length\n\t\n\t\t\twriteByte(0); // HTYDCinfo\n\t\t\tfor (var i=0; i<16; i++) {\n\t\t\t\twriteByte(std_dc_luminance_nrcodes[i+1]);\n\t\t\t}\n\t\t\tfor (var j=0; j<=11; j++) {\n\t\t\t\twriteByte(std_dc_luminance_values[j]);\n\t\t\t}\n\t\n\t\t\twriteByte(0x10); // HTYACinfo\n\t\t\tfor (var k=0; k<16; k++) {\n\t\t\t\twriteByte(std_ac_luminance_nrcodes[k+1]);\n\t\t\t}\n\t\t\tfor (var l=0; l<=161; l++) {\n\t\t\t\twriteByte(std_ac_luminance_values[l]);\n\t\t\t}\n\t\n\t\t\twriteByte(1); // HTUDCinfo\n\t\t\tfor (var m=0; m<16; m++) {\n\t\t\t\twriteByte(std_dc_chrominance_nrcodes[m+1]);\n\t\t\t}\n\t\t\tfor (var n=0; n<=11; n++) {\n\t\t\t\twriteByte(std_dc_chrominance_values[n]);\n\t\t\t}\n\t\n\t\t\twriteByte(0x11); // HTUACinfo\n\t\t\tfor (var o=0; o<16; o++) {\n\t\t\t\twriteByte(std_ac_chrominance_nrcodes[o+1]);\n\t\t\t}\n\t\t\tfor (var p=0; p<=161; p++) {\n\t\t\t\twriteByte(std_ac_chrominance_values[p]);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction writeSOS()\n\t\t{\n\t\t\twriteWord(0xFFDA); // marker\n\t\t\twriteWord(12); // length\n\t\t\twriteByte(3); // nrofcomponents\n\t\t\twriteByte(1); // IdY\n\t\t\twriteByte(0); // HTY\n\t\t\twriteByte(2); // IdU\n\t\t\twriteByte(0x11); // HTU\n\t\t\twriteByte(3); // IdV\n\t\t\twriteByte(0x11); // HTV\n\t\t\twriteByte(0); // Ss\n\t\t\twriteByte(0x3f); // Se\n\t\t\twriteByte(0); // Bf\n\t\t}\n\t\t\n\t\tfunction processDU(CDU, fdtbl, DC, HTDC, HTAC){\n\t\t\tvar EOB = HTAC[0x00];\n\t\t\tvar M16zeroes = HTAC[0xF0];\n\t\t\tvar pos;\n\t\t\tconst I16 = 16;\n\t\t\tconst I63 = 63;\n\t\t\tconst I64 = 64;\n\t\t\tvar DU_DCT = fDCTQuant(CDU, fdtbl);\n\t\t\t//ZigZag reorder\n\t\t\tfor (var j=0;j<I64;++j) {\n\t\t\t\tDU[ZigZag[j]]=DU_DCT[j];\n\t\t\t}\n\t\t\tvar Diff = DU[0] - DC; DC = DU[0];\n\t\t\t//Encode DC\n\t\t\tif (Diff==0) {\n\t\t\t\twriteBits(HTDC[0]); // Diff might be 0\n\t\t\t} else {\n\t\t\t\tpos = 32767+Diff;\n\t\t\t\twriteBits(HTDC[category[pos]]);\n\t\t\t\twriteBits(bitcode[pos]);\n\t\t\t}\n\t\t\t//Encode ACs\n\t\t\tvar end0pos = 63; // was const... which is crazy\n\t\t\tfor (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {};\n\t\t\t//end0pos = first element in reverse order !=0\n\t\t\tif ( end0pos == 0) {\n\t\t\t\twriteBits(EOB);\n\t\t\t\treturn DC;\n\t\t\t}\n\t\t\tvar i = 1;\n\t\t\tvar lng;\n\t\t\twhile ( i <= end0pos ) {\n\t\t\t\tvar startpos = i;\n\t\t\t\tfor (; (DU[i]==0) && (i<=end0pos); ++i) {}\n\t\t\t\tvar nrzeroes = i-startpos;\n\t\t\t\tif ( nrzeroes >= I16 ) {\n\t\t\t\t\tlng = nrzeroes>>4;\n\t\t\t\t\tfor (var nrmarker=1; nrmarker <= lng; ++nrmarker)\n\t\t\t\t\t\twriteBits(M16zeroes);\n\t\t\t\t\tnrzeroes = nrzeroes&0xF;\n\t\t\t\t}\n\t\t\t\tpos = 32767+DU[i];\n\t\t\t\twriteBits(HTAC[(nrzeroes<<4)+category[pos]]);\n\t\t\t\twriteBits(bitcode[pos]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif ( end0pos != I63 ) {\n\t\t\t\twriteBits(EOB);\n\t\t\t}\n\t\t\treturn DC;\n\t\t}\n\n\t\tfunction initCharLookupTable(){\n\t\t\tvar sfcc = String.fromCharCode;\n\t\t\tfor(var i=0; i < 256; i++){ ///// ACHTUNG // 255\n\t\t\t\tclt[i] = sfcc(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.encode = function(image,quality) // image data object\n\t\t{\n\t\t\tvar time_start = new Date().getTime();\n\t\t\t\n\t\t\tif(quality) setQuality(quality);\n\t\t\t\n\t\t\t// Initialize bit writer\n\t\t\tbyteout = new Array();\n\t\t\tbytenew=0;\n\t\t\tbytepos=7;\n\t\n\t\t\t// Add JPEG headers\n\t\t\twriteWord(0xFFD8); // SOI\n\t\t\twriteAPP0();\n\t\t\twriteDQT();\n\t\t\twriteSOF0(image.width,image.height);\n\t\t\twriteDHT();\n\t\t\twriteSOS();\n\n\t\n\t\t\t// Encode 8x8 macroblocks\n\t\t\tvar DCY=0;\n\t\t\tvar DCU=0;\n\t\t\tvar DCV=0;\n\t\t\t\n\t\t\tbytenew=0;\n\t\t\tbytepos=7;\n\t\t\t\n\t\t\t\n\t\t\tthis.encode.displayName = \"_encode_\";\n\n\t\t\tvar imageData = image.data;\n\t\t\tvar width = image.width;\n\t\t\tvar height = image.height;\n\n\t\t\tvar quadWidth = width*4;\n\t\t\tvar tripleWidth = width*3;\n\t\t\t\n\t\t\tvar x, y = 0;\n\t\t\tvar r, g, b;\n\t\t\tvar start,p, col,row,pos;\n\t\t\twhile(y < height){\n\t\t\t\tx = 0;\n\t\t\t\twhile(x < quadWidth){\n\t\t\t\tstart = quadWidth * y + x;\n\t\t\t\tp = start;\n\t\t\t\tcol = -1;\n\t\t\t\trow = 0;\n\t\t\t\t\n\t\t\t\tfor(pos=0; pos < 64; pos++){\n\t\t\t\t\trow = pos >> 3;// /8\n\t\t\t\t\tcol = ( pos & 7 ) * 4; // %8\n\t\t\t\t\tp = start + ( row * quadWidth ) + col;\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(y+row >= height){ // padding bottom\n\t\t\t\t\t\tp-= (quadWidth*(y+1+row-height));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(x+col >= quadWidth){ // padding right\t\n\t\t\t\t\t\tp-= ((x+col) - quadWidth +4)\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tr = imageData[ p++ ];\n\t\t\t\t\tg = imageData[ p++ ];\n\t\t\t\t\tb = imageData[ p++ ];\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t/* // calculate YUV values dynamically\n\t\t\t\t\tYDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80\n\t\t\t\t\tUDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));\n\t\t\t\t\tVDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));\n\t\t\t\t\t*/\n\t\t\t\t\t\n\t\t\t\t\t// use lookup table (slightly faster)\n\t\t\t\t\tYDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;\n\t\t\t\t\tUDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;\n\t\t\t\t\tVDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tDCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n\t\t\t\tDCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\n\t\t\t\tDCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\n\t\t\t\tx+=32;\n\t\t\t\t}\n\t\t\t\ty+=8;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t////////////////////////////////////////////////////////////////\n\t\n\t\t\t// Do the bit alignment of the EOI marker\n\t\t\tif ( bytepos >= 0 ) {\n\t\t\t\tvar fillbits = [];\n\t\t\t\tfillbits[1] = bytepos+1;\n\t\t\t\tfillbits[0] = (1<<(bytepos+1))-1;\n\t\t\t\twriteBits(fillbits);\n\t\t\t}\n\t\n\t\t\twriteWord(0xFFD9); //EOI\n\n      //return new Uint8Array(byteout);\n      return new Buffer(byteout);\n\n\t\t\tvar jpegDataUri = 'data:image/jpeg;base64,' + btoa(byteout.join(''));\n\t\t\t\n\t\t\tbyteout = [];\n\t\t\t\n\t\t\t// benchmarking\n\t\t\tvar duration = new Date().getTime() - time_start;\n    \t\t//console.log('Encoding time: '+ duration + 'ms');\n    \t\t//\n\t\t\t\n\t\t\treturn jpegDataUri\t\t\t\n\t}\n\t\n\tfunction setQuality(quality){\n\t\tif (quality <= 0) {\n\t\t\tquality = 1;\n\t\t}\n\t\tif (quality > 100) {\n\t\t\tquality = 100;\n\t\t}\n\t\t\n\t\tif(currentQuality == quality) return // don't recalc if unchanged\n\t\t\n\t\tvar sf = 0;\n\t\tif (quality < 50) {\n\t\t\tsf = Math.floor(5000 / quality);\n\t\t} else {\n\t\t\tsf = Math.floor(200 - quality*2);\n\t\t}\n\t\t\n\t\tinitQuantTables(sf);\n\t\tcurrentQuality = quality;\n\t\t//console.log('Quality set to: '+quality +'%');\n\t}\n\t\n\tfunction init(){\n\t\tvar time_start = new Date().getTime();\n\t\tif(!quality) quality = 50;\n\t\t// Create tables\n\t\tinitCharLookupTable()\n\t\tinitHuffmanTbl();\n\t\tinitCategoryNumber();\n\t\tinitRGBYUVTable();\n\t\t\n\t\tsetQuality(quality);\n\t\tvar duration = new Date().getTime() - time_start;\n    \t//console.log('Initialization '+ duration + 'ms');\n\t}\n\t\n\tinit();\n\t\n};\nmodule.exports = encode;\n\nfunction encode(imgData, qu) {\n  if (typeof qu === 'undefined') qu = 50;\n  var encoder = new JPEGEncoder(qu);\n\tvar data = encoder.encode(imgData, qu);\n  return {\n    data: data,\n    width: imgData.width,\n    height: imgData.height\n  };\n}\n\n// helper function to get the imageData of an existing image on the current page.\nfunction getImageDataFromImage(idOrElement){\n\tvar theImg = (typeof(idOrElement)=='string')? document.getElementById(idOrElement):idOrElement;\n\tvar cvs = document.createElement('canvas');\n\tcvs.width = theImg.width;\n\tcvs.height = theImg.height;\n\tvar ctx = cvs.getContext(\"2d\");\n\tctx.drawImage(theImg,0,0);\n\t\n\treturn (ctx.getImageData(0, 0, cvs.width, cvs.height));\n}\n\n\n//# sourceURL=webpack:///../node_modules/jpeg-js/lib/encoder.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/base64.js":
/*!*******************************************!*\
  !*** ../node_modules/jszip/lib/base64.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\n// private property\nvar _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n\n// public method for encoding\nexports.encode = function(input) {\n    var output = [];\n    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    var i = 0, len = input.length, remainingBytes = len;\n\n    var isArray = utils.getTypeOf(input) !== \"string\";\n    while (i < input.length) {\n        remainingBytes = len - i;\n\n        if (!isArray) {\n            chr1 = input.charCodeAt(i++);\n            chr2 = i < len ? input.charCodeAt(i++) : 0;\n            chr3 = i < len ? input.charCodeAt(i++) : 0;\n        } else {\n            chr1 = input[i++];\n            chr2 = i < len ? input[i++] : 0;\n            chr3 = i < len ? input[i++] : 0;\n        }\n\n        enc1 = chr1 >> 2;\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;\n        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;\n\n        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));\n\n    }\n\n    return output.join(\"\");\n};\n\n// public method for decoding\nexports.decode = function(input) {\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0, resultIndex = 0;\n\n    var dataUrlPrefix = \"data:\";\n\n    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {\n        // This is a common error: people give a data url\n        // (data:image/png;base64,iVBOR...) with a {base64: true} and\n        // wonders why things don't work.\n        // We can detect that the string input looks like a data url but we\n        // *can't* be sure it is one: removing everything up to the comma would\n        // be too dangerous.\n        throw new Error(\"Invalid base64 input, it looks like a data url.\");\n    }\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n    var totalLength = input.length * 3 / 4;\n    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if (totalLength % 1 !== 0) {\n        // totalLength is not an integer, the length does not match a valid\n        // base64 content. That can happen if:\n        // - the input is not a base64 content\n        // - the input is *almost* a base64 content, with a extra chars at the\n        //   beginning or at the end\n        // - the input uses a base64 variant (base64url for example)\n        throw new Error(\"Invalid base64 input, bad content length.\");\n    }\n    var output;\n    if (support.uint8array) {\n        output = new Uint8Array(totalLength|0);\n    } else {\n        output = new Array(totalLength|0);\n    }\n\n    while (i < input.length) {\n\n        enc1 = _keyStr.indexOf(input.charAt(i++));\n        enc2 = _keyStr.indexOf(input.charAt(i++));\n        enc3 = _keyStr.indexOf(input.charAt(i++));\n        enc4 = _keyStr.indexOf(input.charAt(i++));\n\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n\n        output[resultIndex++] = chr1;\n\n        if (enc3 !== 64) {\n            output[resultIndex++] = chr2;\n        }\n        if (enc4 !== 64) {\n            output[resultIndex++] = chr3;\n        }\n\n    }\n\n    return output;\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/base64.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/compressedObject.js":
/*!*****************************************************!*\
  !*** ../node_modules/jszip/lib/compressedObject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar external = __webpack_require__(/*! ./external */ \"../node_modules/jszip/lib/external.js\");\nvar DataWorker = __webpack_require__(/*! ./stream/DataWorker */ \"../node_modules/jszip/lib/stream/DataWorker.js\");\nvar DataLengthProbe = __webpack_require__(/*! ./stream/DataLengthProbe */ \"../node_modules/jszip/lib/stream/DataLengthProbe.js\");\nvar Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ \"../node_modules/jszip/lib/stream/Crc32Probe.js\");\nvar DataLengthProbe = __webpack_require__(/*! ./stream/DataLengthProbe */ \"../node_modules/jszip/lib/stream/DataLengthProbe.js\");\n\n/**\n * Represent a compressed object, with everything needed to decompress it.\n * @constructor\n * @param {number} compressedSize the size of the data compressed.\n * @param {number} uncompressedSize the size of the data after decompression.\n * @param {number} crc32 the crc32 of the decompressed file.\n * @param {object} compression the type of compression, see lib/compressions.js.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.\n */\nfunction CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {\n    this.compressedSize = compressedSize;\n    this.uncompressedSize = uncompressedSize;\n    this.crc32 = crc32;\n    this.compression = compression;\n    this.compressedContent = data;\n}\n\nCompressedObject.prototype = {\n    /**\n     * Create a worker to get the uncompressed content.\n     * @return {GenericWorker} the worker.\n     */\n    getContentWorker : function () {\n        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))\n        .pipe(this.compression.uncompressWorker())\n        .pipe(new DataLengthProbe(\"data_length\"));\n\n        var that = this;\n        worker.on(\"end\", function () {\n            if(this.streamInfo['data_length'] !== that.uncompressedSize) {\n                throw new Error(\"Bug : uncompressed data size mismatch\");\n            }\n        });\n        return worker;\n    },\n    /**\n     * Create a worker to get the compressed content.\n     * @return {GenericWorker} the worker.\n     */\n    getCompressedWorker : function () {\n        return new DataWorker(external.Promise.resolve(this.compressedContent))\n        .withStreamInfo(\"compressedSize\", this.compressedSize)\n        .withStreamInfo(\"uncompressedSize\", this.uncompressedSize)\n        .withStreamInfo(\"crc32\", this.crc32)\n        .withStreamInfo(\"compression\", this.compression)\n        ;\n    }\n};\n\n/**\n * Chain the given worker with other workers to compress the content with the\n * given compresion.\n * @param {GenericWorker} uncompressedWorker the worker to pipe.\n * @param {Object} compression the compression object.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {GenericWorker} the new worker compressing the content.\n */\nCompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {\n    return uncompressedWorker\n    .pipe(new Crc32Probe())\n    .pipe(new DataLengthProbe(\"uncompressedSize\"))\n    .pipe(compression.compressWorker(compressionOptions))\n    .pipe(new DataLengthProbe(\"compressedSize\"))\n    .withStreamInfo(\"compression\", compression);\n};\n\nmodule.exports = CompressedObject;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/compressedObject.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/compressions.js":
/*!*************************************************!*\
  !*** ../node_modules/jszip/lib/compressions.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\n\nexports.STORE = {\n    magic: \"\\x00\\x00\",\n    compressWorker : function (compressionOptions) {\n        return new GenericWorker(\"STORE compression\");\n    },\n    uncompressWorker : function () {\n        return new GenericWorker(\"STORE decompression\");\n    }\n};\nexports.DEFLATE = __webpack_require__(/*! ./flate */ \"../node_modules/jszip/lib/flate.js\");\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/compressions.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/crc32.js":
/*!******************************************!*\
  !*** ../node_modules/jszip/lib/crc32.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\n\n/**\n * The following functions come from pako, from pako/lib/zlib/crc32.js\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n    var c, table = [];\n\n    for(var n =0; n < 256; n++){\n        c = n;\n        for(var k =0; k < 8; k++){\n            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n        }\n        table[n] = c;\n    }\n\n    return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n    var t = crcTable, end = pos + len;\n\n    crc = crc ^ (-1);\n\n    for (var i = pos; i < end; i++ ) {\n        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n\n    return (crc ^ (-1)); // >>> 0;\n}\n\n// That's all for the pako functions.\n\n/**\n * Compute the crc32 of a string.\n * This is almost the same as the function crc32, but for strings. Using the\n * same function for the two use cases leads to horrible performances.\n * @param {Number} crc the starting value of the crc.\n * @param {String} str the string to use.\n * @param {Number} len the length of the string.\n * @param {Number} pos the starting position for the crc32 computation.\n * @return {Number} the computed crc32.\n */\nfunction crc32str(crc, str, len, pos) {\n    var t = crcTable, end = pos + len;\n\n    crc = crc ^ (-1);\n\n    for (var i = pos; i < end; i++ ) {\n        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];\n    }\n\n    return (crc ^ (-1)); // >>> 0;\n}\n\nmodule.exports = function crc32wrapper(input, crc) {\n    if (typeof input === \"undefined\" || !input.length) {\n        return 0;\n    }\n\n    var isArray = utils.getTypeOf(input) !== \"string\";\n\n    if(isArray) {\n        return crc32(crc|0, input, input.length, 0);\n    } else {\n        return crc32str(crc|0, input, input.length, 0);\n    }\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/crc32.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/defaults.js":
/*!*********************************************!*\
  !*** ../node_modules/jszip/lib/defaults.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.base64 = false;\nexports.binary = false;\nexports.dir = false;\nexports.createFolders = true;\nexports.date = null;\nexports.compression = null;\nexports.compressionOptions = null;\nexports.comment = null;\nexports.unixPermissions = null;\nexports.dosPermissions = null;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/defaults.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/external.js":
/*!*********************************************!*\
  !*** ../node_modules/jszip/lib/external.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global Promise */\n\n\n// load the global object first:\n// - it should be better integrated in the system (unhandledRejection in node)\n// - the environment may have a custom Promise implementation (see zone.js)\nvar ES6Promise = null;\nif (typeof Promise !== \"undefined\") {\n    ES6Promise = Promise;\n} else {\n    ES6Promise = __webpack_require__(/*! lie */ \"../node_modules/lie/lib/index.js\");\n}\n\n/**\n * Let the user use/change some implementations.\n */\nmodule.exports = {\n    Promise: ES6Promise\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/external.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/flate.js":
/*!******************************************!*\
  !*** ../node_modules/jszip/lib/flate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');\n\nvar pako = __webpack_require__(/*! pako */ \"../node_modules/jszip/node_modules/pako/index.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\n\nvar ARRAY_TYPE = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\n\nexports.magic = \"\\x08\\x00\";\n\n/**\n * Create a worker that uses pako to inflate/deflate.\n * @constructor\n * @param {String} action the name of the pako function to call : either \"Deflate\" or \"Inflate\".\n * @param {Object} options the options to use when (de)compressing.\n */\nfunction FlateWorker(action, options) {\n    GenericWorker.call(this, \"FlateWorker/\" + action);\n\n    this._pako = null;\n    this._pakoAction = action;\n    this._pakoOptions = options;\n    // the `meta` object from the last chunk received\n    // this allow this worker to pass around metadata\n    this.meta = {};\n}\n\nutils.inherits(FlateWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nFlateWorker.prototype.processChunk = function (chunk) {\n    this.meta = chunk.meta;\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);\n};\n\n/**\n * @see GenericWorker.flush\n */\nFlateWorker.prototype.flush = function () {\n    GenericWorker.prototype.flush.call(this);\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push([], true);\n};\n/**\n * @see GenericWorker.cleanUp\n */\nFlateWorker.prototype.cleanUp = function () {\n    GenericWorker.prototype.cleanUp.call(this);\n    this._pako = null;\n};\n\n/**\n * Create the _pako object.\n * TODO: lazy-loading this object isn't the best solution but it's the\n * quickest. The best solution is to lazy-load the worker list. See also the\n * issue #446.\n */\nFlateWorker.prototype._createPako = function () {\n    this._pako = new pako[this._pakoAction]({\n        raw: true,\n        level: this._pakoOptions.level || -1 // default compression\n    });\n    var self = this;\n    this._pako.onData = function(data) {\n        self.push({\n            data : data,\n            meta : self.meta\n        });\n    };\n};\n\nexports.compressWorker = function (compressionOptions) {\n    return new FlateWorker(\"Deflate\", compressionOptions);\n};\nexports.uncompressWorker = function () {\n    return new FlateWorker(\"Inflate\", {});\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/flate.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/generate/ZipFileWorker.js":
/*!***********************************************************!*\
  !*** ../node_modules/jszip/lib/generate/ZipFileWorker.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\nvar utf8 = __webpack_require__(/*! ../utf8 */ \"../node_modules/jszip/lib/utf8.js\");\nvar crc32 = __webpack_require__(/*! ../crc32 */ \"../node_modules/jszip/lib/crc32.js\");\nvar signature = __webpack_require__(/*! ../signature */ \"../node_modules/jszip/lib/signature.js\");\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function(dec, bytes) {\n    var hex = \"\", i;\n    for (i = 0; i < bytes; i++) {\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n    return (result & 0xFFFF) << 16;\n};\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n\n    // the dir flag is already set for compatibility\n    return (dosPermissions || 0)  & 0x3F;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {Object} streamInfo the hash with informations about the compressed file.\n * @param {Boolean} streamedContent is the content streamed ?\n * @param {Boolean} streamingEnded is the stream finished ?\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {Object} the zip parts.\n */\nvar generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n    var file = streamInfo['file'],\n    compression = streamInfo['compression'],\n    useCustomEncoding = encodeFileName !== utf8.utf8encode,\n    encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n    utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n    comment = file.comment,\n    encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n    utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n    useUTF8ForComment = utfEncodedComment.length !== comment.length,\n    dosTime,\n    dosDate,\n    extraFields = \"\",\n    unicodePathExtraField = \"\",\n    unicodeCommentExtraField = \"\",\n    dir = file.dir,\n    date = file.date;\n\n\n    var dataInfo = {\n        crc32 : 0,\n        compressedSize : 0,\n        uncompressedSize : 0\n    };\n\n    // if the content is streamed, the sizes/crc32 are only available AFTER\n    // the end of the stream.\n    if (!streamedContent || streamingEnded) {\n        dataInfo.crc32 = streamInfo['crc32'];\n        dataInfo.compressedSize = streamInfo['compressedSize'];\n        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];\n    }\n\n    var bitflag = 0;\n    if (streamedContent) {\n        // Bit 3: the sizes/crc32 are set to zero in the local header.\n        // The correct values are put in the data descriptor immediately\n        // following the compressed data.\n        bitflag |= 0x0008;\n    }\n    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n        // Bit 11: Language encoding flag (EFS).\n        bitflag |= 0x0800;\n    }\n\n\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if(platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else { // DOS or other, fallback to DOS\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n    dosTime = date.getUTCHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getUTCMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getUTCSeconds() / 2;\n\n    dosDate = date.getUTCFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | (date.getUTCMonth() + 1);\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getUTCDate();\n\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField =\n            // Version\n            decToHex(1, 1) +\n            // NameCRC32\n            decToHex(crc32(encodedFileName), 4) +\n            // UnicodeName\n            utfEncodedFileName;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x70\" +\n            // size\n            decToHex(unicodePathExtraField.length, 2) +\n            // content\n            unicodePathExtraField;\n    }\n\n    if(useUTF8ForComment) {\n\n        unicodeCommentExtraField =\n            // Version\n            decToHex(1, 1) +\n            // CommentCRC32\n            decToHex(crc32(encodedComment), 4) +\n            // UnicodeName\n            utfEncodedComment;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x63\" +\n            // size\n            decToHex(unicodeCommentExtraField.length, 2) +\n            // content\n            unicodeCommentExtraField;\n    }\n\n    var header = \"\";\n\n    // version needed to extract\n    header += \"\\x0A\\x00\";\n    // general purpose bit flag\n    header += decToHex(bitflag, 2);\n    // compression method\n    header += compression.magic;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(dataInfo.crc32, 4);\n    // compressed size\n    header += decToHex(dataInfo.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(dataInfo.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n\n\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n\n    var dirRecord = signature.CENTRAL_FILE_HEADER +\n        // version made by (00: DOS)\n        decToHex(versionMadeBy, 2) +\n        // file header (common to file and central directory)\n        header +\n        // file comment length\n        decToHex(encodedComment.length, 2) +\n        // disk number start\n        \"\\x00\\x00\" +\n        // internal file attributes TODO\n        \"\\x00\\x00\" +\n        // external file attributes\n        decToHex(extFileAttr, 4) +\n        // relative offset of local header\n        decToHex(offset, 4) +\n        // file name\n        encodedFileName +\n        // extra field\n        extraFields +\n        // file comment\n        encodedComment;\n\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord\n    };\n};\n\n/**\n * Generate the EOCD record.\n * @param {Number} entriesCount the number of entries in the zip file.\n * @param {Number} centralDirLength the length (in bytes) of the central dir.\n * @param {Number} localDirLength the length (in bytes) of the local dir.\n * @param {String} comment the zip file comment as a binary string.\n * @param {Function} encodeFileName the function to encode the comment.\n * @return {String} the EOCD record.\n */\nvar generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n    var dirEnd = \"\";\n    var encodedComment = utils.transformTo(\"string\", encodeFileName(comment));\n\n    // end of central dir signature\n    dirEnd = signature.CENTRAL_DIRECTORY_END +\n        // number of this disk\n        \"\\x00\\x00\" +\n        // number of the disk with the start of the central directory\n        \"\\x00\\x00\" +\n        // total number of entries in the central directory on this disk\n        decToHex(entriesCount, 2) +\n        // total number of entries in the central directory\n        decToHex(entriesCount, 2) +\n        // size of the central directory   4 bytes\n        decToHex(centralDirLength, 4) +\n        // offset of start of central directory with respect to the starting disk number\n        decToHex(localDirLength, 4) +\n        // .ZIP file comment length\n        decToHex(encodedComment.length, 2) +\n        // .ZIP file comment\n        encodedComment;\n\n    return dirEnd;\n};\n\n/**\n * Generate data descriptors for a file entry.\n * @param {Object} streamInfo the hash generated by a worker, containing informations\n * on the file entry.\n * @return {String} the data descriptors.\n */\nvar generateDataDescriptors = function (streamInfo) {\n    var descriptor = \"\";\n    descriptor = signature.DATA_DESCRIPTOR +\n        // crc-32                          4 bytes\n        decToHex(streamInfo['crc32'], 4) +\n        // compressed size                 4 bytes\n        decToHex(streamInfo['compressedSize'], 4) +\n        // uncompressed size               4 bytes\n        decToHex(streamInfo['uncompressedSize'], 4);\n\n    return descriptor;\n};\n\n\n/**\n * A worker to concatenate other workers to create a zip file.\n * @param {Boolean} streamFiles `true` to stream the content of the files,\n * `false` to accumulate it.\n * @param {String} comment the comment to use.\n * @param {String} platform the platform to use, \"UNIX\" or \"DOS\".\n * @param {Function} encodeFileName the function to encode file names and comments.\n */\nfunction ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n    GenericWorker.call(this, \"ZipFileWorker\");\n    // The number of bytes written so far. This doesn't count accumulated chunks.\n    this.bytesWritten = 0;\n    // The comment of the zip file\n    this.zipComment = comment;\n    // The platform \"generating\" the zip file.\n    this.zipPlatform = platform;\n    // the function to encode file names and comments.\n    this.encodeFileName = encodeFileName;\n    // Should we stream the content of the files ?\n    this.streamFiles = streamFiles;\n    // If `streamFiles` is false, we will need to accumulate the content of the\n    // files to calculate sizes / crc32 (and write them *before* the content).\n    // This boolean indicates if we are accumulating chunks (it will change a lot\n    // during the lifetime of this worker).\n    this.accumulate = false;\n    // The buffer receiving chunks when accumulating content.\n    this.contentBuffer = [];\n    // The list of generated directory records.\n    this.dirRecords = [];\n    // The offset (in bytes) from the beginning of the zip file for the current source.\n    this.currentSourceOffset = 0;\n    // The total number of entries in this zip file.\n    this.entriesCount = 0;\n    // the name of the file currently being added, null when handling the end of the zip file.\n    // Used for the emited metadata.\n    this.currentFile = null;\n\n\n\n    this._sources = [];\n}\nutils.inherits(ZipFileWorker, GenericWorker);\n\n/**\n * @see GenericWorker.push\n */\nZipFileWorker.prototype.push = function (chunk) {\n\n    var currentFilePercent = chunk.meta.percent || 0;\n    var entriesCount = this.entriesCount;\n    var remainingFiles = this._sources.length;\n\n    if(this.accumulate) {\n        this.contentBuffer.push(chunk);\n    } else {\n        this.bytesWritten += chunk.data.length;\n\n        GenericWorker.prototype.push.call(this, {\n            data : chunk.data,\n            meta : {\n                currentFile : this.currentFile,\n                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n            }\n        });\n    }\n};\n\n/**\n * The worker started a new source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the new source.\n */\nZipFileWorker.prototype.openedSource = function (streamInfo) {\n    this.currentSourceOffset = this.bytesWritten;\n    this.currentFile = streamInfo['file'].name;\n\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n\n    // don't stream folders (because they don't have any content)\n    if(streamedContent) {\n        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n        this.push({\n            data : record.fileRecord,\n            meta : {percent:0}\n        });\n    } else {\n        // we need to wait for the whole file before pushing anything\n        this.accumulate = true;\n    }\n};\n\n/**\n * The worker finished a source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the finished source.\n */\nZipFileWorker.prototype.closedSource = function (streamInfo) {\n    this.accumulate = false;\n    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n\n    this.dirRecords.push(record.dirRecord);\n    if(streamedContent) {\n        // after the streamed file, we put data descriptors\n        this.push({\n            data : generateDataDescriptors(streamInfo),\n            meta : {percent:100}\n        });\n    } else {\n        // the content wasn't streamed, we need to push everything now\n        // first the file record, then the content\n        this.push({\n            data : record.fileRecord,\n            meta : {percent:0}\n        });\n        while(this.contentBuffer.length) {\n            this.push(this.contentBuffer.shift());\n        }\n    }\n    this.currentFile = null;\n};\n\n/**\n * @see GenericWorker.flush\n */\nZipFileWorker.prototype.flush = function () {\n\n    var localDirLength = this.bytesWritten;\n    for(var i = 0; i < this.dirRecords.length; i++) {\n        this.push({\n            data : this.dirRecords[i],\n            meta : {percent:100}\n        });\n    }\n    var centralDirLength = this.bytesWritten - localDirLength;\n\n    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n\n    this.push({\n        data : dirEnd,\n        meta : {percent:100}\n    });\n};\n\n/**\n * Prepare the next source to be read.\n */\nZipFileWorker.prototype.prepareNextSource = function () {\n    this.previous = this._sources.shift();\n    this.openedSource(this.previous.streamInfo);\n    if (this.isPaused) {\n        this.previous.pause();\n    } else {\n        this.previous.resume();\n    }\n};\n\n/**\n * @see GenericWorker.registerPrevious\n */\nZipFileWorker.prototype.registerPrevious = function (previous) {\n    this._sources.push(previous);\n    var self = this;\n\n    previous.on('data', function (chunk) {\n        self.processChunk(chunk);\n    });\n    previous.on('end', function () {\n        self.closedSource(self.previous.streamInfo);\n        if(self._sources.length) {\n            self.prepareNextSource();\n        } else {\n            self.end();\n        }\n    });\n    previous.on('error', function (e) {\n        self.error(e);\n    });\n    return this;\n};\n\n/**\n * @see GenericWorker.resume\n */\nZipFileWorker.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if (!this.previous && this._sources.length) {\n        this.prepareNextSource();\n        return true;\n    }\n    if (!this.previous && !this._sources.length && !this.generatedError) {\n        this.end();\n        return true;\n    }\n};\n\n/**\n * @see GenericWorker.error\n */\nZipFileWorker.prototype.error = function (e) {\n    var sources = this._sources;\n    if(!GenericWorker.prototype.error.call(this, e)) {\n        return false;\n    }\n    for(var i = 0; i < sources.length; i++) {\n        try {\n            sources[i].error(e);\n        } catch(e) {\n            // the `error` exploded, nothing to do\n        }\n    }\n    return true;\n};\n\n/**\n * @see GenericWorker.lock\n */\nZipFileWorker.prototype.lock = function () {\n    GenericWorker.prototype.lock.call(this);\n    var sources = this._sources;\n    for(var i = 0; i < sources.length; i++) {\n        sources[i].lock();\n    }\n};\n\nmodule.exports = ZipFileWorker;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/generate/ZipFileWorker.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/generate/index.js":
/*!***************************************************!*\
  !*** ../node_modules/jszip/lib/generate/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar compressions = __webpack_require__(/*! ../compressions */ \"../node_modules/jszip/lib/compressions.js\");\nvar ZipFileWorker = __webpack_require__(/*! ./ZipFileWorker */ \"../node_modules/jszip/lib/generate/ZipFileWorker.js\");\n\n/**\n * Find the compression to use.\n * @param {String} fileCompression the compression defined at the file level, if any.\n * @param {String} zipCompression the compression defined at the load() level.\n * @return {Object} the compression object to use.\n */\nvar getCompression = function (fileCompression, zipCompression) {\n\n    var compressionName = fileCompression || zipCompression;\n    var compression = compressions[compressionName];\n    if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n    }\n    return compression;\n};\n\n/**\n * Create a worker to generate a zip file.\n * @param {JSZip} zip the JSZip instance at the right root level.\n * @param {Object} options to generate the zip file.\n * @param {String} comment the comment to use.\n */\nexports.generateWorker = function (zip, options, comment) {\n\n    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n    var entriesCount = 0;\n    try {\n\n        zip.forEach(function (relativePath, file) {\n            entriesCount++;\n            var compression = getCompression(file.options.compression, options.compression);\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n            var dir = file.dir, date = file.date;\n\n            file._compressWorker(compression, compressionOptions)\n            .withStreamInfo(\"file\", {\n                name : relativePath,\n                dir : dir,\n                date : date,\n                comment : file.comment || \"\",\n                unixPermissions : file.unixPermissions,\n                dosPermissions : file.dosPermissions\n            })\n            .pipe(zipFileWorker);\n        });\n        zipFileWorker.entriesCount = entriesCount;\n    } catch (e) {\n        zipFileWorker.error(e);\n    }\n\n    return zipFileWorker;\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/generate/index.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/index.js":
/*!******************************************!*\
  !*** ../node_modules/jszip/lib/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Representation a of zip file in js\n * @constructor\n */\nfunction JSZip() {\n    // if this constructor isÂ used withoutÂ `new`, itÂ adds `new` beforeÂ itself:\n    if(!(this instanceof JSZip)) {\n        return new JSZip();\n    }\n\n    if(arguments.length) {\n        throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");\n    }\n\n    // object containing the files :\n    // {\n    //   \"folder/\" : {...},\n    //   \"folder/data.txt\" : {...}\n    // }\n    this.files = {};\n\n    this.comment = null;\n\n    // Where we are in the hierarchy\n    this.root = \"\";\n    this.clone = function() {\n        var newObj = new JSZip();\n        for (var i in this) {\n            if (typeof this[i] !== \"function\") {\n                newObj[i] = this[i];\n            }\n        }\n        return newObj;\n    };\n}\nJSZip.prototype = __webpack_require__(/*! ./object */ \"../node_modules/jszip/lib/object.js\");\nJSZip.prototype.loadAsync = __webpack_require__(/*! ./load */ \"../node_modules/jszip/lib/load.js\");\nJSZip.support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\nJSZip.defaults = __webpack_require__(/*! ./defaults */ \"../node_modules/jszip/lib/defaults.js\");\n\n// TODO find a better way to handle this version,\n// a require('package.json').version doesn't work with webpack, see #327\nJSZip.version = \"3.1.5\";\n\nJSZip.loadAsync = function (content, options) {\n    return new JSZip().loadAsync(content, options);\n};\n\nJSZip.external = __webpack_require__(/*! ./external */ \"../node_modules/jszip/lib/external.js\");\nmodule.exports = JSZip;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/index.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/load.js":
/*!*****************************************!*\
  !*** ../node_modules/jszip/lib/load.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar external = __webpack_require__(/*! ./external */ \"../node_modules/jszip/lib/external.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"../node_modules/jszip/lib/utf8.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar ZipEntries = __webpack_require__(/*! ./zipEntries */ \"../node_modules/jszip/lib/zipEntries.js\");\nvar Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ \"../node_modules/jszip/lib/stream/Crc32Probe.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"../node_modules/jszip/lib/nodejsUtils.js\");\n\n/**\n * Check the CRC32 of an entry.\n * @param {ZipEntry} zipEntry the zip entry to check.\n * @return {Promise} the result.\n */\nfunction checkEntryCRC32(zipEntry) {\n    return new external.Promise(function (resolve, reject) {\n        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n        worker.on(\"error\", function (e) {\n            reject(e);\n        })\n        .on(\"end\", function () {\n            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n                reject(new Error(\"Corrupted zip : CRC32 mismatch\"));\n            } else {\n                resolve();\n            }\n        })\n        .resume();\n    });\n}\n\nmodule.exports = function(data, options) {\n    var zip = this;\n    options = utils.extend(options || {}, {\n        base64: false,\n        checkCRC32: false,\n        optimizedBinaryString: false,\n        createFolders: false,\n        decodeFileName: utf8.utf8decode\n    });\n\n    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        return external.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\"));\n    }\n\n    return utils.prepareContent(\"the loaded zip file\", data, true, options.optimizedBinaryString, options.base64)\n    .then(function(data) {\n        var zipEntries = new ZipEntries(options);\n        zipEntries.load(data);\n        return zipEntries;\n    }).then(function checkCRC32(zipEntries) {\n        var promises = [external.Promise.resolve(zipEntries)];\n        var files = zipEntries.files;\n        if (options.checkCRC32) {\n            for (var i = 0; i < files.length; i++) {\n                promises.push(checkEntryCRC32(files[i]));\n            }\n        }\n        return external.Promise.all(promises);\n    }).then(function addFiles(results) {\n        var zipEntries = results.shift();\n        var files = zipEntries.files;\n        for (var i = 0; i < files.length; i++) {\n            var input = files[i];\n            zip.file(input.fileNameStr, input.decompressed, {\n                binary: true,\n                optimizedBinaryString: true,\n                date: input.date,\n                dir: input.dir,\n                comment : input.fileCommentStr.length ? input.fileCommentStr : null,\n                unixPermissions : input.unixPermissions,\n                dosPermissions : input.dosPermissions,\n                createFolders: options.createFolders\n            });\n        }\n        if (zipEntries.zipComment.length) {\n            zip.comment = zipEntries.zipComment;\n        }\n\n        return zip;\n    });\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/load.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js":
/*!********************************************************************!*\
  !*** ../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\n\n/**\n * A worker that use a nodejs stream as source.\n * @constructor\n * @param {String} filename the name of the file entry for this stream.\n * @param {Readable} stream the nodejs stream.\n */\nfunction NodejsStreamInputAdapter(filename, stream) {\n    GenericWorker.call(this, \"Nodejs stream input adapter for \" + filename);\n    this._upstreamEnded = false;\n    this._bindStream(stream);\n}\n\nutils.inherits(NodejsStreamInputAdapter, GenericWorker);\n\n/**\n * Prepare the stream and bind the callbacks on it.\n * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.\n * @param {Stream} stream the nodejs stream to use.\n */\nNodejsStreamInputAdapter.prototype._bindStream = function (stream) {\n    var self = this;\n    this._stream = stream;\n    stream.pause();\n    stream\n    .on(\"data\", function (chunk) {\n        self.push({\n            data: chunk,\n            meta : {\n                percent : 0\n            }\n        });\n    })\n    .on(\"error\", function (e) {\n        if(self.isPaused) {\n            this.generatedError = e;\n        } else {\n            self.error(e);\n        }\n    })\n    .on(\"end\", function () {\n        if(self.isPaused) {\n            self._upstreamEnded = true;\n        } else {\n            self.end();\n        }\n    });\n};\nNodejsStreamInputAdapter.prototype.pause = function () {\n    if(!GenericWorker.prototype.pause.call(this)) {\n        return false;\n    }\n    this._stream.pause();\n    return true;\n};\nNodejsStreamInputAdapter.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if(this._upstreamEnded) {\n        this.end();\n    } else {\n        this._stream.resume();\n    }\n\n    return true;\n};\n\nmodule.exports = NodejsStreamInputAdapter;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js":
/*!*********************************************************************!*\
  !*** ../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Readable = __webpack_require__(/*! readable-stream */ \"../node_modules/jszip/node_modules/readable-stream/readable.js\").Readable;\n\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\nutils.inherits(NodejsStreamOutputAdapter, Readable);\n\n/**\n* A nodejs stream using a worker as source.\n* @see the SourceWrapper in http://nodejs.org/api/stream.html\n* @constructor\n* @param {StreamHelper} helper the helper wrapping the worker\n* @param {Object} options the nodejs stream options\n* @param {Function} updateCb the update callback.\n*/\nfunction NodejsStreamOutputAdapter(helper, options, updateCb) {\n    Readable.call(this, options);\n    this._helper = helper;\n\n    var self = this;\n    helper.on(\"data\", function (data, meta) {\n        if (!self.push(data)) {\n            self._helper.pause();\n        }\n        if(updateCb) {\n            updateCb(meta);\n        }\n    })\n    .on(\"error\", function(e) {\n        self.emit('error', e);\n    })\n    .on(\"end\", function () {\n        self.push(null);\n    });\n}\n\n\nNodejsStreamOutputAdapter.prototype._read = function() {\n    this._helper.resume();\n};\n\nmodule.exports = NodejsStreamOutputAdapter;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/nodejsUtils.js":
/*!************************************************!*\
  !*** ../node_modules/jszip/lib/nodejsUtils.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n    /**\n     * True if this is running in Nodejs, will be undefined in a browser.\n     * In a browser, browserify won't include this file and the whole module\n     * will be resolved an empty object.\n     */\n    isNode : typeof Buffer !== \"undefined\",\n    /**\n     * Create a new nodejs Buffer from an existing content.\n     * @param {Object} data the data to pass to the constructor.\n     * @param {String} encoding the encoding to use.\n     * @return {Buffer} a new Buffer.\n     */\n    newBufferFrom: function(data, encoding) {\n        // XXX We can't use `Buffer.from` which comes from `Uint8Array.from`\n        // in nodejs v4 (< v.4.5). It's not the expected implementation (and\n        // has a different signature).\n        // see https://github.com/nodejs/node/issues/8053\n        // A condition on nodejs' version won't solve the issue as we don't\n        // control the Buffer polyfills that may or may not be used.\n        return new Buffer(data, encoding);\n    },\n    /**\n     * Create a new nodejs Buffer with the specified size.\n     * @param {Integer} size the size of the buffer.\n     * @return {Buffer} a new Buffer.\n     */\n    allocBuffer: function (size) {\n        if (Buffer.alloc) {\n            return Buffer.alloc(size);\n        } else {\n            return new Buffer(size);\n        }\n    },\n    /**\n     * Find out if an object is a Buffer.\n     * @param {Object} b the object to test.\n     * @return {Boolean} true if the object is a Buffer, false otherwise.\n     */\n    isBuffer : function(b){\n        return Buffer.isBuffer(b);\n    },\n\n    isStream : function (obj) {\n        return obj &&\n            typeof obj.on === \"function\" &&\n            typeof obj.pause === \"function\" &&\n            typeof obj.resume === \"function\";\n    }\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/nodejsUtils.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/object.js":
/*!*******************************************!*\
  !*** ../node_modules/jszip/lib/object.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"../node_modules/jszip/lib/utf8.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\nvar StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ \"../node_modules/jszip/lib/stream/StreamHelper.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"../node_modules/jszip/lib/defaults.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"../node_modules/jszip/lib/compressedObject.js\");\nvar ZipObject = __webpack_require__(/*! ./zipObject */ \"../node_modules/jszip/lib/zipObject.js\");\nvar generate = __webpack_require__(/*! ./generate */ \"../node_modules/jszip/lib/generate/index.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"../node_modules/jszip/lib/nodejsUtils.js\");\nvar NodejsStreamInputAdapter = __webpack_require__(/*! ./nodejs/NodejsStreamInputAdapter */ \"../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js\");\n\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} originalOptions the options of the file\n * @return {Object} the new file.\n */\nvar fileAdd = function(name, data, originalOptions) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data),\n        parent;\n\n\n    /*\n     * Correct options.\n     */\n\n    var o = utils.extend(originalOptions || {}, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) {\n        o.compression = o.compression.toUpperCase();\n    }\n\n    if (typeof o.unixPermissions === \"string\") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {\n        o.dir = true;\n    }\n\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n\n    var isUnicodeString = dataType === \"string\" && o.binary === false && o.base64 === false;\n    if (!originalOptions || typeof originalOptions.binary === \"undefined\") {\n        o.binary = !isUnicodeString;\n    }\n\n\n    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;\n\n    if (isCompressedEmpty || o.dir || !data || data.length === 0) {\n        o.base64 = false;\n        o.binary = true;\n        data = \"\";\n        o.compression = \"STORE\";\n        dataType = \"string\";\n    }\n\n    /*\n     * Convert content to fit.\n     */\n\n    var zipObjectContent = null;\n    if (data instanceof CompressedObject || data instanceof GenericWorker) {\n        zipObjectContent = data;\n    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        zipObjectContent = new NodejsStreamInputAdapter(name, data);\n    } else {\n        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);\n    }\n\n    var object = new ZipObject(name, zipObjectContent, o);\n    this.files[name] = object;\n    /*\n    TODO: we can't throw an exception because we have async promises\n    (we can have a promise of a Date() for example) but returning a\n    promise is useless because file(name, data) returns the JSZip\n    object for chaining. Should we break that to allow the user\n    to catch the error ?\n\n    return external.Promise.resolve(zipObjectContent)\n    .then(function () {\n        return object;\n    });\n    */\n};\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nvar parentFolder = function (path) {\n    if (path.slice(-1) === '/') {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf('/');\n    return (lastSlash > 0) ? path.substring(0, lastSlash) : \"\";\n};\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nvar forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) !== \"/\") {\n        path += \"/\"; // IE doesn't like substr(-1)\n    }\n    return path;\n};\n\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nvar folderAdd = function(name, createFolders) {\n    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;\n\n    name = forceTrailingSlash(name);\n\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nfunction isRegExp(object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n}\n\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * @see loadAsync\n     */\n    load: function() {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n\n\n    /**\n     * Call a callback function for each entry at this folder level.\n     * @param {Function} cb the callback function:\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     */\n    forEach: function(cb) {\n        var filename, relativePath, file;\n        for (filename in this.files) {\n            if (!this.files.hasOwnProperty(filename)) {\n                continue;\n            }\n            file = this.files[filename];\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root\n                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...\n            }\n        }\n    },\n\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */\n    filter: function(search) {\n        var result = [];\n        this.forEach(function (relativePath, entry) {\n            if (search(relativePath, entry)) { // the file matches the function\n                result.push(entry);\n            }\n\n        });\n        return result;\n    },\n\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */\n    file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            }\n            else { // text\n                var obj = this.files[this.root + name];\n                if (obj && !obj.dir) {\n                    return obj;\n                } else {\n                    return null;\n                }\n            }\n        }\n        else { // more than one argument : we have data !\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */\n    folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n\n        if (isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */\n    remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) !== \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for (var i = 0; i < kids.length; i++) {\n                delete this.files[kids[i].name];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Generate the complete zip file\n     * @param {Object} options the options to generate the zip file :\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n     */\n    generate: function(options) {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n\n    /**\n     * Generate the complete zip file as an internal stream.\n     * @param {Object} options the options to generate the zip file :\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {StreamHelper} the streamed zip file.\n     */\n    generateInternalStream: function(options) {\n      var worker, opts = {};\n      try {\n          opts = utils.extend(options || {}, {\n              streamFiles: false,\n              compression: \"STORE\",\n              compressionOptions : null,\n              type: \"\",\n              platform: \"DOS\",\n              comment: null,\n              mimeType: 'application/zip',\n              encodeFileName: utf8.utf8encode\n          });\n\n          opts.type = opts.type.toLowerCase();\n          opts.compression = opts.compression.toUpperCase();\n\n          // \"binarystring\" is prefered but the internals use \"string\".\n          if(opts.type === \"binarystring\") {\n            opts.type = \"string\";\n          }\n\n          if (!opts.type) {\n            throw new Error(\"No output type specified.\");\n          }\n\n          utils.checkSupport(opts.type);\n\n          // accept nodejs `process.platform`\n          if(\n              opts.platform === 'darwin' ||\n              opts.platform === 'freebsd' ||\n              opts.platform === 'linux' ||\n              opts.platform === 'sunos'\n          ) {\n              opts.platform = \"UNIX\";\n          }\n          if (opts.platform === 'win32') {\n              opts.platform = \"DOS\";\n          }\n\n          var comment = opts.comment || this.comment || \"\";\n          worker = generate.generateWorker(this, opts, comment);\n      } catch (e) {\n        worker = new GenericWorker(\"error\");\n        worker.error(e);\n      }\n      return new StreamHelper(worker, opts.type || \"string\", opts.mimeType);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */\n    generateAsync: function(options, onUpdate) {\n        return this.generateInternalStream(options).accumulate(onUpdate);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */\n    generateNodeStream: function(options, onUpdate) {\n        options = options || {};\n        if (!options.type) {\n            options.type = \"nodebuffer\";\n        }\n        return this.generateInternalStream(options).toNodejsStream(onUpdate);\n    }\n};\nmodule.exports = out;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/object.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/reader/ArrayReader.js":
/*!*******************************************************!*\
  !*** ../node_modules/jszip/lib/reader/ArrayReader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar DataReader = __webpack_require__(/*! ./DataReader */ \"../node_modules/jszip/lib/reader/DataReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\n\nfunction ArrayReader(data) {\n    DataReader.call(this, data);\n\tfor(var i = 0; i < this.data.length; i++) {\n\t\tdata[i] = data[i] & 0xFF;\n\t}\n}\nutils.inherits(ArrayReader, DataReader);\n/**\n * @see DataReader.byteAt\n */\nArrayReader.prototype.byteAt = function(i) {\n    return this.data[this.zero + i];\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nArrayReader.prototype.lastIndexOfSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3);\n    for (var i = this.length - 4; i >= 0; --i) {\n        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n            return i - this.zero;\n        }\n    }\n\n    return -1;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */\nArrayReader.prototype.readAndCheckSignature = function (sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3),\n        data = this.readData(4);\n    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];\n};\n/**\n * @see DataReader.readData\n */\nArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        return [];\n    }\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = ArrayReader;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/reader/ArrayReader.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/reader/DataReader.js":
/*!******************************************************!*\
  !*** ../node_modules/jszip/lib/reader/DataReader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\n\nfunction DataReader(data) {\n    this.data = data; // type : see implementation\n    this.length = data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specified index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Read the signature (4 bytes) at the current position and compare it with sig.\n     * @param {string} sig the expected signature\n     * @return {boolean} true if the signature matches, false otherwise.\n     */\n    readAndCheckSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(Date.UTC(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1)); // second\n    }\n};\nmodule.exports = DataReader;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/reader/DataReader.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/reader/NodeBufferReader.js":
/*!************************************************************!*\
  !*** ../node_modules/jszip/lib/reader/NodeBufferReader.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ \"../node_modules/jszip/lib/reader/Uint8ArrayReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\n\nfunction NodeBufferReader(data) {\n    Uint8ArrayReader.call(this, data);\n}\nutils.inherits(NodeBufferReader, Uint8ArrayReader);\n\n/**\n * @see DataReader.readData\n */\nNodeBufferReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = NodeBufferReader;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/reader/NodeBufferReader.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/reader/StringReader.js":
/*!********************************************************!*\
  !*** ../node_modules/jszip/lib/reader/StringReader.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar DataReader = __webpack_require__(/*! ./DataReader */ \"../node_modules/jszip/lib/reader/DataReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\n\nfunction StringReader(data) {\n    DataReader.call(this, data);\n}\nutils.inherits(StringReader, DataReader);\n/**\n * @see DataReader.byteAt\n */\nStringReader.prototype.byteAt = function(i) {\n    return this.data.charCodeAt(this.zero + i);\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nStringReader.prototype.lastIndexOfSignature = function(sig) {\n    return this.data.lastIndexOf(sig) - this.zero;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */\nStringReader.prototype.readAndCheckSignature = function (sig) {\n    var data = this.readData(4);\n    return sig === data;\n};\n/**\n * @see DataReader.readData\n */\nStringReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    // this will work because the constructor applied the \"& 0xff\" mask.\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = StringReader;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/reader/StringReader.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/reader/Uint8ArrayReader.js":
/*!************************************************************!*\
  !*** ../node_modules/jszip/lib/reader/Uint8ArrayReader.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ArrayReader = __webpack_require__(/*! ./ArrayReader */ \"../node_modules/jszip/lib/reader/ArrayReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\n\nfunction Uint8ArrayReader(data) {\n    ArrayReader.call(this, data);\n}\nutils.inherits(Uint8ArrayReader, ArrayReader);\n/**\n * @see DataReader.readData\n */\nUint8ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n        return new Uint8Array(0);\n    }\n    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = Uint8ArrayReader;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/reader/Uint8ArrayReader.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/reader/readerFor.js":
/*!*****************************************************!*\
  !*** ../node_modules/jszip/lib/reader/readerFor.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ../support */ \"../node_modules/jszip/lib/support.js\");\nvar ArrayReader = __webpack_require__(/*! ./ArrayReader */ \"../node_modules/jszip/lib/reader/ArrayReader.js\");\nvar StringReader = __webpack_require__(/*! ./StringReader */ \"../node_modules/jszip/lib/reader/StringReader.js\");\nvar NodeBufferReader = __webpack_require__(/*! ./NodeBufferReader */ \"../node_modules/jszip/lib/reader/NodeBufferReader.js\");\nvar Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ \"../node_modules/jszip/lib/reader/Uint8ArrayReader.js\");\n\n/**\n * Create a reader adapted to the data.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.\n * @return {DataReader} the data reader.\n */\nmodule.exports = function (data) {\n    var type = utils.getTypeOf(data);\n    utils.checkSupport(type);\n    if (type === \"string\" && !support.uint8array) {\n        return new StringReader(data);\n    }\n    if (type === \"nodebuffer\") {\n        return new NodeBufferReader(data);\n    }\n    if (support.uint8array) {\n        return new Uint8ArrayReader(utils.transformTo(\"uint8array\", data));\n    }\n    return new ArrayReader(utils.transformTo(\"array\", data));\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/reader/readerFor.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/signature.js":
/*!**********************************************!*\
  !*** ../node_modules/jszip/lib/signature.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.LOCAL_FILE_HEADER = \"PK\\x03\\x04\";\nexports.CENTRAL_FILE_HEADER = \"PK\\x01\\x02\";\nexports.CENTRAL_DIRECTORY_END = \"PK\\x05\\x06\";\nexports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\x06\\x07\";\nexports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\x06\\x06\";\nexports.DATA_DESCRIPTOR = \"PK\\x07\\x08\";\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/signature.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/stream/ConvertWorker.js":
/*!*********************************************************!*\
  !*** ../node_modules/jszip/lib/stream/ConvertWorker.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\n\n/**\n * A worker which convert chunks to a specified type.\n * @constructor\n * @param {String} destType the destination type.\n */\nfunction ConvertWorker(destType) {\n    GenericWorker.call(this, \"ConvertWorker to \" + destType);\n    this.destType = destType;\n}\nutils.inherits(ConvertWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nConvertWorker.prototype.processChunk = function (chunk) {\n    this.push({\n        data : utils.transformTo(this.destType, chunk.data),\n        meta : chunk.meta\n    });\n};\nmodule.exports = ConvertWorker;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/stream/ConvertWorker.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/stream/Crc32Probe.js":
/*!******************************************************!*\
  !*** ../node_modules/jszip/lib/stream/Crc32Probe.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\nvar crc32 = __webpack_require__(/*! ../crc32 */ \"../node_modules/jszip/lib/crc32.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\n\n/**\n * A worker which calculate the crc32 of the data flowing through.\n * @constructor\n */\nfunction Crc32Probe() {\n    GenericWorker.call(this, \"Crc32Probe\");\n    this.withStreamInfo(\"crc32\", 0);\n}\nutils.inherits(Crc32Probe, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nCrc32Probe.prototype.processChunk = function (chunk) {\n    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);\n    this.push(chunk);\n};\nmodule.exports = Crc32Probe;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/stream/Crc32Probe.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/stream/DataLengthProbe.js":
/*!***********************************************************!*\
  !*** ../node_modules/jszip/lib/stream/DataLengthProbe.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\n\n/**\n * A worker which calculate the total length of the data flowing through.\n * @constructor\n * @param {String} propName the name used to expose the length\n */\nfunction DataLengthProbe(propName) {\n    GenericWorker.call(this, \"DataLengthProbe for \" + propName);\n    this.propName = propName;\n    this.withStreamInfo(propName, 0);\n}\nutils.inherits(DataLengthProbe, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nDataLengthProbe.prototype.processChunk = function (chunk) {\n    if(chunk) {\n        var length = this.streamInfo[this.propName] || 0;\n        this.streamInfo[this.propName] = length + chunk.data.length;\n    }\n    GenericWorker.prototype.processChunk.call(this, chunk);\n};\nmodule.exports = DataLengthProbe;\n\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/stream/DataLengthProbe.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/stream/DataWorker.js":
/*!******************************************************!*\
  !*** ../node_modules/jszip/lib/stream/DataWorker.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\n\n// the size of the generated chunks\n// TODO expose this as a public variable\nvar DEFAULT_BLOCK_SIZE = 16 * 1024;\n\n/**\n * A worker that reads a content and emits chunks.\n * @constructor\n * @param {Promise} dataP the promise of the data to split\n */\nfunction DataWorker(dataP) {\n    GenericWorker.call(this, \"DataWorker\");\n    var self = this;\n    this.dataIsReady = false;\n    this.index = 0;\n    this.max = 0;\n    this.data = null;\n    this.type = \"\";\n\n    this._tickScheduled = false;\n\n    dataP.then(function (data) {\n        self.dataIsReady = true;\n        self.data = data;\n        self.max = data && data.length || 0;\n        self.type = utils.getTypeOf(data);\n        if(!self.isPaused) {\n            self._tickAndRepeat();\n        }\n    }, function (e) {\n        self.error(e);\n    });\n}\n\nutils.inherits(DataWorker, GenericWorker);\n\n/**\n * @see GenericWorker.cleanUp\n */\nDataWorker.prototype.cleanUp = function () {\n    GenericWorker.prototype.cleanUp.call(this);\n    this.data = null;\n};\n\n/**\n * @see GenericWorker.resume\n */\nDataWorker.prototype.resume = function () {\n    if(!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n\n    if (!this._tickScheduled && this.dataIsReady) {\n        this._tickScheduled = true;\n        utils.delay(this._tickAndRepeat, [], this);\n    }\n    return true;\n};\n\n/**\n * Trigger a tick a schedule an other call to this function.\n */\nDataWorker.prototype._tickAndRepeat = function() {\n    this._tickScheduled = false;\n    if(this.isPaused || this.isFinished) {\n        return;\n    }\n    this._tick();\n    if(!this.isFinished) {\n        utils.delay(this._tickAndRepeat, [], this);\n        this._tickScheduled = true;\n    }\n};\n\n/**\n * Read and push a chunk.\n */\nDataWorker.prototype._tick = function() {\n\n    if(this.isPaused || this.isFinished) {\n        return false;\n    }\n\n    var size = DEFAULT_BLOCK_SIZE;\n    var data = null, nextIndex = Math.min(this.max, this.index + size);\n    if (this.index >= this.max) {\n        // EOF\n        return this.end();\n    } else {\n        switch(this.type) {\n            case \"string\":\n                data = this.data.substring(this.index, nextIndex);\n            break;\n            case \"uint8array\":\n                data = this.data.subarray(this.index, nextIndex);\n            break;\n            case \"array\":\n            case \"nodebuffer\":\n                data = this.data.slice(this.index, nextIndex);\n            break;\n        }\n        this.index = nextIndex;\n        return this.push({\n            data : data,\n            meta : {\n                percent : this.max ? this.index / this.max * 100 : 0\n            }\n        });\n    }\n};\n\nmodule.exports = DataWorker;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/stream/DataWorker.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/stream/GenericWorker.js":
/*!*********************************************************!*\
  !*** ../node_modules/jszip/lib/stream/GenericWorker.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * A worker that does nothing but passing chunks to the next one. This is like\n * a nodejs stream but with some differences. On the good side :\n * - it works on IE 6-9 without any issue / polyfill\n * - it weights less than the full dependencies bundled with browserify\n * - it forwards errors (no need to declare an error handler EVERYWHERE)\n *\n * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\n * object containing anything (`percent` for example), see each worker for more\n * details. The latter is the real data (String, Uint8Array, etc).\n *\n * @constructor\n * @param {String} name the name of the stream (mainly used for debugging purposes)\n */\nfunction GenericWorker(name) {\n    // the name of the worker\n    this.name = name || \"default\";\n    // an object containing metadata about the workers chain\n    this.streamInfo = {};\n    // an error which happened when the worker was paused\n    this.generatedError = null;\n    // an object containing metadata to be merged by this worker into the general metadata\n    this.extraStreamInfo = {};\n    // true if the stream is paused (and should not do anything), false otherwise\n    this.isPaused = true;\n    // true if the stream is finished (and should not do anything), false otherwise\n    this.isFinished = false;\n    // true if the stream is locked to prevent further structure updates (pipe), false otherwise\n    this.isLocked = false;\n    // the event listeners\n    this._listeners = {\n        'data':[],\n        'end':[],\n        'error':[]\n    };\n    // the previous worker, if any\n    this.previous = null;\n}\n\nGenericWorker.prototype = {\n    /**\n     * Push a chunk to the next workers.\n     * @param {Object} chunk the chunk to push\n     */\n    push : function (chunk) {\n        this.emit(\"data\", chunk);\n    },\n    /**\n     * End the stream.\n     * @return {Boolean} true if this call ended the worker, false otherwise.\n     */\n    end : function () {\n        if (this.isFinished) {\n            return false;\n        }\n\n        this.flush();\n        try {\n            this.emit(\"end\");\n            this.cleanUp();\n            this.isFinished = true;\n        } catch (e) {\n            this.emit(\"error\", e);\n        }\n        return true;\n    },\n    /**\n     * End the stream with an error.\n     * @param {Error} e the error which caused the premature end.\n     * @return {Boolean} true if this call ended the worker with an error, false otherwise.\n     */\n    error : function (e) {\n        if (this.isFinished) {\n            return false;\n        }\n\n        if(this.isPaused) {\n            this.generatedError = e;\n        } else {\n            this.isFinished = true;\n\n            this.emit(\"error\", e);\n\n            // in the workers chain exploded in the middle of the chain,\n            // the error event will go downward but we also need to notify\n            // workers upward that there has been an error.\n            if(this.previous) {\n                this.previous.error(e);\n            }\n\n            this.cleanUp();\n        }\n        return true;\n    },\n    /**\n     * Add a callback on an event.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Function} listener the function to call when the event is triggered\n     * @return {GenericWorker} the current object for chainability\n     */\n    on : function (name, listener) {\n        this._listeners[name].push(listener);\n        return this;\n    },\n    /**\n     * Clean any references when a worker is ending.\n     */\n    cleanUp : function () {\n        this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n        this._listeners = [];\n    },\n    /**\n     * Trigger an event. This will call registered callback with the provided arg.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Object} arg the argument to call the callback with.\n     */\n    emit : function (name, arg) {\n        if (this._listeners[name]) {\n            for(var i = 0; i < this._listeners[name].length; i++) {\n                this._listeners[name][i].call(this, arg);\n            }\n        }\n    },\n    /**\n     * Chain a worker with an other.\n     * @param {Worker} next the worker receiving events from the current one.\n     * @return {worker} the next worker for chainability\n     */\n    pipe : function (next) {\n        return next.registerPrevious(this);\n    },\n    /**\n     * Same as `pipe` in the other direction.\n     * Using an API with `pipe(next)` is very easy.\n     * Implementing the API with the point of view of the next one registering\n     * a source is easier, see the ZipFileWorker.\n     * @param {Worker} previous the previous worker, sending events to this one\n     * @return {Worker} the current worker for chainability\n     */\n    registerPrevious : function (previous) {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n\n        // sharing the streamInfo...\n        this.streamInfo = previous.streamInfo;\n        // ... and adding our own bits\n        this.mergeStreamInfo();\n        this.previous =  previous;\n        var self = this;\n        previous.on('data', function (chunk) {\n            self.processChunk(chunk);\n        });\n        previous.on('end', function () {\n            self.end();\n        });\n        previous.on('error', function (e) {\n            self.error(e);\n        });\n        return this;\n    },\n    /**\n     * Pause the stream so it doesn't send events anymore.\n     * @return {Boolean} true if this call paused the worker, false otherwise.\n     */\n    pause : function () {\n        if(this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = true;\n\n        if(this.previous) {\n            this.previous.pause();\n        }\n        return true;\n    },\n    /**\n     * Resume a paused stream.\n     * @return {Boolean} true if this call resumed the worker, false otherwise.\n     */\n    resume : function () {\n        if(!this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = false;\n\n        // if true, the worker tried to resume but failed\n        var withError = false;\n        if(this.generatedError) {\n            this.error(this.generatedError);\n            withError = true;\n        }\n        if(this.previous) {\n            this.previous.resume();\n        }\n\n        return !withError;\n    },\n    /**\n     * Flush any remaining bytes as the stream is ending.\n     */\n    flush : function () {},\n    /**\n     * Process a chunk. This is usually the method overridden.\n     * @param {Object} chunk the chunk to process.\n     */\n    processChunk : function(chunk) {\n        this.push(chunk);\n    },\n    /**\n     * Add a key/value to be added in the workers chain streamInfo once activated.\n     * @param {String} key the key to use\n     * @param {Object} value the associated value\n     * @return {Worker} the current worker for chainability\n     */\n    withStreamInfo : function (key, value) {\n        this.extraStreamInfo[key] = value;\n        this.mergeStreamInfo();\n        return this;\n    },\n    /**\n     * Merge this worker's streamInfo into the chain's streamInfo.\n     */\n    mergeStreamInfo : function () {\n        for(var key in this.extraStreamInfo) {\n            if (!this.extraStreamInfo.hasOwnProperty(key)) {\n                continue;\n            }\n            this.streamInfo[key] = this.extraStreamInfo[key];\n        }\n    },\n\n    /**\n     * Lock the stream to prevent further updates on the workers chain.\n     * After calling this method, all calls to pipe will fail.\n     */\n    lock: function () {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n        this.isLocked = true;\n        if (this.previous) {\n            this.previous.lock();\n        }\n    },\n\n    /**\n     *\n     * Pretty print the workers chain.\n     */\n    toString : function () {\n        var me = \"Worker \" + this.name;\n        if (this.previous) {\n            return this.previous + \" -> \" + me;\n        } else {\n            return me;\n        }\n    }\n};\n\nmodule.exports = GenericWorker;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/stream/GenericWorker.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/stream/StreamHelper.js":
/*!********************************************************!*\
  !*** ../node_modules/jszip/lib/stream/StreamHelper.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/jszip/lib/utils.js\");\nvar ConvertWorker = __webpack_require__(/*! ./ConvertWorker */ \"../node_modules/jszip/lib/stream/ConvertWorker.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\nvar base64 = __webpack_require__(/*! ../base64 */ \"../node_modules/jszip/lib/base64.js\");\nvar support = __webpack_require__(/*! ../support */ \"../node_modules/jszip/lib/support.js\");\nvar external = __webpack_require__(/*! ../external */ \"../node_modules/jszip/lib/external.js\");\n\nvar NodejsStreamOutputAdapter = null;\nif (support.nodestream) {\n    try {\n        NodejsStreamOutputAdapter = __webpack_require__(/*! ../nodejs/NodejsStreamOutputAdapter */ \"../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js\");\n    } catch(e) {}\n}\n\n/**\n * Apply the final transformation of the data. If the user wants a Blob for\n * example, it's easier to work with an U8intArray and finally do the\n * ArrayBuffer/Blob conversion.\n * @param {String} type the name of the final type\n * @param {String|Uint8Array|Buffer} content the content to transform\n * @param {String} mimeType the mime type of the content, if applicable.\n * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.\n */\nfunction transformZipOutput(type, content, mimeType) {\n    switch(type) {\n        case \"blob\" :\n            return utils.newBlob(utils.transformTo(\"arraybuffer\", content), mimeType);\n        case \"base64\" :\n            return base64.encode(content);\n        default :\n            return utils.transformTo(type, content);\n    }\n}\n\n/**\n * Concatenate an array of data of the given type.\n * @param {String} type the type of the data in the given array.\n * @param {Array} dataArray the array containing the data chunks to concatenate\n * @return {String|Uint8Array|Buffer} the concatenated data\n * @throws Error if the asked type is unsupported\n */\nfunction concat (type, dataArray) {\n    var i, index = 0, res = null, totalLength = 0;\n    for(i = 0; i < dataArray.length; i++) {\n        totalLength += dataArray[i].length;\n    }\n    switch(type) {\n        case \"string\":\n            return dataArray.join(\"\");\n          case \"array\":\n            return Array.prototype.concat.apply([], dataArray);\n        case \"uint8array\":\n            res = new Uint8Array(totalLength);\n            for(i = 0; i < dataArray.length; i++) {\n                res.set(dataArray[i], index);\n                index += dataArray[i].length;\n            }\n            return res;\n        case \"nodebuffer\":\n            return Buffer.concat(dataArray);\n        default:\n            throw new Error(\"concat : unsupported type '\"  + type + \"'\");\n    }\n}\n\n/**\n * Listen a StreamHelper, accumulate its content and concatenate it into a\n * complete block.\n * @param {StreamHelper} helper the helper to use.\n * @param {Function} updateCallback a callback called on each update. Called\n * with one arg :\n * - the metadata linked to the update received.\n * @return Promise the promise for the accumulation.\n */\nfunction accumulate(helper, updateCallback) {\n    return new external.Promise(function (resolve, reject){\n        var dataArray = [];\n        var chunkType = helper._internalType,\n            resultType = helper._outputType,\n            mimeType = helper._mimeType;\n        helper\n        .on('data', function (data, meta) {\n            dataArray.push(data);\n            if(updateCallback) {\n                updateCallback(meta);\n            }\n        })\n        .on('error', function(err) {\n            dataArray = [];\n            reject(err);\n        })\n        .on('end', function (){\n            try {\n                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n                resolve(result);\n            } catch (e) {\n                reject(e);\n            }\n            dataArray = [];\n        })\n        .resume();\n    });\n}\n\n/**\n * An helper to easily use workers outside of JSZip.\n * @constructor\n * @param {Worker} worker the worker to wrap\n * @param {String} outputType the type of data expected by the use\n * @param {String} mimeType the mime type of the content, if applicable.\n */\nfunction StreamHelper(worker, outputType, mimeType) {\n    var internalType = outputType;\n    switch(outputType) {\n        case \"blob\":\n        case \"arraybuffer\":\n            internalType = \"uint8array\";\n        break;\n        case \"base64\":\n            internalType = \"string\";\n        break;\n    }\n\n    try {\n        // the type used internally\n        this._internalType = internalType;\n        // the type used to output results\n        this._outputType = outputType;\n        // the mime type\n        this._mimeType = mimeType;\n        utils.checkSupport(internalType);\n        this._worker = worker.pipe(new ConvertWorker(internalType));\n        // the last workers can be rewired without issues but we need to\n        // prevent any updates on previous workers.\n        worker.lock();\n    } catch(e) {\n        this._worker = new GenericWorker(\"error\");\n        this._worker.error(e);\n    }\n}\n\nStreamHelper.prototype = {\n    /**\n     * Listen a StreamHelper, accumulate its content and concatenate it into a\n     * complete block.\n     * @param {Function} updateCb the update callback.\n     * @return Promise the promise for the accumulation.\n     */\n    accumulate : function (updateCb) {\n        return accumulate(this, updateCb);\n    },\n    /**\n     * Add a listener on an event triggered on a stream.\n     * @param {String} evt the name of the event\n     * @param {Function} fn the listener\n     * @return {StreamHelper} the current helper.\n     */\n    on : function (evt, fn) {\n        var self = this;\n\n        if(evt === \"data\") {\n            this._worker.on(evt, function (chunk) {\n                fn.call(self, chunk.data, chunk.meta);\n            });\n        } else {\n            this._worker.on(evt, function () {\n                utils.delay(fn, arguments, self);\n            });\n        }\n        return this;\n    },\n    /**\n     * Resume the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */\n    resume : function () {\n        utils.delay(this._worker.resume, [], this._worker);\n        return this;\n    },\n    /**\n     * Pause the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */\n    pause : function () {\n        this._worker.pause();\n        return this;\n    },\n    /**\n     * Return a nodejs stream for this helper.\n     * @param {Function} updateCb the update callback.\n     * @return {NodejsStreamOutputAdapter} the nodejs stream.\n     */\n    toNodejsStream : function (updateCb) {\n        utils.checkSupport(\"nodestream\");\n        if (this._outputType !== \"nodebuffer\") {\n            // an object stream containing blob/arraybuffer/uint8array/string\n            // is strange and I don't know if it would be useful.\n            // I you find this comment and have a good usecase, please open a\n            // bug report !\n            throw new Error(this._outputType + \" is not supported by this method\");\n        }\n\n        return new NodejsStreamOutputAdapter(this, {\n            objectMode : this._outputType !== \"nodebuffer\"\n        }, updateCb);\n    }\n};\n\n\nmodule.exports = StreamHelper;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/stream/StreamHelper.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/support.js":
/*!********************************************!*\
  !*** ../node_modules/jszip/lib/support.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.base64 = true;\nexports.array = true;\nexports.string = true;\nexports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\nexports.nodebuffer = typeof Buffer !== \"undefined\";\n// contains true if JSZip can read/generate Uint8Array, false otherwise.\nexports.uint8array = typeof Uint8Array !== \"undefined\";\n\nif (typeof ArrayBuffer === \"undefined\") {\n    exports.blob = false;\n}\nelse {\n    var buffer = new ArrayBuffer(0);\n    try {\n        exports.blob = new Blob([buffer], {\n            type: \"application/zip\"\n        }).size === 0;\n    }\n    catch (e) {\n        try {\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            exports.blob = builder.getBlob('application/zip').size === 0;\n        }\n        catch (e) {\n            exports.blob = false;\n        }\n    }\n}\n\ntry {\n    exports.nodestream = !!__webpack_require__(/*! readable-stream */ \"../node_modules/jszip/node_modules/readable-stream/readable.js\").Readable;\n} catch(e) {\n    exports.nodestream = false;\n}\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/support.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/utf8.js":
/*!*****************************************!*\
  !*** ../node_modules/jszip/lib/utf8.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"../node_modules/jszip/lib/nodejsUtils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodejsUtils.newBufferFrom(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    return buf2string(buf);\n};\n\n/**\n * A worker to decode utf8 encoded binary chunks into string chunks.\n * @constructor\n */\nfunction Utf8DecodeWorker() {\n    GenericWorker.call(this, \"utf-8 decode\");\n    // the last bytes if a chunk didn't end with a complete codepoint.\n    this.leftOver = null;\n}\nutils.inherits(Utf8DecodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8DecodeWorker.prototype.processChunk = function (chunk) {\n\n    var data = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data);\n\n    // 1st step, re-use what's left of the previous chunk\n    if (this.leftOver && this.leftOver.length) {\n        if(support.uint8array) {\n            var previousData = data;\n            data = new Uint8Array(previousData.length + this.leftOver.length);\n            data.set(this.leftOver, 0);\n            data.set(previousData, this.leftOver.length);\n        } else {\n            data = this.leftOver.concat(data);\n        }\n        this.leftOver = null;\n    }\n\n    var nextBoundary = utf8border(data);\n    var usableData = data;\n    if (nextBoundary !== data.length) {\n        if (support.uint8array) {\n            usableData = data.subarray(0, nextBoundary);\n            this.leftOver = data.subarray(nextBoundary, data.length);\n        } else {\n            usableData = data.slice(0, nextBoundary);\n            this.leftOver = data.slice(nextBoundary, data.length);\n        }\n    }\n\n    this.push({\n        data : exports.utf8decode(usableData),\n        meta : chunk.meta\n    });\n};\n\n/**\n * @see GenericWorker.flush\n */\nUtf8DecodeWorker.prototype.flush = function () {\n    if(this.leftOver && this.leftOver.length) {\n        this.push({\n            data : exports.utf8decode(this.leftOver),\n            meta : {}\n        });\n        this.leftOver = null;\n    }\n};\nexports.Utf8DecodeWorker = Utf8DecodeWorker;\n\n/**\n * A worker to endcode string chunks into utf8 encoded binary chunks.\n * @constructor\n */\nfunction Utf8EncodeWorker() {\n    GenericWorker.call(this, \"utf-8 encode\");\n}\nutils.inherits(Utf8EncodeWorker, GenericWorker);\n\n/**\n * @see GenericWorker.processChunk\n */\nUtf8EncodeWorker.prototype.processChunk = function (chunk) {\n    this.push({\n        data : exports.utf8encode(chunk.data),\n        meta : chunk.meta\n    });\n};\nexports.Utf8EncodeWorker = Utf8EncodeWorker;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/utf8.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/utils.js":
/*!******************************************!*\
  !*** ../node_modules/jszip/lib/utils.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\nvar base64 = __webpack_require__(/*! ./base64 */ \"../node_modules/jszip/lib/base64.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"../node_modules/jszip/lib/nodejsUtils.js\");\nvar setImmediate = __webpack_require__(/*! core-js/library/fn/set-immediate */ \"../node_modules/jszip/node_modules/core-js/library/fn/set-immediate.js\");\nvar external = __webpack_require__(/*! ./external */ \"../node_modules/jszip/lib/external.js\");\n\n\n/**\n * Convert a string that pass as a \"binary string\": it should represent a byte\n * array but may have > 255 char codes. Be sure to take only the first byte\n * and returns the byte array.\n * @param {String} str the string to transform.\n * @return {Array|Uint8Array} the string in a binary format.\n */\nfunction string2binary(str) {\n    var result = null;\n    if (support.uint8array) {\n      result = new Uint8Array(str.length);\n    } else {\n      result = new Array(str.length);\n    }\n    return stringToArrayLike(str, result);\n}\n\n/**\n * Create a new blob with the given content and the given type.\n * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use\n * an Uint8Array because the stock browser of android 4 won't accept it (it\n * will be silently converted to a string, \"[object Uint8Array]\").\n *\n * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:\n * when a large amount of Array is used to create the Blob, the amount of\n * memory consumed is nearly 100 times the original data amount.\n *\n * @param {String} type the mime type of the blob.\n * @return {Blob} the created blob.\n */\nexports.newBlob = function(part, type) {\n    exports.checkSupport(\"blob\");\n\n    try {\n        // Blob constructor\n        return new Blob([part], {\n            type: type\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(part);\n            return builder.getBlob(type);\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * An helper for the function arrayLikeToString.\n * This contains static informations and functions that\n * can be optimized by the browser JIT compiler.\n */\nvar arrayToStringHelper = {\n    /**\n     * Transform an array of int into a string, chunk by chunk.\n     * See the performances notes on arrayLikeToString.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @param {String} type the type of the array.\n     * @param {Integer} chunk the chunk size.\n     * @return {String} the resulting string.\n     * @throws Error if the chunk is too big for the stack.\n     */\n    stringifyByChunk: function(array, type, chunk) {\n        var result = [], k = 0, len = array.length;\n        // shortcut\n        if (len <= chunk) {\n            return String.fromCharCode.apply(null, array);\n        }\n        while (k < len) {\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        return result.join(\"\");\n    },\n    /**\n     * Call String.fromCharCode on every item in the array.\n     * This is the naive implementation, which generate A LOT of intermediate string.\n     * This should be used when everything else fail.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @return {String} the result.\n     */\n    stringifyByChar: function(array){\n        var resultStr = \"\";\n        for(var i = 0; i < array.length; i++) {\n            resultStr += String.fromCharCode(array[i]);\n        }\n        return resultStr;\n    },\n    applyCanBeUsed : {\n        /**\n         * true if the browser accepts to use String.fromCharCode on Uint8Array\n         */\n        uint8array : (function () {\n            try {\n                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        })(),\n        /**\n         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.\n         */\n        nodebuffer : (function () {\n            try {\n                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        })()\n    }\n};\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    // TODO : we now have workers that split the work. Do we still need that ?\n    var chunk = 65536,\n        type = exports.getTypeOf(array),\n        canUseApply = true;\n    if (type === \"uint8array\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;\n    } else if (type === \"nodebuffer\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;\n    }\n\n    if (canUseApply) {\n        while (chunk > 1) {\n            try {\n                return arrayToStringHelper.stringifyByChunk(array, type, chunk);\n            } catch (e) {\n                chunk = Math.floor(chunk / 2);\n            }\n        }\n    }\n\n    // no apply or chunk error : slow and painful algorithm\n    // default browser on android 4.*\n    return arrayToStringHelper.stringifyByChar(array);\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this platform\");\n    }\n};\n\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = '',\n        code, i;\n    for (i = 0; i < (str || \"\").length; i++) {\n        code = str.charCodeAt(i);\n        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Defer the call of a function.\n * @param {Function} callback the function to call asynchronously.\n * @param {Array} args the arguments to give to the callback.\n */\nexports.delay = function(callback, args, self) {\n    setImmediate(function () {\n        callback.apply(self || null, args || []);\n    });\n};\n\n/**\n * Extends a prototype with an other, without calling a constructor with\n * side effects. Inspired by nodejs' `utils.inherits`\n * @param {Function} ctor the constructor to augment\n * @param {Function} superCtor the parent constructor to use\n */\nexports.inherits = function (ctor, superCtor) {\n    var Obj = function() {};\n    Obj.prototype = superCtor.prototype;\n    ctor.prototype = new Obj();\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nexports.extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Transform arbitrary content into a Promise.\n * @param {String} name a name for the content being processed.\n * @param {Object} inputData the content to process.\n * @param {Boolean} isBinary true if the content is not an unicode string\n * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.\n * @param {Boolean} isBase64 true if the string content is encoded with base64.\n * @return {Promise} a promise in a format usable by JSZip.\n */\nexports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n\n    // if inputData is already a promise, this flatten it.\n    var promise = external.Promise.resolve(inputData).then(function(data) {\n        \n        \n        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);\n\n        if (isBlob && typeof FileReader !== \"undefined\") {\n            return new external.Promise(function (resolve, reject) {\n                var reader = new FileReader();\n\n                reader.onload = function(e) {\n                    resolve(e.target.result);\n                };\n                reader.onerror = function(e) {\n                    reject(e.target.error);\n                };\n                reader.readAsArrayBuffer(data);\n            });\n        } else {\n            return data;\n        }\n    });\n\n    return promise.then(function(data) {\n        var dataType = exports.getTypeOf(data);\n\n        if (!dataType) {\n            return external.Promise.reject(\n                new Error(\"Can't read the data of '\" + name + \"'. Is it \" +\n                          \"in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\")\n            );\n        }\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = exports.transformTo(\"uint8array\", data);\n        } else if (dataType === \"string\") {\n            if (isBase64) {\n                data = base64.decode(data);\n            }\n            else if (isBinary) {\n                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask\n                if (isOptimizedBinaryString !== true) {\n                    // this is a string, not in a base64 format.\n                    // Be sure that this is a correct \"binary string\"\n                    data = string2binary(data);\n                }\n            }\n        }\n        return data;\n    });\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/utils.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/zipEntries.js":
/*!***********************************************!*\
  !*** ../node_modules/jszip/lib/zipEntries.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar readerFor = __webpack_require__(/*! ./reader/readerFor */ \"../node_modules/jszip/lib/reader/readerFor.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar sig = __webpack_require__(/*! ./signature */ \"../node_modules/jszip/lib/signature.js\");\nvar ZipEntry = __webpack_require__(/*! ./zipEntry */ \"../node_modules/jszip/lib/zipEntry.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"../node_modules/jszip/lib/utf8.js\");\nvar support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\n//  class ZipEntries {{{\n/**\n * All the entries in the zip file.\n * @constructor\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntries(loadOptions) {\n    this.files = [];\n    this.loadOptions = loadOptions;\n}\nZipEntries.prototype = {\n    /**\n     * Check that the reader is on the specified signature.\n     * @param {string} expectedSignature the expected signature.\n     * @throws {Error} if it is an other signature.\n     */\n    checkSignature: function(expectedSignature) {\n        if (!this.reader.readAndCheckSignature(expectedSignature)) {\n            this.reader.index -= 4;\n            var signature = this.reader.readString(4);\n            throw new Error(\"Corrupted zip or bug: unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n        }\n    },\n    /**\n     * Check if the given signature is at the given index.\n     * @param {number} askedIndex the index to check.\n     * @param {string} expectedSignature the signature to expect.\n     * @return {boolean} true if the signature is here, false otherwise.\n     */\n    isSignature: function(askedIndex, expectedSignature) {\n        var currentIndex = this.reader.index;\n        this.reader.setIndex(askedIndex);\n        var signature = this.reader.readString(4);\n        var result = signature === expectedSignature;\n        this.reader.setIndex(currentIndex);\n        return result;\n    },\n    /**\n     * Read the end of the central directory.\n     */\n    readBlockEndOfCentral: function() {\n        this.diskNumber = this.reader.readInt(2);\n        this.diskWithCentralDirStart = this.reader.readInt(2);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n        this.centralDirRecords = this.reader.readInt(2);\n        this.centralDirSize = this.reader.readInt(4);\n        this.centralDirOffset = this.reader.readInt(4);\n\n        this.zipCommentLength = this.reader.readInt(2);\n        // warning : the encoding depends of the system locale\n        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n        // On a windows machine, this field is encoded with the localized windows code page.\n        var zipComment = this.reader.readData(this.zipCommentLength);\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        // To get consistent behavior with the generation part, we will assume that\n        // this is utf8 encoded unless specified otherwise.\n        var decodeContent = utils.transformTo(decodeParamType, zipComment);\n        this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n    },\n    /**\n     * Read the end of the Zip 64 central directory.\n     * Not merged with the method readEndOfCentral :\n     * The end of central can coexist with its Zip64 brother,\n     * I don't want to read the wrong number of bytes !\n     */\n    readBlockZip64EndOfCentral: function() {\n        this.zip64EndOfCentralSize = this.reader.readInt(8);\n        this.reader.skip(4);\n        // this.versionMadeBy = this.reader.readString(2);\n        // this.versionNeeded = this.reader.readInt(2);\n        this.diskNumber = this.reader.readInt(4);\n        this.diskWithCentralDirStart = this.reader.readInt(4);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n        this.centralDirRecords = this.reader.readInt(8);\n        this.centralDirSize = this.reader.readInt(8);\n        this.centralDirOffset = this.reader.readInt(8);\n\n        this.zip64ExtensibleData = {};\n        var extraDataSize = this.zip64EndOfCentralSize - 44,\n            index = 0,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n        while (index < extraDataSize) {\n            extraFieldId = this.reader.readInt(2);\n            extraFieldLength = this.reader.readInt(4);\n            extraFieldValue = this.reader.readData(extraFieldLength);\n            this.zip64ExtensibleData[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Read the end of the Zip 64 central directory locator.\n     */\n    readBlockZip64EndOfCentralLocator: function() {\n        this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n        this.disksCount = this.reader.readInt(4);\n        if (this.disksCount > 1) {\n            throw new Error(\"Multi-volumes zip are not supported\");\n        }\n    },\n    /**\n     * Read the local files, based on the offset read in the central part.\n     */\n    readLocalFiles: function() {\n        var i, file;\n        for (i = 0; i < this.files.length; i++) {\n            file = this.files[i];\n            this.reader.setIndex(file.localHeaderOffset);\n            this.checkSignature(sig.LOCAL_FILE_HEADER);\n            file.readLocalPart(this.reader);\n            file.handleUTF8();\n            file.processAttributes();\n        }\n    },\n    /**\n     * Read the central directory.\n     */\n    readCentralDir: function() {\n        var file;\n\n        this.reader.setIndex(this.centralDirOffset);\n        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {\n            file = new ZipEntry({\n                zip64: this.zip64\n            }, this.loadOptions);\n            file.readCentralPart(this.reader);\n            this.files.push(file);\n        }\n\n        if (this.centralDirRecords !== this.files.length) {\n            if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                // We expected some records but couldn't find ANY.\n                // This is really suspicious, as if something went wrong.\n                throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n            } else {\n                // We found some records but not all.\n                // Something is wrong but we got something for the user: no error here.\n                // console.warn(\"expected\", this.centralDirRecords, \"records in central dir, got\", this.files.length);\n            }\n        }\n    },\n    /**\n     * Read the end of central directory.\n     */\n    readEndOfCentral: function() {\n        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n        if (offset < 0) {\n            // Check if the content is a truncated zip or complete garbage.\n            // A \"LOCAL_FILE_HEADER\" is not required at the beginning (auto\n            // extractible zip for example) but it can give a good hint.\n            // If an ajax request was used without responseType, we will also\n            // get unreadable data.\n            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n\n            if (isGarbage) {\n                throw new Error(\"Can't find end of central directory : is this a zip file ? \" +\n                                \"If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\");\n            } else {\n                throw new Error(\"Corrupted zip: can't find end of central directory\");\n            }\n\n        }\n        this.reader.setIndex(offset);\n        var endOfCentralDirOffset = offset;\n        this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n        this.readBlockEndOfCentral();\n\n\n        /* extract from the zip spec :\n            4)  If one of the fields in the end of central directory\n                record is too small to hold required data, the field\n                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n                ZIP64 format record should be created.\n            5)  The end of central directory record and the\n                Zip64 end of central directory locator record must\n                reside on the same disk when splitting or spanning\n                an archive.\n         */\n        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n            this.zip64 = true;\n\n            /*\n            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents\n            all numbers as 64-bit double precision IEEE 754 floating point numbers.\n            So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5\n            */\n\n            // should look for a zip64 EOCD locator\n            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            if (offset < 0) {\n                throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n            }\n            this.reader.setIndex(offset);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            this.readBlockZip64EndOfCentralLocator();\n\n            // now the zip64 EOCD record\n            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                // console.warn(\"ZIP64 end of central directory not where expected.\");\n                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                    throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n                }\n            }\n            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n            this.readBlockZip64EndOfCentral();\n        }\n\n        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n        if (this.zip64) {\n            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator\n            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;\n        }\n\n        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n\n        if (extraBytes > 0) {\n            // console.warn(extraBytes, \"extra bytes at beginning or within zipfile\");\n            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n                // The offsets seem wrong, but we have something at the specified offset.\n                // Soâ€¦ we keep it.\n            } else {\n                // the offset is wrong, update the \"zero\" of the reader\n                // this happens if data has been prepended (crx files for example)\n                this.reader.zero = extraBytes;\n            }\n        } else if (extraBytes < 0) {\n            throw new Error(\"Corrupted zip: missing \" + Math.abs(extraBytes) + \" bytes.\");\n        }\n    },\n    prepareReader: function(data) {\n        this.reader = readerFor(data);\n    },\n    /**\n     * Read a zip file and create ZipEntries.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n     */\n    load: function(data) {\n        this.prepareReader(data);\n        this.readEndOfCentral();\n        this.readCentralDir();\n        this.readLocalFiles();\n    }\n};\n// }}} end of ZipEntries\nmodule.exports = ZipEntries;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/zipEntries.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/zipEntry.js":
/*!*********************************************!*\
  !*** ../node_modules/jszip/lib/zipEntry.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar readerFor = __webpack_require__(/*! ./reader/readerFor */ \"../node_modules/jszip/lib/reader/readerFor.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"../node_modules/jszip/lib/compressedObject.js\");\nvar crc32fn = __webpack_require__(/*! ./crc32 */ \"../node_modules/jszip/lib/crc32.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"../node_modules/jszip/lib/utf8.js\");\nvar compressions = __webpack_require__(/*! ./compressions */ \"../node_modules/jszip/lib/compressions.js\");\nvar support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\n\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nvar findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */\n    isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */\n    useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let's skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n        // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.\n        this.fileName = reader.readData(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n\n        if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n            throw new Error(\"Bug or corrupted zip : didn't get enough informations from the central directory \" + \"(compressedSize === -1 || uncompressedSize === -1)\");\n        }\n\n        compression = findCompression(this.compressionMethod);\n        if (compression === null) { // no compression found\n            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + utils.transformTo(\"string\", this.fileName) + \")\");\n        }\n        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n    },\n\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readInt(2);\n        reader.skip(2);\n        // this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        var fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n\n        if (this.isEncrypted()) {\n            throw new Error(\"Encrypted zip are not supported\");\n        }\n\n        // will be read in the local part, see the comments there\n        reader.skip(fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readData(this.fileCommentLength);\n    },\n\n    /**\n     * Parse the external file attributes and get the unix/dos permissions.\n     */\n    processAttributes: function () {\n        this.unixPermissions = null;\n        this.dosPermissions = null;\n        var madeBy = this.versionMadeBy >> 8;\n\n        // Check if we have the DOS directory flag set.\n        // We look for it in the DOS and UNIX permissions\n        // but some unknown platform could set it as a compatibility flag.\n        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n\n        if(madeBy === MADE_BY_DOS) {\n            // first 6 bits (0 to 5)\n            this.dosPermissions = this.externalFileAttributes & 0x3F;\n        }\n\n        if(madeBy === MADE_BY_UNIX) {\n            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;\n            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n        }\n\n        // fail safe : if the name ends with a / it probably means a folder\n        if (!this.dir && this.fileNameStr.slice(-1) === '/') {\n            this.dir = true;\n        }\n    },\n\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */\n    parseZIP64ExtraField: function(reader) {\n\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n\n        // should be something, preparing the extra reader\n        var extraReader = readerFor(this.extraFields[0x0001].value);\n\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won't let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readExtraFields: function(reader) {\n        var end = reader.index + this.extraFieldsLength,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n\n        if (!this.extraFields) {\n            this.extraFields = {};\n        }\n\n        while (reader.index < end) {\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readData(extraFieldLength);\n\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */\n    handleUTF8: function() {\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        if (this.useUTF8()) {\n            this.fileNameStr = utf8.utf8decode(this.fileName);\n            this.fileCommentStr = utf8.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileNameStr = upath;\n            } else {\n                // ASCII text or unsupported code page\n                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n            }\n\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileCommentStr = ucomment;\n            } else {\n                // ASCII text or unsupported code page\n                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n            }\n        }\n    },\n\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */\n    findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = readerFor(upathField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the filename changed, this field is out of date.\n            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n        }\n        return null;\n    },\n\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */\n    findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = readerFor(ucommentField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the comment changed, this field is out of date.\n            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/zipEntry.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/zipObject.js":
/*!**********************************************!*\
  !*** ../node_modules/jszip/lib/zipObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ \"../node_modules/jszip/lib/stream/StreamHelper.js\");\nvar DataWorker = __webpack_require__(/*! ./stream/DataWorker */ \"../node_modules/jszip/lib/stream/DataWorker.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"../node_modules/jszip/lib/utf8.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"../node_modules/jszip/lib/compressedObject.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"../node_modules/jszip/lib/stream/GenericWorker.js\");\n\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n\n    this._data = data;\n    this._dataBinary = options.binary;\n    // keep only the compression\n    this.options = {\n        compression : options.compression,\n        compressionOptions : options.compressionOptions\n    };\n};\n\nZipObject.prototype = {\n    /**\n     * Create an internal stream for the content of this object.\n     * @param {String} type the type of each chunk.\n     * @return StreamHelper the stream.\n     */\n    internalStream: function (type) {\n        var result = null, outputType = \"string\";\n        try {\n            if (!type) {\n                throw new Error(\"No output type specified.\");\n            }\n            outputType = type.toLowerCase();\n            var askUnicodeString = outputType === \"string\" || outputType === \"text\";\n            if (outputType === \"binarystring\" || outputType === \"text\") {\n                outputType = \"string\";\n            }\n            result = this._decompressWorker();\n\n            var isUnicodeString = !this._dataBinary;\n\n            if (isUnicodeString && !askUnicodeString) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            if (!isUnicodeString && askUnicodeString) {\n                result = result.pipe(new utf8.Utf8DecodeWorker());\n            }\n        } catch (e) {\n            result = new GenericWorker(\"error\");\n            result.error(e);\n        }\n\n        return new StreamHelper(result, outputType, \"\");\n    },\n\n    /**\n     * Prepare the content in the asked type.\n     * @param {String} type the type of the result.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Promise the promise of the result.\n     */\n    async: function (type, onUpdate) {\n        return this.internalStream(type).accumulate(onUpdate);\n    },\n\n    /**\n     * Prepare the content as a nodejs stream.\n     * @param {String} type the type of each chunk.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Stream the stream.\n     */\n    nodeStream: function (type, onUpdate) {\n        return this.internalStream(type || \"nodebuffer\").toNodejsStream(onUpdate);\n    },\n\n    /**\n     * Return a worker for the compressed content.\n     * @private\n     * @param {Object} compression the compression object to use.\n     * @param {Object} compressionOptions the options to use when compressing.\n     * @return Worker the worker.\n     */\n    _compressWorker: function (compression, compressionOptions) {\n        if (\n            this._data instanceof CompressedObject &&\n            this._data.compression.magic === compression.magic\n        ) {\n            return this._data.getCompressedWorker();\n        } else {\n            var result = this._decompressWorker();\n            if(!this._dataBinary) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n        }\n    },\n    /**\n     * Return a worker for the decompressed content.\n     * @private\n     * @return Worker the worker.\n     */\n    _decompressWorker : function () {\n        if (this._data instanceof CompressedObject) {\n            return this._data.getContentWorker();\n        } else if (this._data instanceof GenericWorker) {\n            return this._data;\n        } else {\n            return new DataWorker(this._data);\n        }\n    }\n};\n\nvar removedMethods = [\"asText\", \"asBinary\", \"asNodeBuffer\", \"asUint8Array\", \"asArrayBuffer\"];\nvar removedFn = function () {\n    throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n};\n\nfor(var i = 0; i < removedMethods.length; i++) {\n    ZipObject.prototype[removedMethods[i]] = removedFn;\n}\nmodule.exports = ZipObject;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/lib/zipObject.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/fn/set-immediate.js":
/*!******************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/fn/set-immediate.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ../modules/web.immediate */ \"../node_modules/jszip/node_modules/core-js/library/modules/web.immediate.js\");\nmodule.exports = __webpack_require__(/*! ../modules/_core */ \"../node_modules/jszip/node_modules/core-js/library/modules/_core.js\").setImmediate;\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/fn/set-immediate.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_a-function.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_a-function.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_a-function.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_an-object.js":
/*!********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_an-object.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ./_is-object */ \"../node_modules/jszip/node_modules/core-js/library/modules/_is-object.js\");\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_an-object.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_cof.js":
/*!**************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_cof.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_cof.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_core.js":
/*!***************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_core.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var core = module.exports = {version: '2.3.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_core.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_ctx.js":
/*!**************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_ctx.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// optional / simple context binding\nvar aFunction = __webpack_require__(/*! ./_a-function */ \"../node_modules/jszip/node_modules/core-js/library/modules/_a-function.js\");\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_ctx.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(/*! ./_fails */ \"../node_modules/jszip/node_modules/core-js/library/modules/_fails.js\")(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ./_is-object */ \"../node_modules/jszip/node_modules/core-js/library/modules/_is-object.js\")\n  , document = __webpack_require__(/*! ./_global */ \"../node_modules/jszip/node_modules/core-js/library/modules/_global.js\").document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_export.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_export.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global    = __webpack_require__(/*! ./_global */ \"../node_modules/jszip/node_modules/core-js/library/modules/_global.js\")\n  , core      = __webpack_require__(/*! ./_core */ \"../node_modules/jszip/node_modules/core-js/library/modules/_core.js\")\n  , ctx       = __webpack_require__(/*! ./_ctx */ \"../node_modules/jszip/node_modules/core-js/library/modules/_ctx.js\")\n  , hide      = __webpack_require__(/*! ./_hide */ \"../node_modules/jszip/node_modules/core-js/library/modules/_hide.js\")\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_export.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_fails.js":
/*!****************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_fails.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_fails.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_global.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_global.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_global.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_hide.js":
/*!***************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_hide.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var dP         = __webpack_require__(/*! ./_object-dp */ \"../node_modules/jszip/node_modules/core-js/library/modules/_object-dp.js\")\n  , createDesc = __webpack_require__(/*! ./_property-desc */ \"../node_modules/jszip/node_modules/core-js/library/modules/_property-desc.js\");\nmodule.exports = __webpack_require__(/*! ./_descriptors */ \"../node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js\") ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_hide.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_html.js":
/*!***************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_html.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./_global */ \"../node_modules/jszip/node_modules/core-js/library/modules/_global.js\").document && document.documentElement;\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_html.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = !__webpack_require__(/*! ./_descriptors */ \"../node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js\") && !__webpack_require__(/*! ./_fails */ \"../node_modules/jszip/node_modules/core-js/library/modules/_fails.js\")(function(){\r\n  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ \"../node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js\")('div'), 'a', {get: function(){ return 7; }}).a != 7;\r\n});\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_ie8-dom-define.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_invoke.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_invoke.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return              fn.apply(that, args);\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_invoke.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_is-object.js":
/*!********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_is-object.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_is-object.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_object-dp.js":
/*!********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_object-dp.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var anObject       = __webpack_require__(/*! ./_an-object */ \"../node_modules/jszip/node_modules/core-js/library/modules/_an-object.js\")\n  , IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ \"../node_modules/jszip/node_modules/core-js/library/modules/_ie8-dom-define.js\")\n  , toPrimitive    = __webpack_require__(/*! ./_to-primitive */ \"../node_modules/jszip/node_modules/core-js/library/modules/_to-primitive.js\")\n  , dP             = Object.defineProperty;\n\nexports.f = __webpack_require__(/*! ./_descriptors */ \"../node_modules/jszip/node_modules/core-js/library/modules/_descriptors.js\") ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_object-dp.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_property-desc.js":
/*!************************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_property-desc.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_property-desc.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_task.js":
/*!***************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_task.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ctx                = __webpack_require__(/*! ./_ctx */ \"../node_modules/jszip/node_modules/core-js/library/modules/_ctx.js\")\n  , invoke             = __webpack_require__(/*! ./_invoke */ \"../node_modules/jszip/node_modules/core-js/library/modules/_invoke.js\")\n  , html               = __webpack_require__(/*! ./_html */ \"../node_modules/jszip/node_modules/core-js/library/modules/_html.js\")\n  , cel                = __webpack_require__(/*! ./_dom-create */ \"../node_modules/jszip/node_modules/core-js/library/modules/_dom-create.js\")\n  , global             = __webpack_require__(/*! ./_global */ \"../node_modules/jszip/node_modules/core-js/library/modules/_global.js\")\n  , process            = global.process\n  , setTask            = global.setImmediate\n  , clearTask          = global.clearImmediate\n  , MessageChannel     = global.MessageChannel\n  , counter            = 0\n  , queue              = {}\n  , ONREADYSTATECHANGE = 'onreadystatechange'\n  , defer, channel, port;\nvar run = function(){\n  var id = +this;\n  if(queue.hasOwnProperty(id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function(event){\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask || !clearTask){\n  setTask = function setImmediate(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(__webpack_require__(/*! ./_cof */ \"../node_modules/jszip/node_modules/core-js/library/modules/_cof.js\")(process) == 'process'){\n    defer = function(id){\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if(MessageChannel){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n    defer = function(id){\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in cel('script')){\n    defer = function(id){\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set:   setTask,\n  clear: clearTask\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_task.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/_to-primitive.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/_to-primitive.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(/*! ./_is-object */ \"../node_modules/jszip/node_modules/core-js/library/modules/_is-object.js\");\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/_to-primitive.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/core-js/library/modules/web.immediate.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/core-js/library/modules/web.immediate.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var $export = __webpack_require__(/*! ./_export */ \"../node_modules/jszip/node_modules/core-js/library/modules/_export.js\")\n  , $task   = __webpack_require__(/*! ./_task */ \"../node_modules/jszip/node_modules/core-js/library/modules/_task.js\");\n$export($export.G + $export.B, {\n  setImmediate:   $task.set,\n  clearImmediate: $task.clear\n});\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/core-js/library/modules/web.immediate.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/index.js":
/*!********************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Top level file is just a mixin of submodules & constants\n\n\nvar assign    = __webpack_require__(/*! ./lib/utils/common */ \"../node_modules/jszip/node_modules/pako/lib/utils/common.js\").assign;\n\nvar deflate   = __webpack_require__(/*! ./lib/deflate */ \"../node_modules/jszip/node_modules/pako/lib/deflate.js\");\nvar inflate   = __webpack_require__(/*! ./lib/inflate */ \"../node_modules/jszip/node_modules/pako/lib/inflate.js\");\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"../node_modules/jszip/node_modules/pako/lib/zlib/constants.js\");\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/index.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/deflate.js":
/*!**************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/deflate.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"../node_modules/jszip/node_modules/pako/lib/zlib/deflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"../node_modules/jszip/node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"../node_modules/jszip/node_modules/pako/lib/utils/strings.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"../node_modules/jszip/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"../node_modules/jszip/node_modules/pako/lib/zlib/zstream.js\");\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/deflate.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/inflate.js":
/*!**************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/inflate.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"../node_modules/jszip/node_modules/pako/lib/zlib/inflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"../node_modules/jszip/node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"../node_modules/jszip/node_modules/pako/lib/utils/strings.js\");\nvar c            = __webpack_require__(/*! ./zlib/constants */ \"../node_modules/jszip/node_modules/pako/lib/zlib/constants.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"../node_modules/jszip/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"../node_modules/jszip/node_modules/pako/lib/zlib/zstream.js\");\nvar GZheader     = __webpack_require__(/*! ./zlib/gzheader */ \"../node_modules/jszip/node_modules/pako/lib/zlib/gzheader.js\");\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n  var dict;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      // Convert data if needed\n      if (typeof dictionary === 'string') {\n        dict = strings.string2buf(dictionary);\n      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(dictionary);\n      } else {\n        dict = dictionary;\n      }\n\n      status = zlib_inflate.inflateSetDictionary(this.strm, dict);\n\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/inflate.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/utils/common.js":
/*!*******************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/utils/common.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/utils/common.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/utils/strings.js":
/*!********************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/utils/strings.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// String encode/decode helpers\n\n\n\nvar utils = __webpack_require__(/*! ./common */ \"../node_modules/jszip/node_modules/pako/lib/utils/common.js\");\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/utils/strings.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/zlib/adler32.js":
/*!*******************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/zlib/adler32.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/zlib/adler32.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/zlib/constants.js":
/*!*********************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/zlib/constants.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/zlib/constants.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/zlib/crc32.js":
/*!*****************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/zlib/crc32.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/zlib/crc32.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/zlib/deflate.js":
/*!*******************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/zlib/deflate.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = __webpack_require__(/*! ../utils/common */ \"../node_modules/jszip/node_modules/pako/lib/utils/common.js\");\nvar trees   = __webpack_require__(/*! ./trees */ \"../node_modules/jszip/node_modules/pako/lib/zlib/trees.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"../node_modules/jszip/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32   = __webpack_require__(/*! ./crc32 */ \"../node_modules/jszip/node_modules/pako/lib/zlib/crc32.js\");\nvar msg     = __webpack_require__(/*! ./messages */ \"../node_modules/jszip/node_modules/pako/lib/zlib/messages.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/zlib/deflate.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/zlib/gzheader.js":
/*!********************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/zlib/gzheader.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/zlib/gzheader.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/zlib/inffast.js":
/*!*******************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/zlib/inffast.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/zlib/inffast.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/zlib/inflate.js":
/*!*******************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/zlib/inflate.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = __webpack_require__(/*! ../utils/common */ \"../node_modules/jszip/node_modules/pako/lib/utils/common.js\");\nvar adler32       = __webpack_require__(/*! ./adler32 */ \"../node_modules/jszip/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32         = __webpack_require__(/*! ./crc32 */ \"../node_modules/jszip/node_modules/pako/lib/zlib/crc32.js\");\nvar inflate_fast  = __webpack_require__(/*! ./inffast */ \"../node_modules/jszip/node_modules/pako/lib/zlib/inffast.js\");\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"../node_modules/jszip/node_modules/pako/lib/zlib/inftrees.js\");\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/zlib/inflate.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/zlib/inftrees.js":
/*!********************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/zlib/inftrees.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"../node_modules/jszip/node_modules/pako/lib/utils/common.js\");\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/zlib/inftrees.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/zlib/messages.js":
/*!********************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/zlib/messages.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/zlib/messages.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/zlib/trees.js":
/*!*****************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/zlib/trees.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"../node_modules/jszip/node_modules/pako/lib/utils/common.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/zlib/trees.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/pako/lib/zlib/zstream.js":
/*!*******************************************************************!*\
  !*** ../node_modules/jszip/node_modules/pako/lib/zlib/zstream.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/pako/lib/zlib/zstream.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/process-nextick-args/index.js":
/*!************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/process-nextick-args/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/process-nextick-args/index.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js":
/*!********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = __webpack_require__(/*! process-nextick-args */ \"../node_modules/jszip/node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"../node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"../node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"../node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"../node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = __webpack_require__(/*! process-nextick-args */ \"../node_modules/jszip/node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"../node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = __webpack_require__(/*! events */ \"events\");\n\n/*<replacement>*/\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = __webpack_require__(/*! stream */ \"stream\");\n  } catch (_) {} finally {\n    if (!Stream) Stream = __webpack_require__(/*! events */ \"events\").EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"../node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"../node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ \"util\");\nvar debug = undefined;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar Duplex;\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"../node_modules/jszip/node_modules/string_decoder/index.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nvar Duplex;\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function') this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      var skipAdd;\n      if (state.decoder && !addToFront && !encoding) {\n        chunk = state.decoder.write(chunk);\n        skipAdd = !state.objectMode && chunk.length === 0;\n      }\n\n      if (!addToFront) state.reading = false;\n\n      // Don't add to the buffer if we've decoded to an empty string chunk and\n      // we're not in object mode\n      if (!skipAdd) {\n        // if we want the data now, just emit it.\n        if (state.flowing && state.length === 0 && !state.sync) {\n          stream.emit('data', chunk);\n          stream.read(0);\n        } else {\n          // update the buffer info.\n          state.length += state.objectMode ? 1 : chunk.length;\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n          if (state.needReadable) emitReadable(stream);\n        }\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"../node_modules/jszip/node_modules/string_decoder/index.js\").StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended) return 0;\n\n  if (state.objectMode) return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;\n  }\n\n  if (n <= 0) return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else {\n      return state.length;\n    }\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended) state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      if (state.pipesCount === 1 && state.pipes[0] === dest && src.listenerCount('data') === 1 && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error];\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var _i = 0; _i < len; _i++) {\n      dests[_i].emit('unpipe', this);\n    }return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1) return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && !this._readableState.endEmitted) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function (ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0) return null;\n\n  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode) ret = '';else ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"../node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"../node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er) {\n      done(stream, er);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nfunction done(stream, er) {\n  if (er) return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = __webpack_require__(/*! process-nextick-args */ \"../node_modules/jszip/node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"../node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"../node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"../node_modules/util-deprecate/node.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = __webpack_require__(/*! stream */ \"stream\");\n  } catch (_) {} finally {\n    if (!Stream) Stream = __webpack_require__(/*! events */ \"events\").EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nvar Duplex;\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // create the two objects needed to store the corked requests\n  // they are not a linked list, as no new elements are inserted in there\n  this.corkedRequestsFree = new CorkedRequest(this);\n  this.corkedRequestsFree.next = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\nvar Duplex;\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n        afterWrite(stream, state, finished, cb);\n      }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    state.corkedRequestsFree = holder.next;\n    holder.next = null;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/readable-stream/readable.js":
/*!**********************************************************************!*\
  !*** ../node_modules/jszip/node_modules/readable-stream/readable.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Stream = (function (){\n  try {\n    return __webpack_require__(/*! stream */ \"stream\"); // hack to fix a circular dependency issue when used with browserify\n  } catch(_){}\n}());\nexports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = Stream || exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"../node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js\");\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/readable-stream/readable.js?");

/***/ }),

/***/ "../node_modules/jszip/node_modules/string_decoder/index.js":
/*!******************************************************************!*\
  !*** ../node_modules/jszip/node_modules/string_decoder/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n\n//# sourceURL=webpack:///../node_modules/jszip/node_modules/string_decoder/index.js?");

/***/ }),

/***/ "../node_modules/lie/lib/index.js":
/*!****************************************!*\
  !*** ../node_modules/lie/lib/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar immediate = __webpack_require__(/*! immediate */ \"../node_modules/immediate/lib/index.js\");\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n/* istanbul ignore else */\nif (!process.browser) {\n  // in which we actually take advantage of JS scoping\n  var UNHANDLED = ['UNHANDLED'];\n}\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    this.handled = UNHANDLED;\n  }\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype.catch = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (this.handled === UNHANDLED) {\n      this.handled = null;\n    }\n  }\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (self.handled === UNHANDLED) {\n      immediate(function () {\n        if (self.handled === UNHANDLED) {\n          process.emit('unhandledRejection', error, self);\n        }\n      });\n    }\n  }\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n//# sourceURL=webpack:///../node_modules/lie/lib/index.js?");

/***/ }),

/***/ "../node_modules/lodash/array/last.js":
/*!********************************************!*\
  !*** ../node_modules/lodash/array/last.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array ? array.length : 0;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/array/last.js?");

/***/ }),

/***/ "../node_modules/lodash/collection/every.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/collection/every.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayEvery = __webpack_require__(/*! ../internal/arrayEvery */ \"../node_modules/lodash/internal/arrayEvery.js\"),\n    baseCallback = __webpack_require__(/*! ../internal/baseCallback */ \"../node_modules/lodash/internal/baseCallback.js\"),\n    baseEvery = __webpack_require__(/*! ../internal/baseEvery */ \"../node_modules/lodash/internal/baseEvery.js\"),\n    isArray = __webpack_require__(/*! ../lang/isArray */ \"../node_modules/lodash/lang/isArray.js\"),\n    isIterateeCall = __webpack_require__(/*! ../internal/isIterateeCall */ \"../node_modules/lodash/internal/isIterateeCall.js\");\n\n/**\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\n * The predicate is bound to `thisArg` and invoked with three arguments:\n * (value, index|key, collection).\n *\n * If a property name is provided for `predicate` the created `_.property`\n * style callback returns the property value of the given element.\n *\n * If a value is also provided for `thisArg` the created `_.matchesProperty`\n * style callback returns `true` for elements that have a matching property\n * value, else `false`.\n *\n * If an object is provided for `predicate` the created `_.matches` style\n * callback returns `true` for elements that have the properties of the given\n * object, else `false`.\n *\n * @static\n * @memberOf _\n * @alias all\n * @category Collection\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [predicate=_.identity] The function invoked\n *  per iteration.\n * @param {*} [thisArg] The `this` binding of `predicate`.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n * @example\n *\n * _.every([true, 1, null, 'yes'], Boolean);\n * // => false\n *\n * var users = [\n *   { 'user': 'barney', 'active': false },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // using the `_.matches` callback shorthand\n * _.every(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // using the `_.matchesProperty` callback shorthand\n * _.every(users, 'active', false);\n * // => true\n *\n * // using the `_.property` callback shorthand\n * _.every(users, 'active');\n * // => false\n */\nfunction every(collection, predicate, thisArg) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n    predicate = undefined;\n  }\n  if (typeof predicate != 'function' || thisArg !== undefined) {\n    predicate = baseCallback(predicate, thisArg, 3);\n  }\n  return func(collection, predicate);\n}\n\nmodule.exports = every;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/collection/every.js?");

/***/ }),

/***/ "../node_modules/lodash/function/restParam.js":
/*!****************************************************!*\
  !*** ../node_modules/lodash/function/restParam.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates a function that invokes `func` with the `this` binding of the\n * created function and arguments from `start` and beyond provided as an array.\n *\n * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).\n *\n * @static\n * @memberOf _\n * @category Function\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var say = _.restParam(function(what, names) {\n *   return what + ' ' + _.initial(names).join(', ') +\n *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n * });\n *\n * say('hello', 'fred', 'barney', 'pebbles');\n * // => 'hello fred, barney, & pebbles'\n */\nfunction restParam(func, start) {\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        rest = Array(length);\n\n    while (++index < length) {\n      rest[index] = args[start + index];\n    }\n    switch (start) {\n      case 0: return func.call(this, rest);\n      case 1: return func.call(this, args[0], rest);\n      case 2: return func.call(this, args[0], args[1], rest);\n    }\n    var otherArgs = Array(start + 1);\n    index = -1;\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = rest;\n    return func.apply(this, otherArgs);\n  };\n}\n\nmodule.exports = restParam;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/function/restParam.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/arrayEvery.js":
/*!*****************************************************!*\
  !*** ../node_modules/lodash/internal/arrayEvery.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * A specialized version of `_.every` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n */\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = arrayEvery;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/arrayEvery.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/arraySome.js":
/*!****************************************************!*\
  !*** ../node_modules/lodash/internal/arraySome.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * A specialized version of `_.some` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/arraySome.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/assignWith.js":
/*!*****************************************************!*\
  !*** ../node_modules/lodash/internal/assignWith.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var keys = __webpack_require__(/*! ../object/keys */ \"../node_modules/lodash/object/keys.js\");\n\n/**\n * A specialized version of `_.assign` for customizing assigned values without\n * support for argument juggling, multiple sources, and `this` binding `customizer`\n * functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n */\nfunction assignWith(object, source, customizer) {\n  var index = -1,\n      props = keys(source),\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index],\n        value = object[key],\n        result = customizer(value, source[key], key, object, source);\n\n    if ((result === result ? (result !== value) : (value === value)) ||\n        (value === undefined && !(key in object))) {\n      object[key] = result;\n    }\n  }\n  return object;\n}\n\nmodule.exports = assignWith;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/assignWith.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseAssign.js":
/*!*****************************************************!*\
  !*** ../node_modules/lodash/internal/baseAssign.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseCopy = __webpack_require__(/*! ./baseCopy */ \"../node_modules/lodash/internal/baseCopy.js\"),\n    keys = __webpack_require__(/*! ../object/keys */ \"../node_modules/lodash/object/keys.js\");\n\n/**\n * The base implementation of `_.assign` without support for argument juggling,\n * multiple sources, and `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return source == null\n    ? object\n    : baseCopy(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseAssign.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseCallback.js":
/*!*******************************************************!*\
  !*** ../node_modules/lodash/internal/baseCallback.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseMatches = __webpack_require__(/*! ./baseMatches */ \"../node_modules/lodash/internal/baseMatches.js\"),\n    baseMatchesProperty = __webpack_require__(/*! ./baseMatchesProperty */ \"../node_modules/lodash/internal/baseMatchesProperty.js\"),\n    bindCallback = __webpack_require__(/*! ./bindCallback */ \"../node_modules/lodash/internal/bindCallback.js\"),\n    identity = __webpack_require__(/*! ../utility/identity */ \"../node_modules/lodash/utility/identity.js\"),\n    property = __webpack_require__(/*! ../utility/property */ \"../node_modules/lodash/utility/property.js\");\n\n/**\n * The base implementation of `_.callback` which supports specifying the\n * number of arguments to provide to `func`.\n *\n * @private\n * @param {*} [func=_.identity] The value to convert to a callback.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction baseCallback(func, thisArg, argCount) {\n  var type = typeof func;\n  if (type == 'function') {\n    return thisArg === undefined\n      ? func\n      : bindCallback(func, thisArg, argCount);\n  }\n  if (func == null) {\n    return identity;\n  }\n  if (type == 'object') {\n    return baseMatches(func);\n  }\n  return thisArg === undefined\n    ? property(func)\n    : baseMatchesProperty(func, thisArg);\n}\n\nmodule.exports = baseCallback;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseCallback.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseCopy.js":
/*!***************************************************!*\
  !*** ../node_modules/lodash/internal/baseCopy.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property names to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @returns {Object} Returns `object`.\n */\nfunction baseCopy(source, props, object) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    object[key] = source[key];\n  }\n  return object;\n}\n\nmodule.exports = baseCopy;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseCopy.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseCreate.js":
/*!*****************************************************!*\
  !*** ../node_modules/lodash/internal/baseCreate.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ../lang/isObject */ \"../node_modules/lodash/lang/isObject.js\");\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(prototype) {\n    if (isObject(prototype)) {\n      object.prototype = prototype;\n      var result = new object;\n      object.prototype = undefined;\n    }\n    return result || {};\n  };\n}());\n\nmodule.exports = baseCreate;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseCreate.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseEach.js":
/*!***************************************************!*\
  !*** ../node_modules/lodash/internal/baseEach.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseForOwn = __webpack_require__(/*! ./baseForOwn */ \"../node_modules/lodash/internal/baseForOwn.js\"),\n    createBaseEach = __webpack_require__(/*! ./createBaseEach */ \"../node_modules/lodash/internal/createBaseEach.js\");\n\n/**\n * The base implementation of `_.forEach` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object|string} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseEach.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseEvery.js":
/*!****************************************************!*\
  !*** ../node_modules/lodash/internal/baseEvery.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseEach = __webpack_require__(/*! ./baseEach */ \"../node_modules/lodash/internal/baseEach.js\");\n\n/**\n * The base implementation of `_.every` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`\n */\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\nmodule.exports = baseEvery;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseEvery.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseFor.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/internal/baseFor.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var createBaseFor = __webpack_require__(/*! ./createBaseFor */ \"../node_modules/lodash/internal/createBaseFor.js\");\n\n/**\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\n * each property. Iteratee functions may exit iteration early by explicitly\n * returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseFor.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseForOwn.js":
/*!*****************************************************!*\
  !*** ../node_modules/lodash/internal/baseForOwn.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseFor = __webpack_require__(/*! ./baseFor */ \"../node_modules/lodash/internal/baseFor.js\"),\n    keys = __webpack_require__(/*! ../object/keys */ \"../node_modules/lodash/object/keys.js\");\n\n/**\n * The base implementation of `_.forOwn` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseForOwn.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseGet.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/internal/baseGet.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toObject = __webpack_require__(/*! ./toObject */ \"../node_modules/lodash/internal/toObject.js\");\n\n/**\n * The base implementation of `get` without support for string paths\n * and default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path of the property to get.\n * @param {string} [pathKey] The key representation of path.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path, pathKey) {\n  if (object == null) {\n    return;\n  }\n  if (pathKey !== undefined && pathKey in toObject(object)) {\n    path = [pathKey];\n  }\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[path[index++]];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseGet.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseIsEqual.js":
/*!******************************************************!*\
  !*** ../node_modules/lodash/internal/baseIsEqual.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseIsEqualDeep = __webpack_require__(/*! ./baseIsEqualDeep */ \"../node_modules/lodash/internal/baseIsEqualDeep.js\"),\n    isObject = __webpack_require__(/*! ../lang/isObject */ \"../node_modules/lodash/lang/isObject.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"../node_modules/lodash/internal/isObjectLike.js\");\n\n/**\n * The base implementation of `_.isEqual` without support for `this` binding\n * `customizer` functions.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparing values.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);\n}\n\nmodule.exports = baseIsEqual;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseIsEqual.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseIsEqualDeep.js":
/*!**********************************************************!*\
  !*** ../node_modules/lodash/internal/baseIsEqualDeep.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var equalArrays = __webpack_require__(/*! ./equalArrays */ \"../node_modules/lodash/internal/equalArrays.js\"),\n    equalByTag = __webpack_require__(/*! ./equalByTag */ \"../node_modules/lodash/internal/equalByTag.js\"),\n    equalObjects = __webpack_require__(/*! ./equalObjects */ \"../node_modules/lodash/internal/equalObjects.js\"),\n    isArray = __webpack_require__(/*! ../lang/isArray */ \"../node_modules/lodash/lang/isArray.js\"),\n    isTypedArray = __webpack_require__(/*! ../lang/isTypedArray */ \"../node_modules/lodash/lang/isTypedArray.js\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing objects.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = objToString.call(object);\n    if (objTag == argsTag) {\n      objTag = objectTag;\n    } else if (objTag != objectTag) {\n      objIsArr = isTypedArray(object);\n    }\n  }\n  if (!othIsArr) {\n    othTag = objToString.call(other);\n    if (othTag == argsTag) {\n      othTag = objectTag;\n    } else if (othTag != objectTag) {\n      othIsArr = isTypedArray(other);\n    }\n  }\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !(objIsArr || objIsObj)) {\n    return equalByTag(object, other, objTag);\n  }\n  if (!isLoose) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  // For more information on detecting circular references see https://es5.github.io/#JO.\n  stackA || (stackA = []);\n  stackB || (stackB = []);\n\n  var length = stackA.length;\n  while (length--) {\n    if (stackA[length] == object) {\n      return stackB[length] == other;\n    }\n  }\n  // Add `object` and `other` to the stack of traversed objects.\n  stackA.push(object);\n  stackB.push(other);\n\n  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);\n\n  stackA.pop();\n  stackB.pop();\n\n  return result;\n}\n\nmodule.exports = baseIsEqualDeep;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseIsEqualDeep.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseIsMatch.js":
/*!******************************************************!*\
  !*** ../node_modules/lodash/internal/baseIsMatch.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseIsEqual = __webpack_require__(/*! ./baseIsEqual */ \"../node_modules/lodash/internal/baseIsEqual.js\"),\n    toObject = __webpack_require__(/*! ./toObject */ \"../node_modules/lodash/internal/toObject.js\");\n\n/**\n * The base implementation of `_.isMatch` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Array} matchData The propery names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparing objects.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = toObject(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var result = customizer ? customizer(objValue, srcValue, key) : undefined;\n      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseIsMatch.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseMatches.js":
/*!******************************************************!*\
  !*** ../node_modules/lodash/internal/baseMatches.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseIsMatch = __webpack_require__(/*! ./baseIsMatch */ \"../node_modules/lodash/internal/baseIsMatch.js\"),\n    getMatchData = __webpack_require__(/*! ./getMatchData */ \"../node_modules/lodash/internal/getMatchData.js\"),\n    toObject = __webpack_require__(/*! ./toObject */ \"../node_modules/lodash/internal/toObject.js\");\n\n/**\n * The base implementation of `_.matches` which does not clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    var key = matchData[0][0],\n        value = matchData[0][1];\n\n    return function(object) {\n      if (object == null) {\n        return false;\n      }\n      return object[key] === value && (value !== undefined || (key in toObject(object)));\n    };\n  }\n  return function(object) {\n    return baseIsMatch(object, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseMatches.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseMatchesProperty.js":
/*!**************************************************************!*\
  !*** ../node_modules/lodash/internal/baseMatchesProperty.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseGet = __webpack_require__(/*! ./baseGet */ \"../node_modules/lodash/internal/baseGet.js\"),\n    baseIsEqual = __webpack_require__(/*! ./baseIsEqual */ \"../node_modules/lodash/internal/baseIsEqual.js\"),\n    baseSlice = __webpack_require__(/*! ./baseSlice */ \"../node_modules/lodash/internal/baseSlice.js\"),\n    isArray = __webpack_require__(/*! ../lang/isArray */ \"../node_modules/lodash/lang/isArray.js\"),\n    isKey = __webpack_require__(/*! ./isKey */ \"../node_modules/lodash/internal/isKey.js\"),\n    isStrictComparable = __webpack_require__(/*! ./isStrictComparable */ \"../node_modules/lodash/internal/isStrictComparable.js\"),\n    last = __webpack_require__(/*! ../array/last */ \"../node_modules/lodash/array/last.js\"),\n    toObject = __webpack_require__(/*! ./toObject */ \"../node_modules/lodash/internal/toObject.js\"),\n    toPath = __webpack_require__(/*! ./toPath */ \"../node_modules/lodash/internal/toPath.js\");\n\n/**\n * The base implementation of `_.matchesProperty` which does not clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to compare.\n * @returns {Function} Returns the new function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  var isArr = isArray(path),\n      isCommon = isKey(path) && isStrictComparable(srcValue),\n      pathKey = (path + '');\n\n  path = toPath(path);\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    var key = pathKey;\n    object = toObject(object);\n    if ((isArr || !isCommon) && !(key in object)) {\n      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n      if (object == null) {\n        return false;\n      }\n      key = last(path);\n      object = toObject(object);\n    }\n    return object[key] === srcValue\n      ? (srcValue !== undefined || (key in object))\n      : baseIsEqual(srcValue, object[key], undefined, true);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseMatchesProperty.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseProperty.js":
/*!*******************************************************!*\
  !*** ../node_modules/lodash/internal/baseProperty.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseProperty.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/basePropertyDeep.js":
/*!***********************************************************!*\
  !*** ../node_modules/lodash/internal/basePropertyDeep.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseGet = __webpack_require__(/*! ./baseGet */ \"../node_modules/lodash/internal/baseGet.js\"),\n    toPath = __webpack_require__(/*! ./toPath */ \"../node_modules/lodash/internal/toPath.js\");\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction basePropertyDeep(path) {\n  var pathKey = (path + '');\n  path = toPath(path);\n  return function(object) {\n    return baseGet(object, path, pathKey);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/basePropertyDeep.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseSlice.js":
/*!****************************************************!*\
  !*** ../node_modules/lodash/internal/baseSlice.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  start = start == null ? 0 : (+start || 0);\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = (end === undefined || end > length) ? length : (+end || 0);\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseSlice.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/baseToString.js":
/*!*******************************************************!*\
  !*** ../node_modules/lodash/internal/baseToString.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Converts `value` to a string if it's not one. An empty string is returned\n * for `null` or `undefined` values.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  return value == null ? '' : (value + '');\n}\n\nmodule.exports = baseToString;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/baseToString.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/bindCallback.js":
/*!*******************************************************!*\
  !*** ../node_modules/lodash/internal/bindCallback.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var identity = __webpack_require__(/*! ../utility/identity */ \"../node_modules/lodash/utility/identity.js\");\n\n/**\n * A specialized version of `baseCallback` which only supports `this` binding\n * and specifying the number of arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  if (thisArg === undefined) {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\nmodule.exports = bindCallback;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/bindCallback.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/createAssigner.js":
/*!*********************************************************!*\
  !*** ../node_modules/lodash/internal/createAssigner.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var bindCallback = __webpack_require__(/*! ./bindCallback */ \"../node_modules/lodash/internal/bindCallback.js\"),\n    isIterateeCall = __webpack_require__(/*! ./isIterateeCall */ \"../node_modules/lodash/internal/isIterateeCall.js\"),\n    restParam = __webpack_require__(/*! ../function/restParam */ \"../node_modules/lodash/function/restParam.js\");\n\n/**\n * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return restParam(function(object, sources) {\n    var index = -1,\n        length = object == null ? 0 : sources.length,\n        customizer = length > 2 ? sources[length - 2] : undefined,\n        guard = length > 2 ? sources[2] : undefined,\n        thisArg = length > 1 ? sources[length - 1] : undefined;\n\n    if (typeof customizer == 'function') {\n      customizer = bindCallback(customizer, thisArg, 5);\n      length -= 2;\n    } else {\n      customizer = typeof thisArg == 'function' ? thisArg : undefined;\n      length -= (customizer ? 1 : 0);\n    }\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/createAssigner.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/createBaseEach.js":
/*!*********************************************************!*\
  !*** ../node_modules/lodash/internal/createBaseEach.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var getLength = __webpack_require__(/*! ./getLength */ \"../node_modules/lodash/internal/getLength.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"../node_modules/lodash/internal/isLength.js\"),\n    toObject = __webpack_require__(/*! ./toObject */ \"../node_modules/lodash/internal/toObject.js\");\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    var length = collection ? getLength(collection) : 0;\n    if (!isLength(length)) {\n      return eachFunc(collection, iteratee);\n    }\n    var index = fromRight ? length : -1,\n        iterable = toObject(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/createBaseEach.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/createBaseFor.js":
/*!********************************************************!*\
  !*** ../node_modules/lodash/internal/createBaseFor.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toObject = __webpack_require__(/*! ./toObject */ \"../node_modules/lodash/internal/toObject.js\");\n\n/**\n * Creates a base function for `_.forIn` or `_.forInRight`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var iterable = toObject(object),\n        props = keysFunc(object),\n        length = props.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var key = props[index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/createBaseFor.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/equalArrays.js":
/*!******************************************************!*\
  !*** ../node_modules/lodash/internal/equalArrays.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arraySome = __webpack_require__(/*! ./arraySome */ \"../node_modules/lodash/internal/arraySome.js\");\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing arrays.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var index = -1,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {\n    return false;\n  }\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index],\n        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;\n\n    if (result !== undefined) {\n      if (result) {\n        continue;\n      }\n      return false;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (isLoose) {\n      if (!arraySome(other, function(othValue) {\n            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n          })) {\n        return false;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = equalArrays;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/equalArrays.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/equalByTag.js":
/*!*****************************************************!*\
  !*** ../node_modules/lodash/internal/equalByTag.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    stringTag = '[object String]';\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag) {\n  switch (tag) {\n    case boolTag:\n    case dateTag:\n      // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n      return +object == +other;\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case numberTag:\n      // Treat `NaN` vs. `NaN` as equal.\n      return (object != +object)\n        ? other != +other\n        : object == +other;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings primitives and string\n      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n      return object == (other + '');\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/equalByTag.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/equalObjects.js":
/*!*******************************************************!*\
  !*** ../node_modules/lodash/internal/equalObjects.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var keys = __webpack_require__(/*! ../object/keys */ \"../node_modules/lodash/object/keys.js\");\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing values.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isLoose) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  var skipCtor = isLoose;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key],\n        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;\n\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {\n      return false;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (!skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = equalObjects;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/equalObjects.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/getLength.js":
/*!****************************************************!*\
  !*** ../node_modules/lodash/internal/getLength.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseProperty = __webpack_require__(/*! ./baseProperty */ \"../node_modules/lodash/internal/baseProperty.js\");\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\nmodule.exports = getLength;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/getLength.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/getMatchData.js":
/*!*******************************************************!*\
  !*** ../node_modules/lodash/internal/getMatchData.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isStrictComparable = __webpack_require__(/*! ./isStrictComparable */ \"../node_modules/lodash/internal/isStrictComparable.js\"),\n    pairs = __webpack_require__(/*! ../object/pairs */ \"../node_modules/lodash/object/pairs.js\");\n\n/**\n * Gets the propery names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = pairs(object),\n      length = result.length;\n\n  while (length--) {\n    result[length][2] = isStrictComparable(result[length][1]);\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/getMatchData.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/getNative.js":
/*!****************************************************!*\
  !*** ../node_modules/lodash/internal/getNative.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isNative = __webpack_require__(/*! ../lang/isNative */ \"../node_modules/lodash/lang/isNative.js\");\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/getNative.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/isArrayLike.js":
/*!******************************************************!*\
  !*** ../node_modules/lodash/internal/isArrayLike.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var getLength = __webpack_require__(/*! ./getLength */ \"../node_modules/lodash/internal/getLength.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"../node_modules/lodash/internal/isLength.js\");\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\nmodule.exports = isArrayLike;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/isArrayLike.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/isIndex.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/internal/isIndex.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\nmodule.exports = isIndex;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/isIndex.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/isIterateeCall.js":
/*!*********************************************************!*\
  !*** ../node_modules/lodash/internal/isIterateeCall.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"../node_modules/lodash/internal/isArrayLike.js\"),\n    isIndex = __webpack_require__(/*! ./isIndex */ \"../node_modules/lodash/internal/isIndex.js\"),\n    isObject = __webpack_require__(/*! ../lang/isObject */ \"../node_modules/lodash/lang/isObject.js\");\n\n/**\n * Checks if the provided arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n      ? (isArrayLike(object) && isIndex(index, object.length))\n      : (type == 'string' && index in object)) {\n    var other = object[index];\n    return value === value ? (value === other) : (other !== other);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/isIterateeCall.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/isKey.js":
/*!************************************************!*\
  !*** ../node_modules/lodash/internal/isKey.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isArray = __webpack_require__(/*! ../lang/isArray */ \"../node_modules/lodash/lang/isArray.js\"),\n    toObject = __webpack_require__(/*! ./toObject */ \"../node_modules/lodash/internal/toObject.js\");\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  var type = typeof value;\n  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {\n    return true;\n  }\n  if (isArray(value)) {\n    return false;\n  }\n  var result = !reIsDeepProp.test(value);\n  return result || (object != null && value in toObject(object));\n}\n\nmodule.exports = isKey;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/isKey.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/isLength.js":
/*!***************************************************!*\
  !*** ../node_modules/lodash/internal/isLength.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/isLength.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/isObjectLike.js":
/*!*******************************************************!*\
  !*** ../node_modules/lodash/internal/isObjectLike.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/isObjectLike.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/isStrictComparable.js":
/*!*************************************************************!*\
  !*** ../node_modules/lodash/internal/isStrictComparable.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ../lang/isObject */ \"../node_modules/lodash/lang/isObject.js\");\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/isStrictComparable.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/shimKeys.js":
/*!***************************************************!*\
  !*** ../node_modules/lodash/internal/shimKeys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isArguments = __webpack_require__(/*! ../lang/isArguments */ \"../node_modules/lodash/lang/isArguments.js\"),\n    isArray = __webpack_require__(/*! ../lang/isArray */ \"../node_modules/lodash/lang/isArray.js\"),\n    isIndex = __webpack_require__(/*! ./isIndex */ \"../node_modules/lodash/internal/isIndex.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"../node_modules/lodash/internal/isLength.js\"),\n    keysIn = __webpack_require__(/*! ../object/keysIn */ \"../node_modules/lodash/object/keysIn.js\");\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = !!length && isLength(length) &&\n    (isArray(object) || isArguments(object));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = shimKeys;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/shimKeys.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/toObject.js":
/*!***************************************************!*\
  !*** ../node_modules/lodash/internal/toObject.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ../lang/isObject */ \"../node_modules/lodash/lang/isObject.js\");\n\n/**\n * Converts `value` to an object if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\nmodule.exports = toObject;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/toObject.js?");

/***/ }),

/***/ "../node_modules/lodash/internal/toPath.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/internal/toPath.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseToString = __webpack_require__(/*! ./baseToString */ \"../node_modules/lodash/internal/baseToString.js\"),\n    isArray = __webpack_require__(/*! ../lang/isArray */ \"../node_modules/lodash/lang/isArray.js\");\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `value` to property path array if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Array} Returns the property path array.\n */\nfunction toPath(value) {\n  if (isArray(value)) {\n    return value;\n  }\n  var result = [];\n  baseToString(value).replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n}\n\nmodule.exports = toPath;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/internal/toPath.js?");

/***/ }),

/***/ "../node_modules/lodash/lang/isArguments.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/lang/isArguments.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isArrayLike = __webpack_require__(/*! ../internal/isArrayLike */ \"../node_modules/lodash/internal/isArrayLike.js\"),\n    isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ \"../node_modules/lodash/internal/isObjectLike.js\");\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Native method references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is classified as an `arguments` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  return isObjectLike(value) && isArrayLike(value) &&\n    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n}\n\nmodule.exports = isArguments;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/lang/isArguments.js?");

/***/ }),

/***/ "../node_modules/lodash/lang/isArray.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/lang/isArray.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var getNative = __webpack_require__(/*! ../internal/getNative */ \"../node_modules/lodash/internal/getNative.js\"),\n    isLength = __webpack_require__(/*! ../internal/isLength */ \"../node_modules/lodash/internal/isLength.js\"),\n    isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ \"../node_modules/lodash/internal/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = getNative(Array, 'isArray');\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\nmodule.exports = isArray;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/lang/isArray.js?");

/***/ }),

/***/ "../node_modules/lodash/lang/isEmpty.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/lang/isEmpty.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isArguments = __webpack_require__(/*! ./isArguments */ \"../node_modules/lodash/lang/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"../node_modules/lodash/lang/isArray.js\"),\n    isArrayLike = __webpack_require__(/*! ../internal/isArrayLike */ \"../node_modules/lodash/internal/isArrayLike.js\"),\n    isFunction = __webpack_require__(/*! ./isFunction */ \"../node_modules/lodash/lang/isFunction.js\"),\n    isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ \"../node_modules/lodash/internal/isObjectLike.js\"),\n    isString = __webpack_require__(/*! ./isString */ \"../node_modules/lodash/lang/isString.js\"),\n    keys = __webpack_require__(/*! ../object/keys */ \"../node_modules/lodash/object/keys.js\");\n\n/**\n * Checks if `value` is empty. A value is considered empty unless it's an\n * `arguments` object, array, string, or jQuery-like collection with a length\n * greater than `0` or an object with own enumerable properties.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {Array|Object|string} value The value to inspect.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||\n      (isObjectLike(value) && isFunction(value.splice)))) {\n    return !value.length;\n  }\n  return !keys(value).length;\n}\n\nmodule.exports = isEmpty;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/lang/isEmpty.js?");

/***/ }),

/***/ "../node_modules/lodash/lang/isFunction.js":
/*!*************************************************!*\
  !*** ../node_modules/lodash/lang/isFunction.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ./isObject */ \"../node_modules/lodash/lang/isObject.js\");\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 which returns 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\nmodule.exports = isFunction;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/lang/isFunction.js?");

/***/ }),

/***/ "../node_modules/lodash/lang/isNative.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/lang/isNative.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isFunction = __webpack_require__(/*! ./isFunction */ \"../node_modules/lodash/lang/isFunction.js\"),\n    isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ \"../node_modules/lodash/internal/isObjectLike.js\");\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isNative;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/lang/isNative.js?");

/***/ }),

/***/ "../node_modules/lodash/lang/isObject.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/lang/isObject.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/lang/isObject.js?");

/***/ }),

/***/ "../node_modules/lodash/lang/isString.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/lang/isString.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ \"../node_modules/lodash/internal/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\n}\n\nmodule.exports = isString;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/lang/isString.js?");

/***/ }),

/***/ "../node_modules/lodash/lang/isTypedArray.js":
/*!***************************************************!*\
  !*** ../node_modules/lodash/lang/isTypedArray.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isLength = __webpack_require__(/*! ../internal/isLength */ \"../node_modules/lodash/internal/isLength.js\"),\n    isObjectLike = __webpack_require__(/*! ../internal/isObjectLike */ \"../node_modules/lodash/internal/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dateTag] = typedArrayTags[errorTag] =\ntypedArrayTags[funcTag] = typedArrayTags[mapTag] =\ntypedArrayTags[numberTag] = typedArrayTags[objectTag] =\ntypedArrayTags[regexpTag] = typedArrayTags[setTag] =\ntypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nfunction isTypedArray(value) {\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n}\n\nmodule.exports = isTypedArray;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/lang/isTypedArray.js?");

/***/ }),

/***/ "../node_modules/lodash/object/assign.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/object/assign.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var assignWith = __webpack_require__(/*! ../internal/assignWith */ \"../node_modules/lodash/internal/assignWith.js\"),\n    baseAssign = __webpack_require__(/*! ../internal/baseAssign */ \"../node_modules/lodash/internal/baseAssign.js\"),\n    createAssigner = __webpack_require__(/*! ../internal/createAssigner */ \"../node_modules/lodash/internal/createAssigner.js\");\n\n/**\n * Assigns own enumerable properties of source object(s) to the destination\n * object. Subsequent sources overwrite property assignments of previous sources.\n * If `customizer` is provided it's invoked to produce the assigned values.\n * The `customizer` is bound to `thisArg` and invoked with five arguments:\n * (objectValue, sourceValue, key, object, source).\n *\n * **Note:** This method mutates `object` and is based on\n * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).\n *\n * @static\n * @memberOf _\n * @alias extend\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {*} [thisArg] The `this` binding of `customizer`.\n * @returns {Object} Returns `object`.\n * @example\n *\n * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n * // => { 'user': 'fred', 'age': 40 }\n *\n * // using a customizer callback\n * var defaults = _.partialRight(_.assign, function(value, other) {\n *   return _.isUndefined(value) ? other : value;\n * });\n *\n * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n * // => { 'user': 'barney', 'age': 36 }\n */\nvar assign = createAssigner(function(object, source, customizer) {\n  return customizer\n    ? assignWith(object, source, customizer)\n    : baseAssign(object, source);\n});\n\nmodule.exports = assign;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/object/assign.js?");

/***/ }),

/***/ "../node_modules/lodash/object/create.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/object/create.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseAssign = __webpack_require__(/*! ../internal/baseAssign */ \"../node_modules/lodash/internal/baseAssign.js\"),\n    baseCreate = __webpack_require__(/*! ../internal/baseCreate */ \"../node_modules/lodash/internal/baseCreate.js\"),\n    isIterateeCall = __webpack_require__(/*! ../internal/isIterateeCall */ \"../node_modules/lodash/internal/isIterateeCall.js\");\n\n/**\n * Creates an object that inherits from the given `prototype` object. If a\n * `properties` object is provided its own enumerable properties are assigned\n * to the created object.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} prototype The object to inherit from.\n * @param {Object} [properties] The properties to assign to the object.\n * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n * @returns {Object} Returns the new object.\n * @example\n *\n * function Shape() {\n *   this.x = 0;\n *   this.y = 0;\n * }\n *\n * function Circle() {\n *   Shape.call(this);\n * }\n *\n * Circle.prototype = _.create(Shape.prototype, {\n *   'constructor': Circle\n * });\n *\n * var circle = new Circle;\n * circle instanceof Circle;\n * // => true\n *\n * circle instanceof Shape;\n * // => true\n */\nfunction create(prototype, properties, guard) {\n  var result = baseCreate(prototype);\n  if (guard && isIterateeCall(prototype, properties, guard)) {\n    properties = undefined;\n  }\n  return properties ? baseAssign(result, properties) : result;\n}\n\nmodule.exports = create;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/object/create.js?");

/***/ }),

/***/ "../node_modules/lodash/object/keys.js":
/*!*********************************************!*\
  !*** ../node_modules/lodash/object/keys.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var getNative = __webpack_require__(/*! ../internal/getNative */ \"../node_modules/lodash/internal/getNative.js\"),\n    isArrayLike = __webpack_require__(/*! ../internal/isArrayLike */ \"../node_modules/lodash/internal/isArrayLike.js\"),\n    isObject = __webpack_require__(/*! ../lang/isObject */ \"../node_modules/lodash/lang/isObject.js\"),\n    shimKeys = __webpack_require__(/*! ../internal/shimKeys */ \"../node_modules/lodash/internal/shimKeys.js\");\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = getNative(Object, 'keys');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  var Ctor = object == null ? undefined : object.constructor;\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isArrayLike(object))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\nmodule.exports = keys;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/object/keys.js?");

/***/ }),

/***/ "../node_modules/lodash/object/keysIn.js":
/*!***********************************************!*\
  !*** ../node_modules/lodash/object/keysIn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isArguments = __webpack_require__(/*! ../lang/isArguments */ \"../node_modules/lodash/lang/isArguments.js\"),\n    isArray = __webpack_require__(/*! ../lang/isArray */ \"../node_modules/lodash/lang/isArray.js\"),\n    isIndex = __webpack_require__(/*! ../internal/isIndex */ \"../node_modules/lodash/internal/isIndex.js\"),\n    isLength = __webpack_require__(/*! ../internal/isLength */ \"../node_modules/lodash/internal/isLength.js\"),\n    isObject = __webpack_require__(/*! ../lang/isObject */ \"../node_modules/lodash/lang/isObject.js\");\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || isArguments(object)) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keysIn;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/object/keysIn.js?");

/***/ }),

/***/ "../node_modules/lodash/object/pairs.js":
/*!**********************************************!*\
  !*** ../node_modules/lodash/object/pairs.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var keys = __webpack_require__(/*! ./keys */ \"../node_modules/lodash/object/keys.js\"),\n    toObject = __webpack_require__(/*! ../internal/toObject */ \"../node_modules/lodash/internal/toObject.js\");\n\n/**\n * Creates a two dimensional array of the key-value pairs for `object`,\n * e.g. `[[key1, value1], [key2, value2]]`.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the new array of key-value pairs.\n * @example\n *\n * _.pairs({ 'barney': 36, 'fred': 40 });\n * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)\n */\nfunction pairs(object) {\n  object = toObject(object);\n\n  var index = -1,\n      props = keys(object),\n      length = props.length,\n      result = Array(length);\n\n  while (++index < length) {\n    var key = props[index];\n    result[index] = [key, object[key]];\n  }\n  return result;\n}\n\nmodule.exports = pairs;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/object/pairs.js?");

/***/ }),

/***/ "../node_modules/lodash/utility/identity.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/utility/identity.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/utility/identity.js?");

/***/ }),

/***/ "../node_modules/lodash/utility/property.js":
/*!**************************************************!*\
  !*** ../node_modules/lodash/utility/property.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseProperty = __webpack_require__(/*! ../internal/baseProperty */ \"../node_modules/lodash/internal/baseProperty.js\"),\n    basePropertyDeep = __webpack_require__(/*! ../internal/basePropertyDeep */ \"../node_modules/lodash/internal/basePropertyDeep.js\"),\n    isKey = __webpack_require__(/*! ../internal/isKey */ \"../node_modules/lodash/internal/isKey.js\");\n\n/**\n * Creates a function that returns the property value at `path` on a\n * given object.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': { 'c': 2 } } },\n *   { 'a': { 'b': { 'c': 1 } } }\n * ];\n *\n * _.map(objects, _.property('a.b.c'));\n * // => [2, 1]\n *\n * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n\n\n//# sourceURL=webpack:///../node_modules/lodash/utility/property.js?");

/***/ }),

/***/ "../node_modules/minimatch/minimatch.js":
/*!**********************************************!*\
  !*** ../node_modules/minimatch/minimatch.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = __webpack_require__(/*! path */ \"path\")\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = __webpack_require__(/*! brace-expansion */ \"../node_modules/brace-expansion/index.js\")\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\n\n//# sourceURL=webpack:///../node_modules/minimatch/minimatch.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/bitmapper.js":
/*!****************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/bitmapper.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar interlaceUtils = __webpack_require__(/*! ./interlace */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/interlace.js\");\n\nvar pixelBppMap = {\n  1: { // L\n    0: 0,\n    1: 0,\n    2: 0,\n    3: 0xff\n  },\n  2: { // LA\n    0: 0,\n    1: 0,\n    2: 0,\n    3: 1\n  },\n  3: { // RGB\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 0xff\n  },\n  4: { // RGBA\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3\n  }\n};\n\nfunction bitRetriever(data, depth) {\n\n  var leftOver = [];\n  var i = 0;\n\n  function split() {\n    if (i === data.length) {\n      throw new Error('Ran out of data');\n    }\n    var byte = data[i];\n    i++;\n    var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;\n    switch (depth) {\n      default:\n        throw new Error('unrecognised depth');\n      case 16:\n        byte2 = data[i];\n        i++;\n        leftOver.push(((byte << 8) + byte2));\n        break;\n      case 4:\n        byte2 = byte & 0x0f;\n        byte1 = byte >> 4;\n        leftOver.push(byte1, byte2);\n        break;\n      case 2:\n        byte4 = byte & 3;\n        byte3 = byte >> 2 & 3;\n        byte2 = byte >> 4 & 3;\n        byte1 = byte >> 6 & 3;\n        leftOver.push(byte1, byte2, byte3, byte4);\n        break;\n      case 1:\n        byte8 = byte & 1;\n        byte7 = byte >> 1 & 1;\n        byte6 = byte >> 2 & 1;\n        byte5 = byte >> 3 & 1;\n        byte4 = byte >> 4 & 1;\n        byte3 = byte >> 5 & 1;\n        byte2 = byte >> 6 & 1;\n        byte1 = byte >> 7 & 1;\n        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);\n        break;\n    }\n  }\n\n  return {\n    get: function(count) {\n      while (leftOver.length < count) {\n        split();\n      }\n      var returner = leftOver.slice(0, count);\n      leftOver = leftOver.slice(count);\n      return returner;\n    },\n    resetAfterLine: function() {\n      leftOver.length = 0;\n    },\n    end: function() {\n      if (i !== data.length) {\n        throw new Error('extra data found');\n      }\n    }\n  };\n}\n\nfunction mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) { // eslint-disable-line max-params\n  var imageWidth = image.width;\n  var imageHeight = image.height;\n  var imagePass = image.index;\n  for (var y = 0; y < imageHeight; y++) {\n    for (var x = 0; x < imageWidth; x++) {\n      var pxPos = getPxPos(x, y, imagePass);\n\n      for (var i = 0; i < 4; i++) {\n        var idx = pixelBppMap[bpp][i];\n        if (i === data.length) {\n          throw new Error('Ran out of data');\n        }\n        pxData[pxPos + i] = idx !== 0xff ? data[idx + rawPos] : 0xff;\n      }\n      rawPos += bpp; //eslint-disable-line no-param-reassign\n    }\n  }\n  return rawPos;\n}\n\nfunction mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) { // eslint-disable-line max-params\n  var imageWidth = image.width;\n  var imageHeight = image.height;\n  var imagePass = image.index;\n  for (var y = 0; y < imageHeight; y++) {\n    for (var x = 0; x < imageWidth; x++) {\n      var pixelData = bits.get(bpp);\n      var pxPos = getPxPos(x, y, imagePass);\n\n      for (var i = 0; i < 4; i++) {\n        var idx = pixelBppMap[bpp][i];\n        pxData[pxPos + i] = idx !== 0xff ? pixelData[idx] : maxBit;\n      }\n    }\n    bits.resetAfterLine();\n  }\n}\n\nexports.dataToBitMap = function(data, bitmapInfo) {\n\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var depth = bitmapInfo.depth;\n  var bpp = bitmapInfo.bpp;\n  var interlace = bitmapInfo.interlace;\n\n  if (depth !== 8) {\n    var bits = bitRetriever(data, depth);\n  }\n  var pxData;\n  if (depth <= 8) {\n    pxData = new Buffer(width * height * 4);\n  }\n  else {\n    pxData = new Uint16Array(width * height * 4);\n  }\n  var maxBit = Math.pow(2, depth) - 1;\n  var rawPos = 0;\n  var images;\n  var getPxPos;\n\n  if (interlace) {\n    images = interlaceUtils.getImagePasses(width, height);\n    getPxPos = interlaceUtils.getInterlaceIterator(width, height);\n  }\n  else {\n    var nonInterlacedPxPos = 0;\n    getPxPos = function() {\n      var returner = nonInterlacedPxPos;\n      nonInterlacedPxPos += 4;\n      return returner;\n    };\n    images = [{ width: width, height: height }];\n  }\n\n  for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {\n    if (depth === 8) {\n      rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);\n    }\n    else {\n      mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);\n    }\n  }\n  if (depth === 8) {\n    if (rawPos !== data.length) {\n      throw new Error('extra data found');\n    }\n  }\n  else {\n    bits.end();\n  }\n\n  return pxData;\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/bitmapper.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/bitpacker.js":
/*!****************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/bitpacker.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar constants = __webpack_require__(/*! ./constants */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/constants.js\");\n\nmodule.exports = function(data, width, height, options) {\n  var outHasAlpha = options.colorType === constants.COLORTYPE_COLOR_ALPHA;\n  if (options.inputHasAlpha && outHasAlpha) {\n    return data;\n  }\n  if (!options.inputHasAlpha && !outHasAlpha) {\n    return data;\n  }\n\n  var outBpp = outHasAlpha ? 4 : 3;\n  var outData = new Buffer(width * height * outBpp);\n  var inBpp = options.inputHasAlpha ? 4 : 3;\n  var inIndex = 0;\n  var outIndex = 0;\n\n  var bgColor = options.bgColor || {};\n  if (bgColor.red === undefined) {\n    bgColor.red = 255;\n  }\n  if (bgColor.green === undefined) {\n    bgColor.green = 255;\n  }\n  if (bgColor.blue === undefined) {\n    bgColor.blue = 255;\n  }\n\n  for (var y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++) {\n      var red = data[inIndex];\n      var green = data[inIndex + 1];\n      var blue = data[inIndex + 2];\n\n      var alpha;\n      if (options.inputHasAlpha) {\n        alpha = data[inIndex + 3];\n        if (!outHasAlpha) {\n          alpha /= 255;\n          red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), 255);\n          green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), 255);\n          blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), 255);\n        }\n      }\n      else {\n        alpha = 255;\n      }\n\n      outData[outIndex] = red;\n      outData[outIndex + 1] = green;\n      outData[outIndex + 2] = blue;\n      if (outHasAlpha) {\n        outData[outIndex + 3] = alpha;\n      }\n\n      inIndex += inBpp;\n      outIndex += outBpp;\n    }\n  }\n\n  return outData;\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/bitpacker.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/chunkstream.js":
/*!******************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/chunkstream.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\n\n\nvar ChunkStream = module.exports = function() {\n  Stream.call(this);\n\n  this._buffers = [];\n  this._buffered = 0;\n\n  this._reads = [];\n  this._paused = false;\n\n  this._encoding = 'utf8';\n  this.writable = true;\n};\nutil.inherits(ChunkStream, Stream);\n\n\nChunkStream.prototype.read = function(length, callback) {\n\n  this._reads.push({\n    length: Math.abs(length),  // if length < 0 then at most this length\n    allowLess: length < 0,\n    func: callback\n  });\n\n  process.nextTick(function() {\n    this._process();\n\n    // its paused and there is not enought data then ask for more\n    if (this._paused && this._reads.length > 0) {\n      this._paused = false;\n\n      this.emit('drain');\n    }\n  }.bind(this));\n};\n\nChunkStream.prototype.write = function(data, encoding) {\n\n  if (!this.writable) {\n    this.emit('error', new Error('Stream not writable'));\n    return false;\n  }\n\n  var dataBuffer;\n  if (Buffer.isBuffer(data)) {\n    dataBuffer = data;\n  }\n  else {\n    dataBuffer = new Buffer(data, encoding || this._encoding);\n  }\n\n  this._buffers.push(dataBuffer);\n  this._buffered += dataBuffer.length;\n\n  this._process();\n\n  // ok if there are no more read requests\n  if (this._reads && this._reads.length === 0) {\n    this._paused = true;\n  }\n\n  return this.writable && !this._paused;\n};\n\nChunkStream.prototype.end = function(data, encoding) {\n\n  if (data) {\n    this.write(data, encoding);\n  }\n\n  this.writable = false;\n\n  // already destroyed\n  if (!this._buffers) {\n    return;\n  }\n\n  // enqueue or handle end\n  if (this._buffers.length === 0) {\n    this._end();\n  }\n  else {\n    this._buffers.push(null);\n    this._process();\n  }\n};\n\nChunkStream.prototype.destroySoon = ChunkStream.prototype.end;\n\nChunkStream.prototype._end = function() {\n\n  if (this._reads.length > 0) {\n    this.emit('error',\n      new Error('There are some read requests waitng on finished stream')\n    );\n  }\n\n  this.destroy();\n};\n\nChunkStream.prototype.destroy = function() {\n\n  if (!this._buffers) {\n    return;\n  }\n\n  this.writable = false;\n  this._reads = null;\n  this._buffers = null;\n\n  this.emit('close');\n};\n\nChunkStream.prototype._processReadAllowingLess = function(read) {\n  // ok there is any data so that we can satisfy this request\n  this._reads.shift(); // == read\n\n  // first we need to peek into first buffer\n  var smallerBuf = this._buffers[0];\n\n  // ok there is more data than we need\n  if (smallerBuf.length > read.length) {\n\n    this._buffered -= read.length;\n    this._buffers[0] = smallerBuf.slice(read.length);\n\n    read.func.call(this, smallerBuf.slice(0, read.length));\n\n  }\n  else {\n    // ok this is less than maximum length so use it all\n    this._buffered -= smallerBuf.length;\n    this._buffers.shift(); // == smallerBuf\n\n    read.func.call(this, smallerBuf);\n  }\n};\n\nChunkStream.prototype._processRead = function(read) {\n  this._reads.shift(); // == read\n\n  var pos = 0;\n  var count = 0;\n  var data = new Buffer(read.length);\n\n  // create buffer for all data\n  while (pos < read.length) {\n\n    var buf = this._buffers[count++];\n    var len = Math.min(buf.length, read.length - pos);\n\n    buf.copy(data, pos, 0, len);\n    pos += len;\n\n    // last buffer wasn't used all so just slice it and leave\n    if (len !== buf.length) {\n      this._buffers[--count] = buf.slice(len);\n    }\n  }\n\n  // remove all used buffers\n  if (count > 0) {\n    this._buffers.splice(0, count);\n  }\n\n  this._buffered -= read.length;\n\n  read.func.call(this, data);\n};\n\nChunkStream.prototype._process = function() {\n\n  try {\n    // as long as there is any data and read requests\n    while (this._buffered > 0 && this._reads && this._reads.length > 0) {\n\n      var read = this._reads[0];\n\n      // read any data (but no more than length)\n      if (read.allowLess) {\n        this._processReadAllowingLess(read);\n\n      }\n      else if (this._buffered >= read.length) {\n        // ok we can meet some expectations\n\n        this._processRead(read);\n      }\n      else {\n        // not enought data to satisfy first request in queue\n        // so we need to wait for more\n        break;\n      }\n    }\n\n    if (this._buffers && this._buffers.length > 0 && this._buffers[0] === null) {\n      this._end();\n    }\n  }\n  catch (ex) {\n    this.emit('error', ex);\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/chunkstream.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/constants.js":
/*!****************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/constants.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = {\n\n  PNG_SIGNATURE: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],\n\n  TYPE_IHDR: 0x49484452,\n  TYPE_IEND: 0x49454e44,\n  TYPE_IDAT: 0x49444154,\n  TYPE_PLTE: 0x504c5445,\n  TYPE_tRNS: 0x74524e53, // eslint-disable-line camelcase\n  TYPE_gAMA: 0x67414d41, // eslint-disable-line camelcase\n\n  // color-type bits\n  COLORTYPE_GRAYSCALE: 0,\n  COLORTYPE_PALETTE: 1,\n  COLORTYPE_COLOR: 2,\n  COLORTYPE_ALPHA: 4, // e.g. grayscale and alpha\n\n  // color-type combinations\n  COLORTYPE_PALETTE_COLOR: 3,\n  COLORTYPE_COLOR_ALPHA: 6,\n\n  COLORTYPE_TO_BPP_MAP: {\n    0: 1,\n    2: 3,\n    3: 1,\n    4: 2,\n    6: 4\n  },\n\n  GAMMA_DIVISION: 100000\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/constants.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/crc.js":
/*!**********************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/crc.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar crcTable = [];\n\n(function() {\n  for (var i = 0; i < 256; i++) {\n    var currentCrc = i;\n    for (var j = 0; j < 8; j++) {\n      if (currentCrc & 1) {\n        currentCrc = 0xedb88320 ^ (currentCrc >>> 1);\n      }\n      else {\n        currentCrc = currentCrc >>> 1;\n      }\n    }\n    crcTable[i] = currentCrc;\n  }\n}());\n\nvar CrcCalculator = module.exports = function() {\n  this._crc = -1;\n};\n\nCrcCalculator.prototype.write = function(data) {\n\n  for (var i = 0; i < data.length; i++) {\n    this._crc = crcTable[(this._crc ^ data[i]) & 0xff] ^ (this._crc >>> 8);\n  }\n  return true;\n};\n\nCrcCalculator.prototype.crc32 = function() {\n  return this._crc ^ -1;\n};\n\n\nCrcCalculator.crc32 = function(buf) {\n\n  var crc = -1;\n  for (var i = 0; i < buf.length; i++) {\n    crc = crcTable[(crc ^ buf[i]) & 0xff] ^ (crc >>> 8);\n  }\n  return crc ^ -1;\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/crc.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-pack.js":
/*!******************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-pack.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar paethPredictor = __webpack_require__(/*! ./paeth-predictor */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/paeth-predictor.js\");\n\nfunction filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {\n  pxData.copy(rawData, rawPos, pxPos, pxPos + byteWidth);\n}\n\nfunction filterSumNone(pxData, pxPos, byteWidth) {\n\n  var sum = 0;\n  var length = pxPos + byteWidth;\n\n  for (var i = pxPos; i < length; i++) {\n    sum += Math.abs(pxData[i]);\n  }\n  return sum;\n}\n\nfunction filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {\n\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var val = pxData[pxPos + x] - left;\n\n    rawData[rawPos + x] = val;\n  }\n}\n\nfunction filterSumSub(pxData, pxPos, byteWidth, bpp) {\n\n  var sum = 0;\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var val = pxData[pxPos + x] - left;\n\n    sum += Math.abs(val);\n  }\n\n  return sum;\n}\n\nfunction filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {\n\n  for (var x = 0; x < byteWidth; x++) {\n\n    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;\n    var val = pxData[pxPos + x] - up;\n\n    rawData[rawPos + x] = val;\n  }\n}\n\nfunction filterSumUp(pxData, pxPos, byteWidth) {\n\n  var sum = 0;\n  var length = pxPos + byteWidth;\n  for (var x = pxPos; x < length; x++) {\n\n    var up = pxPos > 0 ? pxData[x - byteWidth] : 0;\n    var val = pxData[x] - up;\n\n    sum += Math.abs(val);\n  }\n\n  return sum;\n}\n\nfunction filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {\n\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;\n    var val = pxData[pxPos + x] - ((left + up) >> 1);\n\n    rawData[rawPos + x] = val;\n  }\n}\n\nfunction filterSumAvg(pxData, pxPos, byteWidth, bpp) {\n\n  var sum = 0;\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;\n    var val = pxData[pxPos + x] - ((left + up) >> 1);\n\n    sum += Math.abs(val);\n  }\n\n  return sum;\n}\n\nfunction filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {\n\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;\n    var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;\n    var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);\n\n    rawData[rawPos + x] = val;\n  }\n}\n\nfunction filterSumPaeth(pxData, pxPos, byteWidth, bpp) {\n  var sum = 0;\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;\n    var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;\n    var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);\n\n    sum += Math.abs(val);\n  }\n\n  return sum;\n}\n\nvar filters = {\n  0: filterNone,\n  1: filterSub,\n  2: filterUp,\n  3: filterAvg,\n  4: filterPaeth\n};\n\nvar filterSums = {\n  0: filterSumNone,\n  1: filterSumSub,\n  2: filterSumUp,\n  3: filterSumAvg,\n  4: filterSumPaeth\n};\n\nmodule.exports = function(pxData, width, height, options, bpp) {\n\n  var filterTypes;\n  if (!('filterType' in options) || options.filterType === -1) {\n    filterTypes = [0, 1, 2, 3, 4];\n  }\n  else if (typeof options.filterType === 'number') {\n    filterTypes = [options.filterType];\n  }\n  else {\n    throw new Error('unrecognised filter types');\n  }\n\n  var byteWidth = width * bpp;\n  var rawPos = 0;\n  var pxPos = 0;\n  var rawData = new Buffer((byteWidth + 1) * height);\n  var sel = filterTypes[0];\n\n  for (var y = 0; y < height; y++) {\n\n    if (filterTypes.length > 1) {\n      // find best filter for this line (with lowest sum of values)\n      var min = Infinity;\n\n      for (var i = 0; i < filterTypes.length; i++) {\n        var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);\n        if (sum < min) {\n          sel = filterTypes[i];\n          min = sum;\n        }\n      }\n    }\n\n    rawData[rawPos] = sel;\n    rawPos++;\n    filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);\n    rawPos += byteWidth;\n    pxPos += byteWidth;\n  }\n  return rawData;\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-pack.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse-async.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse-async.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar ChunkStream = __webpack_require__(/*! ./chunkstream */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/chunkstream.js\");\nvar Filter = __webpack_require__(/*! ./filter-parse */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse.js\");\n\n\nvar FilterAsync = module.exports = function(bitmapInfo) {\n  ChunkStream.call(this);\n\n  var buffers = [];\n  var that = this;\n  this._filter = new Filter(bitmapInfo, {\n    read: this.read.bind(this),\n    write: function(buffer) {\n      buffers.push(buffer);\n    },\n    complete: function() {\n      that.emit('complete', Buffer.concat(buffers));\n    }\n  });\n\n  this._filter.start();\n};\nutil.inherits(FilterAsync, ChunkStream);\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse-async.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse-sync.js":
/*!************************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse-sync.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar SyncReader = __webpack_require__(/*! ./sync-reader */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/sync-reader.js\");\nvar Filter = __webpack_require__(/*! ./filter-parse */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse.js\");\n\n\nexports.process = function(inBuffer, bitmapInfo) {\n\n  var outBuffers = [];\n  var reader = new SyncReader(inBuffer);\n  var filter = new Filter(bitmapInfo, {\n    read: reader.read.bind(reader),\n    write: function(bufferPart) {\n      outBuffers.push(bufferPart);\n    },\n    complete: function() {\n    }\n  });\n\n  filter.start();\n  reader.process();\n\n  return Buffer.concat(outBuffers);\n};\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse-sync.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar interlaceUtils = __webpack_require__(/*! ./interlace */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/interlace.js\");\nvar paethPredictor = __webpack_require__(/*! ./paeth-predictor */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/paeth-predictor.js\");\n\nfunction getByteWidth(width, bpp, depth) {\n  var byteWidth = width * bpp;\n  if (depth !== 8) {\n    byteWidth = Math.ceil(byteWidth / (8 / depth));\n  }\n  return byteWidth;\n}\n\nvar Filter = module.exports = function(bitmapInfo, dependencies) {\n\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var interlace = bitmapInfo.interlace;\n  var bpp = bitmapInfo.bpp;\n  var depth = bitmapInfo.depth;\n\n  this.read = dependencies.read;\n  this.write = dependencies.write;\n  this.complete = dependencies.complete;\n\n  this._imageIndex = 0;\n  this._images = [];\n  if (interlace) {\n    var passes = interlaceUtils.getImagePasses(width, height);\n    for (var i = 0; i < passes.length; i++) {\n      this._images.push({\n        byteWidth: getByteWidth(passes[i].width, bpp, depth),\n        height: passes[i].height,\n        lineIndex: 0\n      });\n    }\n  }\n  else {\n    this._images.push({\n      byteWidth: getByteWidth(width, bpp, depth),\n      height: height,\n      lineIndex: 0\n    });\n  }\n\n  // when filtering the line we look at the pixel to the left\n  // the spec also says it is done on a byte level regardless of the number of pixels\n  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back\n  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.\n  if (depth === 8) {\n    this._xComparison = bpp;\n  }\n  else if (depth === 16) {\n    this._xComparison = bpp * 2;\n  }\n  else {\n    this._xComparison = 1;\n  }\n};\n\nFilter.prototype.start = function() {\n  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));\n};\n\nFilter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    unfilteredLine[x] = rawByte + f1Left;\n  }\n};\n\nFilter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {\n\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f2Up = lastLine ? lastLine[x] : 0;\n    unfilteredLine[x] = rawByte + f2Up;\n  }\n};\n\nFilter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f3Up = lastLine ? lastLine[x] : 0;\n    var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f3Add = Math.floor((f3Left + f3Up) / 2);\n    unfilteredLine[x] = rawByte + f3Add;\n  }\n};\n\nFilter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f4Up = lastLine ? lastLine[x] : 0;\n    var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;\n    var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);\n    unfilteredLine[x] = rawByte + f4Add;\n  }\n};\n\nFilter.prototype._reverseFilterLine = function(rawData) {\n\n  var filter = rawData[0];\n  var unfilteredLine;\n  var currentImage = this._images[this._imageIndex];\n  var byteWidth = currentImage.byteWidth;\n\n  if (filter === 0) {\n    unfilteredLine = rawData.slice(1, byteWidth + 1);\n  }\n  else {\n\n    unfilteredLine = new Buffer(byteWidth);\n\n    switch (filter) {\n      case 1:\n        this._unFilterType1(rawData, unfilteredLine, byteWidth);\n        break;\n      case 2:\n        this._unFilterType2(rawData, unfilteredLine, byteWidth);\n        break;\n      case 3:\n        this._unFilterType3(rawData, unfilteredLine, byteWidth);\n        break;\n      case 4:\n        this._unFilterType4(rawData, unfilteredLine, byteWidth);\n        break;\n      default:\n        throw new Error('Unrecognised filter type - ' + filter);\n    }\n  }\n\n  this.write(unfilteredLine);\n\n  currentImage.lineIndex++;\n  if (currentImage.lineIndex >= currentImage.height) {\n    this._lastLine = null;\n    this._imageIndex++;\n    currentImage = this._images[this._imageIndex];\n  }\n  else {\n    this._lastLine = unfilteredLine;\n  }\n\n  if (currentImage) {\n    // read, using the byte width that may be from the new current image\n    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));\n  }\n  else {\n    this._lastLine = null;\n    this.complete();\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/format-normaliser.js":
/*!************************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/format-normaliser.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nfunction dePalette(indata, outdata, width, height, palette) {\r\n  var pxPos = 0;\r\n  // use values from palette\r\n  for (var y = 0; y < height; y++) {\r\n    for (var x = 0; x < width; x++) {\r\n      var color = palette[indata[pxPos]];\r\n\r\n      if (!color) {\r\n        throw new Error('index ' + indata[pxPos] + ' not in palette');\r\n      }\r\n\r\n      for (var i = 0; i < 4; i++) {\r\n        outdata[pxPos + i] = color[i];\r\n      }\r\n      pxPos += 4;\r\n    }\r\n  }\r\n}\r\n\r\nfunction replaceTransparentColor(indata, outdata, width, height, transColor) {\r\n  var pxPos = 0;\r\n  for (var y = 0; y < height; y++) {\r\n    for (var x = 0; x < width; x++) {\r\n      var makeTrans = false;\r\n\r\n      if (transColor.length === 1) {\r\n        if (transColor[0] === indata[pxPos]) {\r\n          makeTrans = true;\r\n        }\r\n      }\r\n      else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {\r\n        makeTrans = true;\r\n      }\r\n      if (makeTrans) {\r\n        for (var i = 0; i < 4; i++) {\r\n          outdata[pxPos + i] = 0;\r\n        }\r\n      }\r\n      pxPos += 4;\r\n    }\r\n  }\r\n}\r\n\r\nfunction scaleDepth(indata, outdata, width, height, depth) {\r\n  var maxOutSample = 255;\r\n  var maxInSample = Math.pow(2, depth) - 1;\r\n  var pxPos = 0;\r\n\r\n  for (var y = 0; y < height; y++) {\r\n    for (var x = 0; x < width; x++) {\r\n      for (var i = 0; i < 4; i++) {\r\n        outdata[pxPos + i] = Math.floor((indata[pxPos + i] * maxOutSample) / maxInSample + 0.5);\r\n      }\r\n      pxPos += 4;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = function(indata, imageData) {\r\n\r\n  var depth = imageData.depth;\r\n  var width = imageData.width;\r\n  var height = imageData.height;\r\n  var colorType = imageData.colorType;\r\n  var transColor = imageData.transColor;\r\n  var palette = imageData.palette;\r\n\r\n  var outdata = indata; // only different for 16 bits\r\n\r\n  if (colorType === 3) { // paletted\r\n    dePalette(indata, outdata, width, height, palette);\r\n  }\r\n  else {\r\n    if (transColor) {\r\n      replaceTransparentColor(indata, outdata, width, height, transColor);\r\n    }\r\n    // if it needs scaling\r\n    if (depth !== 8) {\r\n      // if we need to change the buffer size\r\n      if (depth === 16) {\r\n        outdata = new Buffer(width * height * 4);\r\n      }\r\n      scaleDepth(indata, outdata, width, height, depth);\r\n    }\r\n  }\r\n  return outdata;\r\n};\r\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/format-normaliser.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/interlace.js":
/*!****************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/interlace.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Adam 7\n//   0 1 2 3 4 5 6 7\n// 0 x 6 4 6 x 6 4 6\n// 1 7 7 7 7 7 7 7 7\n// 2 5 6 5 6 5 6 5 6\n// 3 7 7 7 7 7 7 7 7\n// 4 3 6 4 6 3 6 4 6\n// 5 7 7 7 7 7 7 7 7\n// 6 5 6 5 6 5 6 5 6\n// 7 7 7 7 7 7 7 7 7\n\n\nvar imagePasses = [\n  { // pass 1 - 1px\n    x: [0],\n    y: [0]\n  },\n  { // pass 2 - 1px\n    x: [4],\n    y: [0]\n  },\n  { // pass 3 - 2px\n    x: [0, 4],\n    y: [4]\n  },\n  { // pass 4 - 4px\n    x: [2, 6],\n    y: [0, 4]\n  },\n  { // pass 5 - 8px\n    x: [0, 2, 4, 6],\n    y: [2, 6]\n  },\n  { // pass 6 - 16px\n    x: [1, 3, 5, 7],\n    y: [0, 2, 4, 6]\n  },\n  { // pass 7 - 32px\n    x: [0, 1, 2, 3, 4, 5, 6, 7],\n    y: [1, 3, 5, 7]\n  }\n];\n\nexports.getImagePasses = function(width, height) {\n  var images = [];\n  var xLeftOver = width % 8;\n  var yLeftOver = height % 8;\n  var xRepeats = (width - xLeftOver) / 8;\n  var yRepeats = (height - yLeftOver) / 8;\n  for (var i = 0; i < imagePasses.length; i++) {\n    var pass = imagePasses[i];\n    var passWidth = xRepeats * pass.x.length;\n    var passHeight = yRepeats * pass.y.length;\n    for (var j = 0; j < pass.x.length; j++) {\n      if (pass.x[j] < xLeftOver) {\n        passWidth++;\n      }\n      else {\n        break;\n      }\n    }\n    for (j = 0; j < pass.y.length; j++) {\n      if (pass.y[j] < yLeftOver) {\n        passHeight++;\n      }\n      else {\n        break;\n      }\n    }\n    if (passWidth > 0 && passHeight > 0) {\n      images.push({ width: passWidth, height: passHeight, index: i });\n    }\n  }\n  return images;\n};\n\nexports.getInterlaceIterator = function(width) {\n  return function(x, y, pass) {\n    var outerXLeftOver = x % imagePasses[pass].x.length;\n    var outerX = (((x - outerXLeftOver) / imagePasses[pass].x.length) * 8) + imagePasses[pass].x[outerXLeftOver];\n    var outerYLeftOver = y % imagePasses[pass].y.length;\n    var outerY = (((y - outerYLeftOver) / imagePasses[pass].y.length) * 8) + imagePasses[pass].y[outerYLeftOver];\n    return (outerX * 4) + (outerY * width * 4);\n  };\n};\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/interlace.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/packer-async.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/packer-async.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\nvar constants = __webpack_require__(/*! ./constants */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/constants.js\");\nvar Packer = __webpack_require__(/*! ./packer */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/packer.js\");\n\nvar PackerAsync = module.exports = function(opt) {\n  Stream.call(this);\n\n  var options = opt || {};\n\n  this._packer = new Packer(options);\n  this._deflate = this._packer.createDeflate();\n\n  this.readable = true;\n};\nutil.inherits(PackerAsync, Stream);\n\n\nPackerAsync.prototype.pack = function(data, width, height, gamma) {\n  // Signature\n  this.emit('data', new Buffer(constants.PNG_SIGNATURE));\n  this.emit('data', this._packer.packIHDR(width, height));\n\n  if (gamma) {\n    this.emit('data', this._packer.packGAMA(gamma));\n  }\n\n  var filteredData = this._packer.filterData(data, width, height);\n\n  // compress it\n  this._deflate.on('error', this.emit.bind(this, 'error'));\n\n  this._deflate.on('data', function(compressedData) {\n    this.emit('data', this._packer.packIDAT(compressedData));\n  }.bind(this));\n\n  this._deflate.on('end', function() {\n    this.emit('data', this._packer.packIEND());\n    this.emit('end');\n  }.bind(this));\n\n  this._deflate.end(filteredData);\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/packer-async.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/packer-sync.js":
/*!******************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/packer-sync.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\nvar constants = __webpack_require__(/*! ./constants */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/constants.js\");\nvar Packer = __webpack_require__(/*! ./packer */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/packer.js\");\n\nmodule.exports = function(metaData, opt) {\n  var options = opt || {};\n\n  var packer = new Packer(options);\n\n  var chunks = [];\n\n  // Signature\n  chunks.push(new Buffer(constants.PNG_SIGNATURE));\n\n  // Header\n  chunks.push(packer.packIHDR(metaData.width, metaData.height));\n\n  if (metaData.gamma) {\n    chunks.push(packer.packGAMA(metaData.gamma));\n  }\n\n  var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);\n\n  // compress it\n  var compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());\n  filteredData = null;\n\n  if (!compressedData || !compressedData.length) {\n    throw new Error('bad png - invalid compressed data response');\n  }\n  chunks.push(packer.packIDAT(compressedData));\n\n  // End\n  chunks.push(packer.packIEND());\n\n  return Buffer.concat(chunks);\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/packer-sync.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/packer.js":
/*!*************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/packer.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar constants = __webpack_require__(/*! ./constants */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/constants.js\");\nvar CrcStream = __webpack_require__(/*! ./crc */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/crc.js\");\nvar bitPacker = __webpack_require__(/*! ./bitpacker */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/bitpacker.js\");\nvar filter = __webpack_require__(/*! ./filter-pack */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-pack.js\");\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nvar Packer = module.exports = function(options) {\n  this._options = options;\n\n  options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;\n  options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;\n  options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;\n  options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;\n  options.deflateFactory = options.deflateFactory || zlib.createDeflate;\n  options.bitDepth = options.bitDepth || 8;\n  options.colorType = (typeof options.colorType === 'number') ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;\n\n  if (options.colorType !== constants.COLORTYPE_COLOR && options.colorType !== constants.COLORTYPE_COLOR_ALPHA) {\n    throw new Error('option color type:' + options.colorType + ' is not supported at present');\n  }\n  if (options.bitDepth !== 8) {\n    throw new Error('option bit depth:' + options.bitDepth + ' is not supported at present');\n  }\n};\n\nPacker.prototype.getDeflateOptions = function() {\n  return {\n    chunkSize: this._options.deflateChunkSize,\n    level: this._options.deflateLevel,\n    strategy: this._options.deflateStrategy\n  };\n};\n\nPacker.prototype.createDeflate = function() {\n  return this._options.deflateFactory(this.getDeflateOptions());\n};\n\nPacker.prototype.filterData = function(data, width, height) {\n  // convert to correct format for filtering (e.g. right bpp and bit depth)\n  var packedData = bitPacker(data, width, height, this._options);\n\n  // filter pixel data\n  var bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];\n  var filteredData = filter(packedData, width, height, this._options, bpp);\n  return filteredData;\n};\n\nPacker.prototype._packChunk = function(type, data) {\n\n  var len = (data ? data.length : 0);\n  var buf = new Buffer(len + 12);\n\n  buf.writeUInt32BE(len, 0);\n  buf.writeUInt32BE(type, 4);\n\n  if (data) {\n    data.copy(buf, 8);\n  }\n\n  buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);\n  return buf;\n};\n\nPacker.prototype.packGAMA = function(gamma) {\n  var buf = new Buffer(4);\n  buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);\n  return this._packChunk(constants.TYPE_gAMA, buf);\n};\n\nPacker.prototype.packIHDR = function(width, height) {\n\n  var buf = new Buffer(13);\n  buf.writeUInt32BE(width, 0);\n  buf.writeUInt32BE(height, 4);\n  buf[8] = this._options.bitDepth;  // Bit depth\n  buf[9] = this._options.colorType; // colorType\n  buf[10] = 0; // compression\n  buf[11] = 0; // filter\n  buf[12] = 0; // interlace\n\n  return this._packChunk(constants.TYPE_IHDR, buf);\n};\n\nPacker.prototype.packIDAT = function(data) {\n  return this._packChunk(constants.TYPE_IDAT, data);\n};\n\nPacker.prototype.packIEND = function() {\n  return this._packChunk(constants.TYPE_IEND, null);\n};\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/packer.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/paeth-predictor.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/paeth-predictor.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nmodule.exports = function paethPredictor(left, above, upLeft) {\r\n\r\n  var paeth = left + above - upLeft;\r\n  var pLeft = Math.abs(paeth - left);\r\n  var pAbove = Math.abs(paeth - above);\r\n  var pUpLeft = Math.abs(paeth - upLeft);\r\n\r\n  if (pLeft <= pAbove && pLeft <= pUpLeft) {\r\n    return left;\r\n  }\r\n  if (pAbove <= pUpLeft) {\r\n    return above;\r\n  }\r\n  return upLeft;\r\n};\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/paeth-predictor.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/parser-async.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/parser-async.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\nvar ChunkStream = __webpack_require__(/*! ./chunkstream */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/chunkstream.js\");\nvar FilterAsync = __webpack_require__(/*! ./filter-parse-async */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse-async.js\");\nvar Parser = __webpack_require__(/*! ./parser */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/parser.js\");\nvar bitmapper = __webpack_require__(/*! ./bitmapper */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/bitmapper.js\");\nvar formatNormaliser = __webpack_require__(/*! ./format-normaliser */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/format-normaliser.js\");\n\nvar ParserAsync = module.exports = function(options) {\n  ChunkStream.call(this);\n\n  this._parser = new Parser(options, {\n    read: this.read.bind(this),\n    error: this._handleError.bind(this),\n    metadata: this._handleMetaData.bind(this),\n    gamma: this.emit.bind(this, 'gamma'),\n    palette: this._handlePalette.bind(this),\n    transColor: this._handleTransColor.bind(this),\n    finished: this._finished.bind(this),\n    inflateData: this._inflateData.bind(this)\n  });\n  this._options = options;\n  this.writable = true;\n\n  this._parser.start();\n};\nutil.inherits(ParserAsync, ChunkStream);\n\n\nParserAsync.prototype._handleError = function(err) {\n\n  this.emit('error', err);\n\n  this.writable = false;\n\n  this.destroy();\n\n  if (this._inflate && this._inflate.destroy) {\n    this._inflate.destroy();\n  }\n\n  this.errord = true;\n};\n\nParserAsync.prototype._inflateData = function(data) {\n  if (!this._inflate) {\n    this._inflate = zlib.createInflate();\n\n    this._inflate.on('error', this.emit.bind(this, 'error'));\n    this._filter.on('complete', this._complete.bind(this));\n\n    this._inflate.pipe(this._filter);\n  }\n  this._inflate.write(data);\n};\n\nParserAsync.prototype._handleMetaData = function(metaData) {\n\n  this.emit('metadata', metaData);\n\n  this._bitmapInfo = Object.create(metaData);\n\n  this._filter = new FilterAsync(this._bitmapInfo);\n};\n\nParserAsync.prototype._handleTransColor = function(transColor) {\n  this._bitmapInfo.transColor = transColor;\n};\n\nParserAsync.prototype._handlePalette = function(palette) {\n  this._bitmapInfo.palette = palette;\n};\n\n\nParserAsync.prototype._finished = function() {\n  if (this.errord) {\n    return;\n  }\n\n  if (!this._inflate) {\n    this.emit('error', 'No Inflate block');\n  }\n  else {\n    // no more data to inflate\n    this._inflate.end();\n  }\n  this.destroySoon();\n};\n\nParserAsync.prototype._complete = function(filteredData) {\n\n  if (this.errord) {\n    return;\n  }\n\n  try {\n    var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);\n\n    var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);\n    bitmapData = null;\n  }\n  catch (ex) {\n    this._handleError(ex);\n    return;\n  }\n\n  this.emit('parsed', normalisedBitmapData);\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/parser-async.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/parser-sync.js":
/*!******************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/parser-sync.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\nvar SyncReader = __webpack_require__(/*! ./sync-reader */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/sync-reader.js\");\nvar FilterSync = __webpack_require__(/*! ./filter-parse-sync */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/filter-parse-sync.js\");\nvar Parser = __webpack_require__(/*! ./parser */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/parser.js\");\nvar bitmapper = __webpack_require__(/*! ./bitmapper */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/bitmapper.js\");\nvar formatNormaliser = __webpack_require__(/*! ./format-normaliser */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/format-normaliser.js\");\n\n\nmodule.exports = function(buffer, options) {\n\n  var err;\n  function handleError(_err_) {\n    err = _err_;\n  }\n\n  var metaData;\n  function handleMetaData(_metaData_) {\n    metaData = _metaData_;\n  }\n\n  function handleTransColor(transColor) {\n    metaData.transColor = transColor;\n  }\n\n  function handlePalette(palette) {\n    metaData.palette = palette;\n  }\n\n  var gamma;\n  function handleGamma(_gamma_) {\n    gamma = _gamma_;\n  }\n\n  var inflateDataList = [];\n  function handleInflateData(inflatedData) {\n    inflateDataList.push(inflatedData);\n  }\n\n  var reader = new SyncReader(buffer);\n\n  var parser = new Parser(options, {\n    read: reader.read.bind(reader),\n    error: handleError,\n    metadata: handleMetaData,\n    gamma: handleGamma,\n    palette: handlePalette,\n    transColor: handleTransColor,\n    inflateData: handleInflateData\n  });\n\n  parser.start();\n  reader.process();\n\n  if (err) {\n    throw err;\n  }\n\n  //join together the inflate datas\n  var inflateData = Buffer.concat(inflateDataList);\n  inflateDataList.length = 0;\n\n  var inflatedData = zlib.inflateSync(inflateData);\n  inflateData = null;\n\n  if (!inflatedData || !inflatedData.length) {\n    throw new Error('bad png - invalid inflate data response');\n  }\n\n  var unfilteredData = FilterSync.process(inflatedData, metaData);\n  inflateData = null;\n\n  var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);\n  unfilteredData = null;\n\n  var normalisedBitmapData = formatNormaliser(bitmapData, metaData);\n\n  metaData.data = normalisedBitmapData;\n  metaData.gamma = gamma || 0;\n\n  return metaData;\n};\n\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/parser-sync.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/parser.js":
/*!*************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/parser.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar constants = __webpack_require__(/*! ./constants */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/constants.js\");\nvar CrcCalculator = __webpack_require__(/*! ./crc */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/crc.js\");\n\n\nvar Parser = module.exports = function(options, dependencies) {\n\n  this._options = options;\n  options.checkCRC = options.checkCRC !== false;\n\n  this._hasIHDR = false;\n  this._hasIEND = false;\n\n  // input flags/metadata\n  this._palette = [];\n  this._colorType = 0;\n\n  this._chunks = {};\n  this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);\n  this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);\n  this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);\n  this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);\n  this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);\n  this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);\n\n  this.read = dependencies.read;\n  this.error = dependencies.error;\n  this.metadata = dependencies.metadata;\n  this.gamma = dependencies.gamma;\n  this.transColor = dependencies.transColor;\n  this.palette = dependencies.palette;\n  this.parsed = dependencies.parsed;\n  this.inflateData = dependencies.inflateData;\n  this.inflateData = dependencies.inflateData;\n  this.finished = dependencies.finished;\n};\n\nParser.prototype.start = function() {\n  this.read(constants.PNG_SIGNATURE.length,\n    this._parseSignature.bind(this)\n  );\n};\n\nParser.prototype._parseSignature = function(data) {\n\n  var signature = constants.PNG_SIGNATURE;\n\n  for (var i = 0; i < signature.length; i++) {\n    if (data[i] !== signature[i]) {\n      this.error(new Error('Invalid file signature'));\n      return;\n    }\n  }\n  this.read(8, this._parseChunkBegin.bind(this));\n};\n\nParser.prototype._parseChunkBegin = function(data) {\n\n  // chunk content length\n  var length = data.readUInt32BE(0);\n\n  // chunk type\n  var type = data.readUInt32BE(4);\n  var name = '';\n  for (var i = 4; i < 8; i++) {\n    name += String.fromCharCode(data[i]);\n  }\n\n  //console.log('chunk ', name, length);\n\n  // chunk flags\n  var ancillary = Boolean(data[4] & 0x20); // or critical\n//    priv = Boolean(data[5] & 0x20), // or public\n//    safeToCopy = Boolean(data[7] & 0x20); // or unsafe\n\n  if (!this._hasIHDR && type !== constants.TYPE_IHDR) {\n    this.error(new Error('Expected IHDR on beggining'));\n    return;\n  }\n\n  this._crc = new CrcCalculator();\n  this._crc.write(new Buffer(name));\n\n  if (this._chunks[type]) {\n    return this._chunks[type](length);\n  }\n\n  if (!ancillary) {\n    this.error(new Error('Unsupported critical chunk type ' + name));\n    return;\n  }\n\n  this.read(length + 4, this._skipChunk.bind(this));\n};\n\nParser.prototype._skipChunk = function(/*data*/) {\n  this.read(8, this._parseChunkBegin.bind(this));\n};\n\nParser.prototype._handleChunkEnd = function() {\n  this.read(4, this._parseChunkEnd.bind(this));\n};\n\nParser.prototype._parseChunkEnd = function(data) {\n\n  var fileCrc = data.readInt32BE(0);\n  var calcCrc = this._crc.crc32();\n\n  // check CRC\n  if (this._options.checkCRC && calcCrc !== fileCrc) {\n    this.error(new Error('Crc error - ' + fileCrc + ' - ' + calcCrc));\n    return;\n  }\n\n  if (!this._hasIEND) {\n    this.read(8, this._parseChunkBegin.bind(this));\n  }\n};\n\nParser.prototype._handleIHDR = function(length) {\n  this.read(length, this._parseIHDR.bind(this));\n};\nParser.prototype._parseIHDR = function(data) {\n\n  this._crc.write(data);\n\n  var width = data.readUInt32BE(0);\n  var height = data.readUInt32BE(4);\n  var depth = data[8];\n  var colorType = data[9]; // bits: 1 palette, 2 color, 4 alpha\n  var compr = data[10];\n  var filter = data[11];\n  var interlace = data[12];\n\n  // console.log('    width', width, 'height', height,\n  //     'depth', depth, 'colorType', colorType,\n  //     'compr', compr, 'filter', filter, 'interlace', interlace\n  // );\n\n  if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {\n    this.error(new Error('Unsupported bit depth ' + depth));\n    return;\n  }\n  if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {\n    this.error(new Error('Unsupported color type'));\n    return;\n  }\n  if (compr !== 0) {\n    this.error(new Error('Unsupported compression method'));\n    return;\n  }\n  if (filter !== 0) {\n    this.error(new Error('Unsupported filter method'));\n    return;\n  }\n  if (interlace !== 0 && interlace !== 1) {\n    this.error(new Error('Unsupported interlace method'));\n    return;\n  }\n\n  this._colorType = colorType;\n\n  var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];\n\n  this._hasIHDR = true;\n\n  this.metadata({\n    width: width,\n    height: height,\n    depth: depth,\n    interlace: Boolean(interlace),\n    palette: Boolean(colorType & constants.COLORTYPE_PALETTE),\n    color: Boolean(colorType & constants.COLORTYPE_COLOR),\n    alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),\n    bpp: bpp,\n    colorType: colorType\n  });\n\n  this._handleChunkEnd();\n};\n\n\nParser.prototype._handlePLTE = function(length) {\n  this.read(length, this._parsePLTE.bind(this));\n};\nParser.prototype._parsePLTE = function(data) {\n\n  this._crc.write(data);\n\n  var entries = Math.floor(data.length / 3);\n  // console.log('Palette:', entries);\n\n  for (var i = 0; i < entries; i++) {\n    this._palette.push([\n      data[i * 3],\n      data[i * 3 + 1],\n      data[i * 3 + 2],\n      0xff\n    ]);\n  }\n\n  this.palette(this._palette);\n\n  this._handleChunkEnd();\n};\n\nParser.prototype._handleTRNS = function(length) {\n  this.read(length, this._parseTRNS.bind(this));\n};\nParser.prototype._parseTRNS = function(data) {\n\n  this._crc.write(data);\n\n  // palette\n  if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {\n    if (this._palette.length === 0) {\n      this.error(new Error('Transparency chunk must be after palette'));\n      return;\n    }\n    if (data.length > this._palette.length) {\n      this.error(new Error('More transparent colors than palette size'));\n      return;\n    }\n    for (var i = 0; i < data.length; i++) {\n      this._palette[i][3] = data[i];\n    }\n    this.palette(this._palette);\n  }\n\n  // for colorType 0 (grayscale) and 2 (rgb)\n  // there might be one gray/color defined as transparent\n  if (this._colorType === constants.COLORTYPE_GRAYSCALE) {\n    // grey, 2 bytes\n    this.transColor([data.readUInt16BE(0)]);\n  }\n  if (this._colorType === constants.COLORTYPE_COLOR) {\n    this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);\n  }\n\n  this._handleChunkEnd();\n};\n\nParser.prototype._handleGAMA = function(length) {\n  this.read(length, this._parseGAMA.bind(this));\n};\nParser.prototype._parseGAMA = function(data) {\n\n  this._crc.write(data);\n  this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);\n\n  this._handleChunkEnd();\n};\n\nParser.prototype._handleIDAT = function(length) {\n  this.read(-length, this._parseIDAT.bind(this, length));\n};\nParser.prototype._parseIDAT = function(length, data) {\n\n  this._crc.write(data);\n\n  if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {\n    throw new Error('Expected palette not found');\n  }\n\n  this.inflateData(data);\n  var leftOverLength = length - data.length;\n\n  if (leftOverLength > 0) {\n    this._handleIDAT(leftOverLength);\n  }\n  else {\n    this._handleChunkEnd();\n  }\n};\n\nParser.prototype._handleIEND = function(length) {\n  this.read(length, this._parseIEND.bind(this));\n};\nParser.prototype._parseIEND = function(data) {\n\n  this._crc.write(data);\n\n  this._hasIEND = true;\n  this._handleChunkEnd();\n\n  if (this.finished) {\n    this.finished();\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/parser.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/png-sync.js":
/*!***************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/png-sync.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar parse = __webpack_require__(/*! ./parser-sync */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/parser-sync.js\");\nvar pack = __webpack_require__(/*! ./packer-sync */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/packer-sync.js\");\n\n\nexports.read = function(buffer, options) {\n\n  return parse(buffer, options || {});\n};\n\nexports.write = function(png) {\n\n  return pack(png);\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/png-sync.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/png.js":
/*!**********************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/png.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\nvar Parser = __webpack_require__(/*! ./parser-async */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/parser-async.js\");\nvar Packer = __webpack_require__(/*! ./packer-async */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/packer-async.js\");\nvar PNGSync = __webpack_require__(/*! ./png-sync */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/png-sync.js\");\n\n\nvar PNG = exports.PNG = function(options) {\n  Stream.call(this);\n\n  options = options || {}; // eslint-disable-line no-param-reassign\n\n  this.width = options.width || 0;\n  this.height = options.height || 0;\n\n  this.data = this.width > 0 && this.height > 0 ?\n    new Buffer(4 * this.width * this.height) : null;\n\n  if (options.fill && this.data) {\n    this.data.fill(0);\n  }\n\n  this.gamma = 0;\n  this.readable = this.writable = true;\n\n  this._parser = new Parser(options);\n\n  this._parser.on('error', this.emit.bind(this, 'error'));\n  this._parser.on('close', this._handleClose.bind(this));\n  this._parser.on('metadata', this._metadata.bind(this));\n  this._parser.on('gamma', this._gamma.bind(this));\n  this._parser.on('parsed', function(data) {\n    this.data = data;\n    this.emit('parsed', data);\n  }.bind(this));\n\n  this._packer = new Packer(options);\n  this._packer.on('data', this.emit.bind(this, 'data'));\n  this._packer.on('end', this.emit.bind(this, 'end'));\n  this._parser.on('close', this._handleClose.bind(this));\n  this._packer.on('error', this.emit.bind(this, 'error'));\n\n};\nutil.inherits(PNG, Stream);\n\nPNG.sync = PNGSync;\n\nPNG.prototype.pack = function() {\n\n  if (!this.data || !this.data.length) {\n    this.emit('error', 'No data provided');\n    return this;\n  }\n\n  process.nextTick(function() {\n    this._packer.pack(this.data, this.width, this.height, this.gamma);\n  }.bind(this));\n\n  return this;\n};\n\n\nPNG.prototype.parse = function(data, callback) {\n\n  if (callback) {\n    var onParsed, onError;\n\n    onParsed = function(parsedData) {\n      this.removeListener('error', onError);\n\n      this.data = parsedData;\n      callback(null, this);\n    }.bind(this);\n\n    onError = function(err) {\n      this.removeListener('parsed', onParsed);\n\n      callback(err, null);\n    }.bind(this);\n\n    this.once('parsed', onParsed);\n    this.once('error', onError);\n  }\n\n  this.end(data);\n  return this;\n};\n\nPNG.prototype.write = function(data) {\n  this._parser.write(data);\n  return true;\n};\n\nPNG.prototype.end = function(data) {\n  this._parser.end(data);\n};\n\nPNG.prototype._metadata = function(metadata) {\n  this.width = metadata.width;\n  this.height = metadata.height;\n\n  this.emit('metadata', metadata);\n};\n\nPNG.prototype._gamma = function(gamma) {\n  this.gamma = gamma;\n};\n\nPNG.prototype._handleClose = function() {\n  if (!this._parser.writable && !this._packer.readable) {\n    this.emit('close');\n  }\n};\n\n\nPNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) { // eslint-disable-line max-params\n\n  if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {\n    throw new Error('bitblt reading outside image');\n  }\n\n  if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {\n    throw new Error('bitblt writing outside image');\n  }\n\n  for (var y = 0; y < height; y++) {\n    src.data.copy(dst.data,\n      ((deltaY + y) * dst.width + deltaX) << 2,\n      ((srcY + y) * src.width + srcX) << 2,\n      ((srcY + y) * src.width + srcX + width) << 2\n    );\n  }\n};\n\n\nPNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) { // eslint-disable-line max-params\n\n  PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);\n  return this;\n};\n\nPNG.adjustGamma = function(src) {\n  if (src.gamma) {\n    for (var y = 0; y < src.height; y++) {\n      for (var x = 0; x < src.width; x++) {\n        var idx = (src.width * y + x) << 2;\n\n        for (var i = 0; i < 3; i++) {\n          var sample = src.data[idx + i] / 255;\n          sample = Math.pow(sample, 1 / 2.2 / src.gamma);\n          src.data[idx + i] = Math.round(sample * 255);\n        }\n      }\n    }\n    src.gamma = 0;\n  }\n};\n\nPNG.prototype.adjustGamma = function() {\n  PNG.adjustGamma(this);\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/png.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/node_modules/pngjs/lib/sync-reader.js":
/*!******************************************************************************!*\
  !*** ../node_modules/node-resemble-js/node_modules/pngjs/lib/sync-reader.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar SyncReader = module.exports = function(buffer) {\n\n  this._buffer = buffer;\n  this._reads = [];\n};\n\nSyncReader.prototype.read = function(length, callback) {\n\n  this._reads.push({\n    length: Math.abs(length),  // if length < 0 then at most this length\n    allowLess: length < 0,\n    func: callback\n  });\n};\n\nSyncReader.prototype.process = function() {\n\n  // as long as there is any data and read requests\n  while (this._reads.length > 0 && this._buffer.length) {\n\n    var read = this._reads[0];\n\n    if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {\n\n      // ok there is any data so that we can satisfy this request\n      this._reads.shift(); // == read\n\n      var buf = this._buffer;\n\n      this._buffer = buf.slice(read.length);\n\n      read.func.call(this, buf.slice(0, read.length));\n\n    }\n    else {\n      break;\n    }\n\n  }\n\n  if (this._reads.length > 0) {\n    return new Error('There are some read requests waitng on finished stream');\n  }\n\n  if (this._buffer.length > 0) {\n    return new Error('unrecognised content at end of stream');\n  }\n\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/node_modules/pngjs/lib/sync-reader.js?");

/***/ }),

/***/ "../node_modules/node-resemble-js/resemble.js":
/*!****************************************************!*\
  !*** ../node_modules/node-resemble-js/resemble.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nJames Cryer / Huddle 2014\nURL: https://github.com/Huddle/Resemble.js\n*/\n\n\nvar PNG = __webpack_require__(/*! pngjs */ \"../node_modules/node-resemble-js/node_modules/pngjs/lib/png.js\").PNG;\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar jpeg = __webpack_require__(/*! jpeg-js */ \"../node_modules/jpeg-js/index.js\");\n\n//keeping wrong indentation and '_this' for better diff with origin resemble.js\nvar _this = {};\n\n\tvar pixelTransparency = 1;\n\n\tvar errorPixelColor = { // Color for Error Pixels. Between 0 and 255.\n\t\tred: 255,\n\t\tgreen: 0,\n\t\tblue: 255,\n\t\talpha: 255\n\t};\n\n\tvar errorPixelTransform = {\n\t\tflat : function (d1, d2){\n\t\t\treturn {\n\t\t\t\tr: errorPixelColor.red,\n\t\t\t\tg: errorPixelColor.green,\n\t\t\t\tb: errorPixelColor.blue,\n\t\t\t\ta: errorPixelColor.alpha\n\t\t\t}\n\t\t},\n\t\tmovement: function (d1, d2){\n\t\t\treturn {\n\t\t\t\tr: ((d2.r*(errorPixelColor.red/255)) + errorPixelColor.red)/2,\n\t\t\t\tg: ((d2.g*(errorPixelColor.green/255)) + errorPixelColor.green)/2,\n\t\t\t\tb: ((d2.b*(errorPixelColor.blue/255)) + errorPixelColor.blue)/2,\n\t\t\t\ta: d2.a\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar errorPixelTransformer = errorPixelTransform.flat;\n\tvar largeImageThreshold = 1200;\n\n\t_this['resemble'] = function( fileData ){\n\n\t\tvar data = {};\n\t\tvar images = [];\n\t\tvar updateCallbackArray = [];\n\n\t\tvar tolerance = { // between 0 and 255\n\t\t\tred: 16,\n\t\t\tgreen: 16,\n\t\t\tblue: 16,\n\t\t\talpha: 16,\n\t\t\tminBrightness: 16,\n\t\t\tmaxBrightness: 240\n\t\t};\n\n\t\tvar ignoreAntialiasing = false;\n\t\tvar ignoreColors = false;\n    var ignoreRectangles = null;\n\n\t\tfunction triggerDataUpdate(){\n\t\t\tvar len = updateCallbackArray.length;\n\t\t\tvar i;\n\t\t\tfor(i=0;i<len;i++){\n\t\t\t\tif (typeof updateCallbackArray[i] === 'function'){\n\t\t\t\t\tupdateCallbackArray[i](data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction loop(x, y, callback){\n\t\t\tvar i,j;\n\n\t\t\tfor (i=0;i<x;i++){\n\t\t\t\tfor (j=0;j<y;j++){\n\t\t\t\t\tcallback(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction parseImage(sourceImageData, width, height){\n\n\t\t\tvar pixleCount = 0;\n\t\t\tvar redTotal = 0;\n\t\t\tvar greenTotal = 0;\n\t\t\tvar blueTotal = 0;\n\t\t\tvar brightnessTotal = 0;\n\n\t\t\tloop(height, width, function(verticalPos, horizontalPos){\n\t\t\t\tvar offset = (verticalPos*width + horizontalPos) * 4;\n\t\t\t\tvar red = sourceImageData[offset];\n\t\t\t\tvar green = sourceImageData[offset + 1];\n\t\t\t\tvar blue = sourceImageData[offset + 2];\n\t\t\t\tvar brightness = getBrightness(red,green,blue);\n\n\t\t\t\tpixleCount++;\n\n\t\t\t\tredTotal += red / 255 * 100;\n\t\t\t\tgreenTotal += green / 255 * 100;\n\t\t\t\tblueTotal += blue / 255 * 100;\n\t\t\t\tbrightnessTotal += brightness / 255 * 100;\n\t\t\t});\n\n\t\t\tdata.red = Math.floor(redTotal / pixleCount);\n\t\t\tdata.green = Math.floor(greenTotal / pixleCount);\n\t\t\tdata.blue = Math.floor(blueTotal / pixleCount);\n\t\t\tdata.brightness = Math.floor(brightnessTotal / pixleCount);\n\n\t\t\ttriggerDataUpdate();\n\t\t}\n\n\t\tfunction loadImageData( fileData, callback ){\n\n\t\t\tif (Buffer.isBuffer(fileData)) {\n\t\t\t\tvar png = new PNG();\n\t\t\t\tpng.parse(fileData, function (err, data) {\n\t\t\t\t  callback(data, data.width, data.height);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvar ext = fileData.substring(fileData.lastIndexOf(\".\")+1);\n\t\t\t\tif(ext==\"png\") {\n\t\t\t\t\tvar png = new PNG();\n\t\t\t\t\tfs.createReadStream(fileData)\n\t\t\t\t\t  .pipe(png)\n\t\t\t\t\t  .on('parsed', function() {\n\t\t\t\t\t\tcallback(this, this.width, this.height);\n\t\t\t\t\t  });\n\t\t\t\t}\n\t\t\t\tif(ext==\"jpg\" || ext==\"jpeg\") {\n\t\t\t\t\tvar jpegData = fs.readFileSync(fileData);\n\t\t\t\t\tfileData = jpeg.decode(jpegData, true);\n\t\t\t\t\tcallback(fileData, fileData.width, fileData.height);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction isColorSimilar(a, b, color){\n\n\t\t\tvar absDiff = Math.abs(a - b);\n\n\t\t\tif(typeof a === 'undefined'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(typeof b === 'undefined'){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif(a === b){\n\t\t\t\treturn true;\n\t\t\t} else if ( absDiff < tolerance[color] ) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfunction isNumber(n) {\n\t\t\treturn !isNaN(parseFloat(n));\n\t\t}\n\n\t\tfunction isPixelBrightnessSimilar(d1, d2){\n\t\t\tvar alpha = isColorSimilar(d1.a, d2.a, 'alpha');\n\t\t\tvar brightness = isColorSimilar(d1.brightness, d2.brightness, 'minBrightness');\n\t\t\treturn brightness && alpha;\n\t\t}\n\n\t\tfunction getBrightness(r,g,b){\n\t\t\treturn 0.3*r + 0.59*g + 0.11*b;\n\t\t}\n\n\t\tfunction isRGBSame(d1,d2){\n\t\t\tvar red = d1.r === d2.r;\n\t\t\tvar green = d1.g === d2.g;\n\t\t\tvar blue = d1.b === d2.b;\n\t\t\treturn red && green && blue;\n\t\t}\n\n\t\tfunction isRGBSimilar(d1, d2){\n\t\t\tvar red = isColorSimilar(d1.r,d2.r,'red');\n\t\t\tvar green = isColorSimilar(d1.g,d2.g,'green');\n\t\t\tvar blue = isColorSimilar(d1.b,d2.b,'blue');\n\t\t\tvar alpha = isColorSimilar(d1.a, d2.a, 'alpha');\n\n\t\t\treturn red && green && blue && alpha;\n\t\t}\n\n\t\tfunction isContrasting(d1, d2){\n\t\t\treturn Math.abs(d1.brightness - d2.brightness) > tolerance.maxBrightness;\n\t\t}\n\n\t\tfunction getHue(r,g,b){\n\n\t\t\tr = r / 255;\n\t\t\tg = g / 255;\n\t\t\tb = b / 255;\n\t\t\tvar max = Math.max(r, g, b), min = Math.min(r, g, b);\n\t\t\tvar h;\n\t\t\tvar d;\n\n\t\t\tif (max == min){\n\t\t\t\th = 0; // achromatic\n\t\t\t} else{\n\t\t\t\td = max - min;\n\t\t\t\tswitch(max){\n\t\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\t\tcase b: h = (r - g) / d + 4; break;\n\t\t\t\t}\n\t\t\t\th /= 6;\n\t\t\t}\n\n\t\t\treturn h;\n\t\t}\n\n\t\tfunction isAntialiased(sourcePix, data, cacheSet, verticalPos, horizontalPos, width){\n\t\t\tvar offset;\n\t\t\tvar targetPix;\n\t\t\tvar distance = 1;\n\t\t\tvar i;\n\t\t\tvar j;\n\t\t\tvar hasHighContrastSibling = 0;\n\t\t\tvar hasSiblingWithDifferentHue = 0;\n\t\t\tvar hasEquivilantSibling = 0;\n\n\t\t\taddHueInfo(sourcePix);\n\n\t\t\tfor (i = distance*-1; i <= distance; i++){\n\t\t\t\tfor (j = distance*-1; j <= distance; j++){\n\n\t\t\t\t\tif(i===0 && j===0){\n\t\t\t\t\t\t// ignore source pixel\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toffset = ((verticalPos+j)*width + (horizontalPos+i)) * 4;\n\t\t\t\t\t\ttargetPix = getPixelInfo(data, offset, cacheSet);\n\n\t\t\t\t\t\tif(targetPix === null){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\taddBrightnessInfo(targetPix);\n\t\t\t\t\t\taddHueInfo(targetPix);\n\n\t\t\t\t\t\tif( isContrasting(sourcePix, targetPix) ){\n\t\t\t\t\t\t\thasHighContrastSibling++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( isRGBSame(sourcePix,targetPix) ){\n\t\t\t\t\t\t\thasEquivilantSibling++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( Math.abs(targetPix.h - sourcePix.h) > 0.3 ){\n\t\t\t\t\t\t\thasSiblingWithDifferentHue++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( hasSiblingWithDifferentHue > 1 || hasHighContrastSibling > 1){\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(hasEquivilantSibling < 2){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction errorPixel(px, offset, data1, data2){\n\t\t\tvar data = errorPixelTransformer(data1, data2);\n\t\t\tpx[offset] = data.r;\n\t\t\tpx[offset + 1] = data.g;\n\t\t\tpx[offset + 2] = data.b;\n\t\t\tpx[offset + 3] = data.a;\n\t\t}\n\n\t\tfunction copyPixel(px, offset, data){\n\t\t\tpx[offset] = data.r; //r\n\t\t\tpx[offset + 1] = data.g; //g\n\t\t\tpx[offset + 2] = data.b; //b\n\t\t\tpx[offset + 3] = data.a * pixelTransparency; //a\n\t\t}\n\n\t\tfunction copyGrayScalePixel(px, offset, data){\n\t\t\tpx[offset] = data.brightness; //r\n\t\t\tpx[offset + 1] = data.brightness; //g\n\t\t\tpx[offset + 2] = data.brightness; //b\n\t\t\tpx[offset + 3] = data.a * pixelTransparency; //a\n\t\t}\n\n\t\tfunction getPixelInfo(data, offset, cacheSet){\n\t\t\tvar r;\n\t\t\tvar g;\n\t\t\tvar b;\n\t\t\tvar d;\n\t\t\tvar a;\n\n\t\t\tr = data[offset];\n\n\t\t\tif(typeof r !== 'undefined'){\n\t\t\t\tg = data[offset+1];\n\t\t\t\tb = data[offset+2];\n\t\t\t\ta = data[offset+3];\n\t\t\t\td = {\n\t\t\t\t\tr: r,\n\t\t\t\t\tg: g,\n\t\t\t\t\tb: b,\n\t\t\t\t\ta: a\n\t\t\t\t};\n\n\t\t\t\treturn d;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tfunction addBrightnessInfo(data){\n\t\t\tdata.brightness = getBrightness(data.r,data.g,data.b); // 'corrected' lightness\n\t\t}\n\n\t\tfunction addHueInfo(data){\n\t\t\tdata.h = getHue(data.r,data.g,data.b);\n\t\t}\n\n\t\tfunction analyseImages(img1, img2, width, height){\n\n\t\t\tvar data1 = img1.data;\n\t\t\tvar data2 = img2.data;\n\n      //TODO\n      var imgd = new PNG({\n          width: img1.width,\n          height: img1.height,\n          deflateChunkSize: img1.deflateChunkSize,\n          deflateLevel: img1.deflateLevel,\n          deflateStrategy: img1.deflateStrategy,\n        });\n\t\t\tvar targetPix = imgd.data;\n\n\t\t\tvar mismatchCount = 0;\n\n\t\t\tvar time = Date.now();\n\n\t\t\tvar skip;\n\n      var currentRectangle = null;\n      var rectagnlesIdx = 0;\n\n\t\t\tif(!!largeImageThreshold && ignoreAntialiasing && (width > largeImageThreshold || height > largeImageThreshold)){\n\t\t\t\tskip = 6;\n\t\t\t}\n\n\t\t\tloop(height, width, function(verticalPos, horizontalPos){\n\n\t\t\t\tif(skip){ // only skip if the image isn't small\n\t\t\t\t\tif(verticalPos % skip === 0 || horizontalPos % skip === 0){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar offset = (verticalPos*width + horizontalPos) * 4;\n\t\t\t\tvar pixel1 = getPixelInfo(data1, offset, 1);\n\t\t\t\tvar pixel2 = getPixelInfo(data2, offset, 2);\n\n\t\t\t\tif(pixel1 === null || pixel2 === null){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n        if (ignoreRectangles) {\n          for(rectagnlesIdx = 0; rectagnlesIdx < ignoreRectangles.length; rectagnlesIdx++) {\n            currentRectangle = ignoreRectangles[rectagnlesIdx];\n            //console.log(currentRectangle, verticalPos, horizontalPos);\n            if (\n              (verticalPos >= currentRectangle[1]) &&\n              (verticalPos < currentRectangle[1] + currentRectangle[3]) &&\n              (horizontalPos >= currentRectangle[0]) &&\n              (horizontalPos < currentRectangle[0] + currentRectangle[2])\n            ) {\n\t\t\t\t\t\t  copyGrayScalePixel(targetPix, offset, pixel2);\n\t\t\t\t\t    //copyPixel(targetPix, offset, pixel1, pixel2);\n              return;\n            }\n          }\n        }\n\n\t\t\t\tif (ignoreColors){\n\n\t\t\t\t\taddBrightnessInfo(pixel1);\n\t\t\t\t\taddBrightnessInfo(pixel2);\n\n\t\t\t\t\tif( isPixelBrightnessSimilar(pixel1, pixel2) ){\n\t\t\t\t\t\tcopyGrayScalePixel(targetPix, offset, pixel2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrorPixel(targetPix, offset, pixel1, pixel2);\n\t\t\t\t\t\tmismatchCount++;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif( isRGBSimilar(pixel1, pixel2) ){\n\t\t\t\t\tcopyPixel(targetPix, offset, pixel1, pixel2);\n\n\t\t\t\t} else if( ignoreAntialiasing && (\n\t\t\t\t\t\taddBrightnessInfo(pixel1), // jit pixel info augmentation looks a little weird, sorry.\n\t\t\t\t\t\taddBrightnessInfo(pixel2),\n\t\t\t\t\t\tisAntialiased(pixel1, data1, 1, verticalPos, horizontalPos, width) ||\n\t\t\t\t\t\tisAntialiased(pixel2, data2, 2, verticalPos, horizontalPos, width)\n\t\t\t\t\t)){\n\n\t\t\t\t\tif( isPixelBrightnessSimilar(pixel1, pixel2) ){\n\t\t\t\t\t\tcopyGrayScalePixel(targetPix, offset, pixel2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrorPixel(targetPix, offset, pixel1, pixel2);\n\t\t\t\t\t\tmismatchCount++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrorPixel(targetPix, offset, pixel1, pixel2);\n\t\t\t\t\tmismatchCount++;\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tdata.misMatchPercentage = (mismatchCount / (height*width) * 100).toFixed(2);\n\t\t\tdata.analysisTime = Date.now() - time;\n\n\t\t\tdata.getDiffImage = function(text){\n        return imgd;\n\t\t\t};\n\n\t\t\tdata.getDiffImageAsJPEG = function(quality) {\n\t\t\t\treturn jpeg.encode({\n\t\t\t\t  data: targetPix,\n\t\t\t\t  width: img1.width,\n\t\t\t\t  height: img1.height\n\t\t\t\t}, quality !== undefined ? quality : 50).data;\n\t\t\t};\n\t\t}\n\n\t\tfunction compare(one, two){\n\n\t\t\tfunction onceWeHaveBoth(img){\n\t\t\t\tvar width;\n\t\t\t\tvar height;\n\n        images.push(img);\n\t\t\t\tif(images.length === 2){\n\t\t\t\t\twidth = images[0].width > images[1].width ? images[0].width : images[1].width;\n\t\t\t\t\theight = images[0].height > images[1].height ? images[0].height : images[1].height;\n\n\t\t\t\t\tif( (images[0].width === images[1].width) && (images[0].height === images[1].height) ){\n\t\t\t\t\t\tdata.isSameDimensions = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata.isSameDimensions = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.dimensionDifference = { width: images[0].width - images[1].width, height: images[0].height - images[1].height };\n\n          //lksv: normalization removed\n\t\t\t\t\tanalyseImages( images[0], images[1], width, height);\n\n\t\t\t\t\ttriggerDataUpdate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timages = [];\n\t\t\tloadImageData(one, onceWeHaveBoth);\n\t\t\tloadImageData(two, onceWeHaveBoth);\n\t\t}\n\n\t\tfunction getCompareApi(param){\n\n\t\t\tvar secondFileData,\n\t\t\t\thasMethod = typeof param === 'function';\n\n\t\t\tif( !hasMethod ){\n\t\t\t\t// assume it's file data\n\t\t\t\tsecondFileData = param;\n\t\t\t}\n\n\t\t\tvar self = {\n\t\t\t\tignoreNothing: function(){\n\n\t\t\t\t\ttolerance.red = 16;\n\t\t\t\t\ttolerance.green = 16;\n\t\t\t\t\ttolerance.blue = 16;\n\t\t\t\t\ttolerance.alpha = 16;\n\t\t\t\t\ttolerance.minBrightness = 16;\n\t\t\t\t\ttolerance.maxBrightness = 240;\n\n\t\t\t\t\tignoreAntialiasing = false;\n\t\t\t\t\tignoreColors = false;\n\n\t\t\t\t\tif(hasMethod) { param(); }\n\t\t\t\t\treturn self;\n\t\t\t\t},\n\t\t\t\tignoreAntialiasing: function(){\n\n\t\t\t\t\ttolerance.red = 32;\n\t\t\t\t\ttolerance.green = 32;\n\t\t\t\t\ttolerance.blue = 32;\n\t\t\t\t\ttolerance.alpha = 32;\n\t\t\t\t\ttolerance.minBrightness = 64;\n\t\t\t\t\ttolerance.maxBrightness = 96;\n\n\t\t\t\t\tignoreAntialiasing = true;\n\t\t\t\t\tignoreColors = false;\n\n\t\t\t\t\tif(hasMethod) { param(); }\n\t\t\t\t\treturn self;\n\t\t\t\t},\n\t\t\t\tignoreColors: function(){\n\n\t\t\t\t\ttolerance.alpha = 16;\n\t\t\t\t\ttolerance.minBrightness = 16;\n\t\t\t\t\ttolerance.maxBrightness = 240;\n\n\t\t\t\t\tignoreAntialiasing = false;\n\t\t\t\t\tignoreColors = true;\n\n\t\t\t\t\tif(hasMethod) { param(); }\n\t\t\t\t\treturn self;\n\t\t\t\t},\n        //array of rectangles, each rectangle is defined as (x, y, width. height)\n        //e.g. [[325, 170, 100, 40]]\n        ignoreRectangles: function(rectangles) {\n          ignoreRectangles = rectangles;\n          return self;\n        },\n\t\t\t\trepaint: function(){\n\t\t\t\t\tif(hasMethod) { param(); }\n\t\t\t\t\treturn self;\n\t\t\t\t},\n\t\t\t\tonComplete: function( callback ){\n\n\t\t\t\t\tupdateCallbackArray.push(callback);\n\n\t\t\t\t\tvar wrapper = function(){\n\t\t\t\t\t\tcompare(fileData, secondFileData);\n\t\t\t\t\t};\n\n\t\t\t\t\twrapper();\n\n\t\t\t\t\treturn getCompareApi(wrapper);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn self;\n\t\t}\n\n\t\treturn {\n\t\t\tonComplete: function( callback ){\n\t\t\t\tupdateCallbackArray.push(callback);\n\t\t\t\tloadImageData(fileData, function(imageData, width, height){\n\t\t\t\t\tparseImage(imageData.data, width, height);\n\t\t\t\t});\n\t\t\t},\n\t\t\tcompareTo: function(secondFileData){\n\t\t\t\treturn getCompareApi(secondFileData);\n\t\t\t}\n\t\t};\n\n\t};\n\n\t_this['resemble'].outputSettings = function(options){\n\t\tvar key;\n\t\tvar undefined;\n\n\t\tif(options.errorColor){\n\t\t\tfor (key in options.errorColor) {\n\t\t\t\terrorPixelColor[key] = options.errorColor[key] === undefined ? errorPixelColor[key] : options.errorColor[key];\n\t\t\t}\n\t\t}\n\n\t\tif(options.errorType && errorPixelTransform[options.errorType] ){\n\t\t\terrorPixelTransformer = errorPixelTransform[options.errorType];\n\t\t}\n\t\t\n\t\tpixelTransparency = options.transparency || pixelTransparency;\n\n\t\tif (options.largeImageThreshold !== undefined) {\n\t\t\tlargeImageThreshold = options.largeImageThreshold;\n\t\t}\n\n\t\treturn this;\n\t};\n\nmodule.exports = _this['resemble']\n\n\n//# sourceURL=webpack:///../node_modules/node-resemble-js/resemble.js?");

/***/ }),

/***/ "../node_modules/node-trx/formatter.js":
/*!*********************************************!*\
  !*** ../node_modules/node-trx/formatter.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var builder = __webpack_require__(/*! xmlbuilder */ \"../node_modules/xmlbuilder/lib/index.js\");\n\n/**\n * Formats a `TestRun` into xml\n *\n * @param {TestRun} testRun - the `TestRun` instance to format\n * @return {string} xml\n */\nexports.testRun = function (testRun) {\n  var xml = builder.create('TestRun')\n    , el;\n\n  xml.att('xmlns', 'http://microsoft.com/schemas/VisualStudio/TeamTest/2010');\n  xml.att('id', testRun.id);\n  xml.att('name', testRun.name);\n\n  if (testRun.runUser) {\n    xml.att('runUser', testRun.runUser);\n  }\n\n  if (testRun.times) {\n    el = xml.ele('Times')\n      .att('creation', testRun.times.creation)\n      .att('queuing', testRun.times.queuing)\n      .att('start', testRun.times.start)\n      .att('finish', testRun.times.finish);\n  }\n\n\n  el = xml.ele('TestSettings')\n    .att('name', testRun.testSettings.name)\n    .att('id', testRun.testSettings.id);\n\n  if(testRun.testSettings.deployment !== null && testRun.testSettings.deployment !== undefined) {\n    buildDeployment(el, testRun.testSettings.deployment)\n  }\n\n  // TODO: add Output > StdOut tags in result summary\n  el = xml.ele('ResultSummary')\n    .att('outcome', testRun.counters.failed > 0 ? 'Failed' : 'Completed')\n    .ele('Counters')\n    .att('total', testRun.counters.total)\n    .att('executed', testRun.counters.executed)\n    .att('passed', testRun.counters.passed)\n    .att('error', testRun.counters.error)\n    .att('failed', testRun.counters.failed)\n    .att('timeout', testRun.counters.timeout)\n    .att('aborted', testRun.counters.aborted)\n    .att('inconclusive', testRun.counters.inconclusive)\n    .att('passedButRunAborted', testRun.counters.passedButRunAborted)\n    .att('notRunnable', testRun.counters.notRunnable)\n    .att('notExecuted', testRun.counters.notExecuted)\n    .att('disconnected', testRun.counters.disconnected)\n    .att('warning', testRun.counters.warning)\n    .att('completed', testRun.counters.completed)\n    .att('inProgress', testRun.counters.inProgress)\n    .att('pending', testRun.counters.pending);\n\n  el = xml.ele('TestDefinitions');\n  buildArray(testRun.testDefinitions, el, buildTestDefinition);\n\n  el = xml.ele('TestLists');\n  buildArray(testRun.testLists, el, buildTestList);\n\n  el = xml.ele('TestEntries');\n  buildArray(testRun.testEntries, el, buildTestEntry);\n\n  el = xml.ele('Results');\n  buildArray(testRun.testResults, el, buildTestResult);\n\n  return xml.end({pretty: true});\n}\n\nfunction buildArray(items, element, builder) {\n  items.forEach(function (item) {\n    builder(element, item);\n  });\n}\n\nfunction buildDeployment(parent, deploymentDefinition) {\n  var ele = parent.ele('Deployment');\n  \n  if(deploymentDefinition.runDeploymentRoot !== undefined) {\n    ele.att('runDeploymentRoot', deploymentDefinition.runDeploymentRoot);\n  }\n}\n\nfunction buildTestDefinition(parent, testDefinition) {\n  var xml = parent.ele('UnitTest')\n    .att('id', testDefinition.id)\n    .att('name', testDefinition.name);\n\n  if (testDefinition.description) {\n    xml.ele('Description', testDefinition.description);\n  }\n\n  if(testDefinition.owners) {\n    var owners = xml.ele('Owners');\n    buildArray(testDefinition.owners, owners, buildTestOwners);\n  }\n   \n  xml.ele('Execution', {id: testDefinition.executionId}, null);\n  xml.ele('TestMethod')\n    .att('codeBase', testDefinition.methodCodeBase)\n    .att('className', testDefinition.methodClassName)\n    .att('name', testDefinition.methodName)\n}\n\nfunction buildTestList(parent, testList) {\n  var xml = parent.ele('TestList')\n    .att('id', testList.id)\n    .att('name', testList.name);\n}\n\nfunction buildTestEntry(parent, testEntry) {\n  var xml = parent.ele('TestEntry')\n    .att('testId', testEntry.testId)\n    .att('executionId', testEntry.executionId)\n    .att('testListId', testEntry.testListId);\n}\n\nfunction buildTestOwners(parent, owner) {\n  var xml = parent.ele('Owner', owner)\n    .att('name', owner.name);\n}\n\nfunction buildTestResult(parent, result) {\n  var xml = parent.ele('UnitTestResult')\n    .att('testId', result.testId)\n    .att('testName', result.testName)\n    .att('testType', result.testType)\n    .att('testListId', result.testListId)\n    .att('computerName', result.computerName);\n\n  if (result.outcome) {\n    xml.att('outcome', result.outcome);\n  }\n\n  if (result.startTime) {\n    xml.att('startTime', result.startTime);\n  }\n\n  if (result.endTime) {\n    xml.att('endTime', result.endTime);\n  }\n\n  if (result.duration) {\n    xml.att('duration', result.duration);\n  }\n\n  if (result.executionId) {\n    xml.att('executionId', result.executionId);\n  }\n\n  if (result.relativeResultsDirectory) { \n    xml.att('relativeResultsDirectory', result.relativeResultsDirectory);\n  }\n\n  if(result.resultFiles && result.resultFiles.length > 0) {\n\t  buildArray(result.resultFiles, xml.ele('ResultFiles'), buildResultFileEntry);\n  }\n\n  if (result.output || result.errorMessage || result.errorStacktrace) {\n    var output = xml.ele('Output');\n    output.ele('StdOut', result.output || '');\n\n    if (result.errorMessage || result.errorStacktrace) {\n      var error = output.ele('ErrorInfo');\n      error.ele('Message', result.errorMessage || '');\n      error.ele('StackTrace', result.errorStacktrace || '');\n    }\n  }\n}\n\nfunction buildResultFileEntry(parent, result) {\n  var xml = parent.ele('ResultFile').att('path', result.path);\n}\n\n\n\n//# sourceURL=webpack:///../node_modules/node-trx/formatter.js?");

/***/ }),

/***/ "../node_modules/node-trx/trx.js":
/*!***************************************!*\
  !*** ../node_modules/node-trx/trx.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var uuid = __webpack_require__(/*! uuid */ \"../node_modules/uuid/index.js\")\n  , formatter = __webpack_require__(/*! ./formatter */ \"../node_modules/node-trx/formatter.js\");\n\n/**\n * Represents a test run as defined in the XSD `TestRunType`\n *\n * @param {object} params\n * @config {string} name\n * @config {string} [id]\n * @config {string} [runUser]\n */\nfunction TestRun(params) {\n  this.id = params.id || uuid.v4();\n  this.name = params.name;\n\n  if (params.runUser) {\n    this.runUser = params.runUser;\n  }\n\n  if (params.times) {\n    this.times = new Times(params.times);\n  }\n\n  if (params.testSettings) {\n    this.testSettings = new TestSettings(params.testSettings);\n  } else {\n    this.testSettings = new TestSettings({\n        id: 'ce1a4cfb-64fa-4d63-8815-e9984737a62c',\n        name: 'Default Test Settings'\n    });\n  }\n\n  if(params.deployment) {\n    // support for attachments. If the reporter wants to attach files (like screenshots), \n    // it should specify the folder like this: \n    //  params.deployment = { runDeploymentRoot : 'attachmentsFolderName' }\n    // the folder should have the following hierarchy\n    //  * myreport.trx \n    //  -> attachmentsFolderName\n    //    -> In    (i still dont know how to get this out of the way)\n    //      -> executionId_Or_RelativeResultsDirectoryName\n    //        * file.png\n    //\n    this.testSettings.deployment = new Deployment(params.deployment); \n  }\n\n  this.testDefinitions = [];\n  this.testLists = [\n    TestList.ResultsNotInAList,\n    TestList.AllLoadedResults\n  ];\n  this.testEntries = [];\n  this.testResults = [];\n\n  this.counters = new Counter();\n}\n\n\nTestRun.prototype.toXml = function () {\n  return formatter.testRun(this);\n}\n\n\n/**\n * Adds a test result to the run\n *\n * @param {object} params\n * @config {GenericTest} test\n * @config {string} [computerName]\n * @config {TestList} [testList]\n * @config {string} [outcome]\n * @config {date} [startTime]\n * @config {date} [endTime]\n * @config {number} [duration]\n * @config {string} [executionId]\n */\nTestRun.prototype.addResult = function (params) {\n\n  // generate a new executionId for this test\n  var executionId = params.executionId || uuid.v4()\n    , test = params.test\n    , computerName = params.computerName || this.computerName\n    , testList = params.testList || TestList.ResultsNotInAList\n    , outcome = params.outcome\n    , startTime = params.startTime\n    , endTime = params.endTime\n    , duration = params.duration\n    , output = params.output\n    , errorMessage = params.errorMessage\n    , errorStacktrace = params.errorStacktrace;\n\n  // add test definition\n  test.executionId = executionId;\n  this.testDefinitions.push(test);\n\n  // add a test entry\n  var testEntry = new TestEntry({\n    testId: test.id,\n    executionId: executionId,\n    testListId: testList.id\n  });\n  this.testEntries.push(testEntry);\n\n  // add a test result\n  var testResult = new UnitTestResult({\n    testName: test.name,\n    testType: test.type,\n    testId: test.id,\n    testListId: testList.id,\n    computerName: computerName,\n    outcome: outcome,\n    startTime: startTime,\n    endTime: endTime,\n    duration: duration,\n    output: output,\n    errorMessage: errorMessage,\n    errorStacktrace: errorStacktrace,\n    // visual studio usually uses the executionId as the relativeResultsDirectory\n    relativeResultsDirectory: params.relativeResultsDirectory || executionId \n  });\n  testResult.executionId = executionId;\n\n  // support for attachments. Useful for tests with Selenium or CodedUI\n  testResult.resultFiles = params.resultFiles || [];\n  this.testResults.push(testResult);\n\n  // increment the counter\n  this.counters.increment(outcome);\n\n  return this;\n}\n\n\n/**\n * Counter is defined by the XSD\n */\nfunction Counter() {\n  this.total = 0;\n  this.executed = 0;\n  this.passed = 0;\n  this.error = 0;\n  this.failed = 0;\n  this.timeout = 0;\n  this.aborted = 0;\n  this.inconclusive = 0;\n  this.passedButRunAborted = 0;\n  this.notRunnable = 0;\n  this.notExecuted = 0;\n  this.disconnected = 0;\n  this.warning = 0;\n  this.completed = 0;\n  this.inProgress = 0;\n  this.pending = 0;\n}\n\n/**\n * Increments the counter object values based on the outcome\n *\n * @param {string} outcome - outcome 'Passed', 'Failed', 'Inconclusive', 'Timeout', 'Pending', 'NotExecuted'\n */\nCounter.prototype.increment = function (outcome) {\n  this.total += 1;\n\n  switch (outcome) {\n    case 'Passed':\n      this.executed += 1;\n      this.passed += 1;\n      break;\n    case 'Failed':\n      this.executed += 1;\n      this.failed += 1;\n      break;\n    case 'Inconclusive':\n      this.executed += 1;\n      this.inconclusive += 1;\n      break;\n    case 'Timeout':\n      this.executed += 1;\n      this.timeout += 1;\n      break;\n    case 'Pending':\n      this.pending += 1;\n      break;\n    case 'NotExecuted':\n      this.notExecuted += 1;\n      break;\n  }\n}\n\n/**\n * A Times as defined by the XSD type `Times`\n *\n * @param {object} params\n * @config creation\n * @config queuing\n * @config start\n * @config finish\n */\nfunction Times(params) {\n  this.creation = params.creation;\n  this.queuing = params.queuing;\n  this.start = params.start;\n  this.finish = params.finish;\n}\n\n/**\n * A TestSetting as defined by the XSD type `TestSettingsType`\n *\n * @param {object} params\n * @config {string} name - name of the test settings\n * @config {string} id - guid identifier\n */\nfunction TestSettings(params) {\n  this.id = params.id;\n  this.name = params.name;\n}\n\n/**\n * A Deployment element as defined by the XSD type `Deployment`\n *\n * @param  {object} params\n * @config {string} [runDeploymentRoot] - name of the folder where any files generated by the tests will be located\n * @config {string} [userDeploymentRoot]\n * @config {string} [deploySatelliteAssemblies]\n * @config {string} [ignoredDependentAssemblies]\n * @config {string} [enabled]\n */\nfunction Deployment(params) {\n  this.runDeploymentRoot = params.runDeploymentRoot\n  this.userDeploymentRoot = params.userDeploymentRoot\n  this.deploySatelliteAssemblies = params.deploySatelliteAssemblies\n  this.ignoredDependentAssemblies = params.ignoredDependentAssemblies\n  this.enabled = params.enabled\n}\n\n/**\n * A TestList as defined by the XSD type `TestListType`\n *\n * @param {object} params\n * @config {string} name - name of the test list\n * @config {string} [id] - optional guid identifier that is generated if not supplied\n */\nfunction TestList(params) {\n  this.id = params.id || uuid.v4();\n  this.name = params.name;\n}\n\n\n/**\n * An Owner as defined by the XSD type `OwnerType`\n *\n * @param {object} params\n * @config {string} name - name of the owner\n */\nfunction Owner(params) {\n  this.name = params.name;\n}\n\n\n/**\n * System list for 'Results Not in a List'\n */\nTestList.ResultsNotInAList = new TestList({id: '8c84fa94-04c1-424b-9868-57a2d4851a1d', name: 'Results Not in a List'});\n\n/**\n * System list for 'All Loaded Results'\n */\nTestList.AllLoadedResults = new TestList({id: '19431567-8539-422a-85d7-44ee4e166bda', name: 'All Loaded Results'});\n\n\n/**\n * Represents a generic test definition and maps to the XSD type `GenericTestType`\n *\n * @param {object} params\n * @config {string} name\n * @config {string} methodName\n * @config {string} methodCodeBase\n * @config {string} methodClassName\n * @config {string} [id]\n * @config {Owner[]} owners\n */\nfunction UnitTest(params) {\n  this.id = params.id || uuid.v4();\n  this.name = params.name;\n  this.type = '13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b';\n  this.methodName = params.methodName;\n  this.methodCodeBase = params.methodCodeBase;\n  this.methodClassName = params.methodClassName;\n  this.owners = params.owners;\n  this.description = params.description;\n}\n\n\n/**\n * Represents a Test Result definition of the XSD type `UnitTestResultType`\n * which is used in the XSD type `ResultsType` collection.\n *\n * @param {object} params\n * @config {string} testName\n * @config {string} testType\n * @config {string} testId\n * @config {string} testListId\n * @config {string} computerName\n * @config {string} [outcome]\n * @config {string} [startTime]\n * @config {string} [endTime]\n * @config {string} [duration]\n * @config {string} [executionId]\n * @config {string} [relativeResultsDirectory]\n */\nfunction UnitTestResult(params) {\n  this.testName = params.testName;\n  this.testType = params.testType;\n  this.testId = params.testId;\n  this.testListId = params.testListId;\n  this.computerName = params.computerName;\n  this.outcome = params.outcome;\n  this.startTime = params.startTime;\n  this.endTime = params.endTime;\n  this.duration = params.duration;\n  this.executionId = params.executionId;\n  this.output = params.output;\n  this.errorMessage = params.errorMessage;\n  this.errorStacktrace = params.errorStacktrace;\n  this.relativeResultsDirectory = params.relativeResultsDirectory; \n}\n\n\n/**\n * Represents a Test Entry definition of the XSD type `TestEntryType`\n *\n * @param {object} params\n * @config {String} testID\n * @config {String} executionId\n * @config {String} testListId\n */\nfunction TestEntry(params) {\n  this.testId = params.testId;\n  this.executionId = params.executionId;\n  this.testListId = params.testListId;\n}\n\n\n/**\n * Represents a ResultFile definition of the XSD type `ResultFileType`\n * which is used in the XSD type `ResultFilesType` collection.\n *\n * @param {object} params\n * @config {string} path\n */\nfunction ResultFile(params) {\n  this.path = params.path;\n}\n\n/**\n * Exports\n */\n\nmodule.exports = {\n  TestRun: TestRun,\n  UnitTest: UnitTest,\n  TestList: TestList\n};\n\n\n//# sourceURL=webpack:///../node_modules/node-trx/trx.js?");

/***/ }),

/***/ "../node_modules/once/once.js":
/*!************************************!*\
  !*** ../node_modules/once/once.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"../node_modules/wrappy/wrappy.js\")\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n\n//# sourceURL=webpack:///../node_modules/once/once.js?");

/***/ }),

/***/ "../node_modules/os-tmpdir/index.js":
/*!******************************************!*\
  !*** ../node_modules/os-tmpdir/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar isWindows = process.platform === 'win32';\nvar trailingSlashRe = isWindows ? /[^:]\\\\$/ : /.\\/$/;\n\n// https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43\nmodule.exports = function () {\n\tvar path;\n\n\tif (isWindows) {\n\t\tpath = process.env.TEMP ||\n\t\t\tprocess.env.TMP ||\n\t\t\t(process.env.SystemRoot || process.env.windir) + '\\\\temp';\n\t} else {\n\t\tpath = process.env.TMPDIR ||\n\t\t\tprocess.env.TMP ||\n\t\t\tprocess.env.TEMP ||\n\t\t\t'/tmp';\n\t}\n\n\tif (trailingSlashRe.test(path)) {\n\t\tpath = path.slice(0, -1);\n\t}\n\n\treturn path;\n};\n\n\n//# sourceURL=webpack:///../node_modules/os-tmpdir/index.js?");

/***/ }),

/***/ "../node_modules/path-is-absolute/index.js":
/*!*************************************************!*\
  !*** ../node_modules/path-is-absolute/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n\n\n//# sourceURL=webpack:///../node_modules/path-is-absolute/index.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/bitmapper.js":
/*!**********************************************!*\
  !*** ../node_modules/pngjs/lib/bitmapper.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar interlaceUtils = __webpack_require__(/*! ./interlace */ \"../node_modules/pngjs/lib/interlace.js\");\n\nvar pixelBppMap = {\n  1: { // L\n    0: 0,\n    1: 0,\n    2: 0,\n    3: 0xff\n  },\n  2: { // LA\n    0: 0,\n    1: 0,\n    2: 0,\n    3: 1\n  },\n  3: { // RGB\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 0xff\n  },\n  4: { // RGBA\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3\n  }\n};\n\nfunction bitRetriever(data, depth) {\n\n  var leftOver = [];\n  var i = 0;\n\n  function split() {\n    if (i === data.length) {\n      throw new Error('Ran out of data');\n    }\n    var byte = data[i];\n    i++;\n    var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;\n    switch (depth) {\n      default:\n        throw new Error('unrecognised depth');\n      case 16:\n        byte2 = data[i];\n        i++;\n        leftOver.push(((byte << 8) + byte2));\n        break;\n      case 4:\n        byte2 = byte & 0x0f;\n        byte1 = byte >> 4;\n        leftOver.push(byte1, byte2);\n        break;\n      case 2:\n        byte4 = byte & 3;\n        byte3 = byte >> 2 & 3;\n        byte2 = byte >> 4 & 3;\n        byte1 = byte >> 6 & 3;\n        leftOver.push(byte1, byte2, byte3, byte4);\n        break;\n      case 1:\n        byte8 = byte & 1;\n        byte7 = byte >> 1 & 1;\n        byte6 = byte >> 2 & 1;\n        byte5 = byte >> 3 & 1;\n        byte4 = byte >> 4 & 1;\n        byte3 = byte >> 5 & 1;\n        byte2 = byte >> 6 & 1;\n        byte1 = byte >> 7 & 1;\n        leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);\n        break;\n    }\n  }\n\n  return {\n    get: function(count) {\n      while (leftOver.length < count) {\n        split();\n      }\n      var returner = leftOver.slice(0, count);\n      leftOver = leftOver.slice(count);\n      return returner;\n    },\n    resetAfterLine: function() {\n      leftOver.length = 0;\n    },\n    end: function() {\n      if (i !== data.length) {\n        throw new Error('extra data found');\n      }\n    }\n  };\n}\n\nfunction mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) { // eslint-disable-line max-params\n  var imageWidth = image.width;\n  var imageHeight = image.height;\n  var imagePass = image.index;\n  for (var y = 0; y < imageHeight; y++) {\n    for (var x = 0; x < imageWidth; x++) {\n      var pxPos = getPxPos(x, y, imagePass);\n\n      for (var i = 0; i < 4; i++) {\n        var idx = pixelBppMap[bpp][i];\n        if (idx === 0xff) {\n          pxData[pxPos + i] = 0xff;\n        } else {\n          var dataPos = idx + rawPos;\n          if (dataPos === data.length) {\n            throw new Error('Ran out of data');\n          }\n          pxData[pxPos + i] = data[dataPos];\n        }\n      }\n      rawPos += bpp; //eslint-disable-line no-param-reassign\n    }\n  }\n  return rawPos;\n}\n\nfunction mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) { // eslint-disable-line max-params\n  var imageWidth = image.width;\n  var imageHeight = image.height;\n  var imagePass = image.index;\n  for (var y = 0; y < imageHeight; y++) {\n    for (var x = 0; x < imageWidth; x++) {\n      var pixelData = bits.get(bpp);\n      var pxPos = getPxPos(x, y, imagePass);\n\n      for (var i = 0; i < 4; i++) {\n        var idx = pixelBppMap[bpp][i];\n        pxData[pxPos + i] = idx !== 0xff ? pixelData[idx] : maxBit;\n      }\n    }\n    bits.resetAfterLine();\n  }\n}\n\nexports.dataToBitMap = function(data, bitmapInfo) {\n\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var depth = bitmapInfo.depth;\n  var bpp = bitmapInfo.bpp;\n  var interlace = bitmapInfo.interlace;\n\n  if (depth !== 8) {\n    var bits = bitRetriever(data, depth);\n  }\n  var pxData;\n  if (depth <= 8) {\n    pxData = new Buffer(width * height * 4);\n  }\n  else {\n    pxData = new Uint16Array(width * height * 4);\n  }\n  var maxBit = Math.pow(2, depth) - 1;\n  var rawPos = 0;\n  var images;\n  var getPxPos;\n\n  if (interlace) {\n    images = interlaceUtils.getImagePasses(width, height);\n    getPxPos = interlaceUtils.getInterlaceIterator(width, height);\n  }\n  else {\n    var nonInterlacedPxPos = 0;\n    getPxPos = function() {\n      var returner = nonInterlacedPxPos;\n      nonInterlacedPxPos += 4;\n      return returner;\n    };\n    images = [{ width: width, height: height }];\n  }\n\n  for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {\n    if (depth === 8) {\n      rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);\n    }\n    else {\n      mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);\n    }\n  }\n  if (depth === 8) {\n    if (rawPos !== data.length) {\n      throw new Error('extra data found');\n    }\n  }\n  else {\n    bits.end();\n  }\n\n  return pxData;\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/bitmapper.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/bitpacker.js":
/*!**********************************************!*\
  !*** ../node_modules/pngjs/lib/bitpacker.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar constants = __webpack_require__(/*! ./constants */ \"../node_modules/pngjs/lib/constants.js\");\n\nmodule.exports = function(dataIn, width, height, options) {\n  var outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;\n  if (options.colorType === options.inputColorType) {\n    var bigEndian = (function() {\n      var buffer = new ArrayBuffer(2);\n      new DataView(buffer).setInt16(0, 256, true /* littleEndian */);\n      // Int16Array uses the platform's endianness.\n      return new Int16Array(buffer)[0] !== 256;\n    })();\n    // If no need to convert to grayscale and alpha is present/absent in both, take a fast route\n     if (options.bitDepth === 8 || (options.bitDepth === 16 && bigEndian)){\n         return dataIn;\n    }\n  }\n\n  // map to a UInt16 array if data is 16bit, fix endianness below\n  var data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);\n\n  var maxValue = 255;\n  var inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];\n  if (inBpp == 4 && !options.inputHasAlpha) inBpp = 3;\n  var outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];\n  if (options.bitDepth === 16) {\n    maxValue = 65535;\n    outBpp *= 2;\n  }\n  var outData = new Buffer(width * height * outBpp);\n\n  var inIndex = 0;\n  var outIndex = 0;\n\n  var bgColor = options.bgColor || {};\n  if (bgColor.red === undefined) {\n    bgColor.red = maxValue;\n  }\n  if (bgColor.green === undefined) {\n    bgColor.green = maxValue;\n  }\n  if (bgColor.blue === undefined) {\n    bgColor.blue = maxValue;\n  }\n\n  function getRGBA(data, inIndex) {\n    var red, green, blue, alpha = maxValue;\n    switch (options.inputColorType) {\n      case constants.COLORTYPE_COLOR_ALPHA:\n        alpha = data[inIndex + 3];\n        red = data[inIndex];\n        green = data[inIndex+1];\n        blue = data[inIndex+2];\n        break;\n      case constants.COLORTYPE_COLOR:\n        red = data[inIndex];\n        green = data[inIndex+1];\n        blue = data[inIndex+2];\n        break;\n      case constants.COLORTYPE_ALPHA:\n        alpha = data[inIndex + 1];\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n      case constants.COLORTYPE_GRAYSCALE:\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n      default:\n        throw new Error('input color type:' + options.inputColorType + ' is not supported at present');\n    }\n\n    if (options.inputHasAlpha) {\n      if (!outHasAlpha) {\n        alpha /= maxValue;\n        red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);\n        green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);\n        blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);\n      }\n    }\n    return {red: red, green: green, blue: blue, alpha: alpha};\n  }\n\n  for (var y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++) {\n      var rgba = getRGBA(data, inIndex);\n\n      switch (options.colorType) {\n        case constants.COLORTYPE_COLOR_ALPHA:\n        case constants.COLORTYPE_COLOR:\n          if (options.bitDepth === 8) {\n            outData[outIndex] = rgba.red;\n            outData[outIndex + 1] = rgba.green;\n            outData[outIndex + 2] = rgba.blue;\n            if (outHasAlpha) {\n              outData[outIndex + 3] = rgba.alpha;\n            }\n          } else {\n            outData.writeUInt16BE(rgba.red, outIndex);\n            outData.writeUInt16BE(rgba.green, outIndex + 2);\n            outData.writeUInt16BE(rgba.blue, outIndex + 4);\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 6);\n            }\n          }\n          break;\n        case constants.COLORTYPE_ALPHA:\n        case constants.COLORTYPE_GRAYSCALE:\n          // Convert to grayscale and alpha\n          var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;\n          if (options.bitDepth === 8) {\n            outData[outIndex] = grayscale;\n            if (outHasAlpha) {\n              outData[outIndex + 1] = rgba.alpha;\n            }\n          } else {\n            outData.writeUInt16BE(grayscale, outIndex);\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 2);\n            }\n          }\n          break;\n      }\n\n      inIndex += inBpp;\n      outIndex += outBpp;\n    }\n  }\n\n  return outData;\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/bitpacker.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/chunkstream.js":
/*!************************************************!*\
  !*** ../node_modules/pngjs/lib/chunkstream.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\n\n\nvar ChunkStream = module.exports = function() {\n  Stream.call(this);\n\n  this._buffers = [];\n  this._buffered = 0;\n\n  this._reads = [];\n  this._paused = false;\n\n  this._encoding = 'utf8';\n  this.writable = true;\n};\nutil.inherits(ChunkStream, Stream);\n\n\nChunkStream.prototype.read = function(length, callback) {\n\n  this._reads.push({\n    length: Math.abs(length),  // if length < 0 then at most this length\n    allowLess: length < 0,\n    func: callback\n  });\n\n  process.nextTick(function() {\n    this._process();\n\n    // its paused and there is not enought data then ask for more\n    if (this._paused && this._reads.length > 0) {\n      this._paused = false;\n\n      this.emit('drain');\n    }\n  }.bind(this));\n};\n\nChunkStream.prototype.write = function(data, encoding) {\n\n  if (!this.writable) {\n    this.emit('error', new Error('Stream not writable'));\n    return false;\n  }\n\n  var dataBuffer;\n  if (Buffer.isBuffer(data)) {\n    dataBuffer = data;\n  }\n  else {\n    dataBuffer = new Buffer(data, encoding || this._encoding);\n  }\n\n  this._buffers.push(dataBuffer);\n  this._buffered += dataBuffer.length;\n\n  this._process();\n\n  // ok if there are no more read requests\n  if (this._reads && this._reads.length === 0) {\n    this._paused = true;\n  }\n\n  return this.writable && !this._paused;\n};\n\nChunkStream.prototype.end = function(data, encoding) {\n\n  if (data) {\n    this.write(data, encoding);\n  }\n\n  this.writable = false;\n\n  // already destroyed\n  if (!this._buffers) {\n    return;\n  }\n\n  // enqueue or handle end\n  if (this._buffers.length === 0) {\n    this._end();\n  }\n  else {\n    this._buffers.push(null);\n    this._process();\n  }\n};\n\nChunkStream.prototype.destroySoon = ChunkStream.prototype.end;\n\nChunkStream.prototype._end = function() {\n\n  if (this._reads.length > 0) {\n    this.emit('error',\n      new Error('There are some read requests waiting on finished stream')\n    );\n  }\n\n  this.destroy();\n};\n\nChunkStream.prototype.destroy = function() {\n\n  if (!this._buffers) {\n    return;\n  }\n\n  this.writable = false;\n  this._reads = null;\n  this._buffers = null;\n\n  this.emit('close');\n};\n\nChunkStream.prototype._processReadAllowingLess = function(read) {\n  // ok there is any data so that we can satisfy this request\n  this._reads.shift(); // == read\n\n  // first we need to peek into first buffer\n  var smallerBuf = this._buffers[0];\n\n  // ok there is more data than we need\n  if (smallerBuf.length > read.length) {\n\n    this._buffered -= read.length;\n    this._buffers[0] = smallerBuf.slice(read.length);\n\n    read.func.call(this, smallerBuf.slice(0, read.length));\n\n  }\n  else {\n    // ok this is less than maximum length so use it all\n    this._buffered -= smallerBuf.length;\n    this._buffers.shift(); // == smallerBuf\n\n    read.func.call(this, smallerBuf);\n  }\n};\n\nChunkStream.prototype._processRead = function(read) {\n  this._reads.shift(); // == read\n\n  var pos = 0;\n  var count = 0;\n  var data = new Buffer(read.length);\n\n  // create buffer for all data\n  while (pos < read.length) {\n\n    var buf = this._buffers[count++];\n    var len = Math.min(buf.length, read.length - pos);\n\n    buf.copy(data, pos, 0, len);\n    pos += len;\n\n    // last buffer wasn't used all so just slice it and leave\n    if (len !== buf.length) {\n      this._buffers[--count] = buf.slice(len);\n    }\n  }\n\n  // remove all used buffers\n  if (count > 0) {\n    this._buffers.splice(0, count);\n  }\n\n  this._buffered -= read.length;\n\n  read.func.call(this, data);\n};\n\nChunkStream.prototype._process = function() {\n\n  try {\n    // as long as there is any data and read requests\n    while (this._buffered > 0 && this._reads && this._reads.length > 0) {\n\n      var read = this._reads[0];\n\n      // read any data (but no more than length)\n      if (read.allowLess) {\n        this._processReadAllowingLess(read);\n\n      }\n      else if (this._buffered >= read.length) {\n        // ok we can meet some expectations\n\n        this._processRead(read);\n      }\n      else {\n        // not enought data to satisfy first request in queue\n        // so we need to wait for more\n        break;\n      }\n    }\n\n    if (this._buffers && this._buffers.length > 0 && this._buffers[0] === null) {\n      this._end();\n    }\n  }\n  catch (ex) {\n    this.emit('error', ex);\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/chunkstream.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/constants.js":
/*!**********************************************!*\
  !*** ../node_modules/pngjs/lib/constants.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = {\n\n  PNG_SIGNATURE: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],\n\n  TYPE_IHDR: 0x49484452,\n  TYPE_IEND: 0x49454e44,\n  TYPE_IDAT: 0x49444154,\n  TYPE_PLTE: 0x504c5445,\n  TYPE_tRNS: 0x74524e53, // eslint-disable-line camelcase\n  TYPE_gAMA: 0x67414d41, // eslint-disable-line camelcase\n\n  // color-type bits\n  COLORTYPE_GRAYSCALE: 0,\n  COLORTYPE_PALETTE: 1,\n  COLORTYPE_COLOR: 2,\n  COLORTYPE_ALPHA: 4, // e.g. grayscale and alpha\n\n  // color-type combinations\n  COLORTYPE_PALETTE_COLOR: 3,\n  COLORTYPE_COLOR_ALPHA: 6,\n\n  COLORTYPE_TO_BPP_MAP: {\n    0: 1,\n    2: 3,\n    3: 1,\n    4: 2,\n    6: 4\n  },\n\n  GAMMA_DIVISION: 100000\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/constants.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/crc.js":
/*!****************************************!*\
  !*** ../node_modules/pngjs/lib/crc.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar crcTable = [];\n\n(function() {\n  for (var i = 0; i < 256; i++) {\n    var currentCrc = i;\n    for (var j = 0; j < 8; j++) {\n      if (currentCrc & 1) {\n        currentCrc = 0xedb88320 ^ (currentCrc >>> 1);\n      }\n      else {\n        currentCrc = currentCrc >>> 1;\n      }\n    }\n    crcTable[i] = currentCrc;\n  }\n}());\n\nvar CrcCalculator = module.exports = function() {\n  this._crc = -1;\n};\n\nCrcCalculator.prototype.write = function(data) {\n\n  for (var i = 0; i < data.length; i++) {\n    this._crc = crcTable[(this._crc ^ data[i]) & 0xff] ^ (this._crc >>> 8);\n  }\n  return true;\n};\n\nCrcCalculator.prototype.crc32 = function() {\n  return this._crc ^ -1;\n};\n\n\nCrcCalculator.crc32 = function(buf) {\n\n  var crc = -1;\n  for (var i = 0; i < buf.length; i++) {\n    crc = crcTable[(crc ^ buf[i]) & 0xff] ^ (crc >>> 8);\n  }\n  return crc ^ -1;\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/crc.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/filter-pack.js":
/*!************************************************!*\
  !*** ../node_modules/pngjs/lib/filter-pack.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar paethPredictor = __webpack_require__(/*! ./paeth-predictor */ \"../node_modules/pngjs/lib/paeth-predictor.js\");\n\nfunction filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {\n\n  for (var x = 0; x < byteWidth; x++) {    \n    rawData[rawPos + x] = pxData[pxPos + x];\n  }\n}\n\nfunction filterSumNone(pxData, pxPos, byteWidth) {\n\n  var sum = 0;\n  var length = pxPos + byteWidth;\n\n  for (var i = pxPos; i < length; i++) {\n    sum += Math.abs(pxData[i]);\n  }\n  return sum;\n}\n\nfunction filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {\n\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var val = pxData[pxPos + x] - left;\n\n    rawData[rawPos + x] = val;\n  }\n}\n\nfunction filterSumSub(pxData, pxPos, byteWidth, bpp) {\n\n  var sum = 0;\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var val = pxData[pxPos + x] - left;\n\n    sum += Math.abs(val);\n  }\n\n  return sum;\n}\n\nfunction filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {\n\n  for (var x = 0; x < byteWidth; x++) {\n\n    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;\n    var val = pxData[pxPos + x] - up;\n\n    rawData[rawPos + x] = val;\n  }\n}\n\nfunction filterSumUp(pxData, pxPos, byteWidth) {\n\n  var sum = 0;\n  var length = pxPos + byteWidth;\n  for (var x = pxPos; x < length; x++) {\n\n    var up = pxPos > 0 ? pxData[x - byteWidth] : 0;\n    var val = pxData[x] - up;\n\n    sum += Math.abs(val);\n  }\n\n  return sum;\n}\n\nfunction filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {\n\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;\n    var val = pxData[pxPos + x] - ((left + up) >> 1);\n\n    rawData[rawPos + x] = val;\n  }\n}\n\nfunction filterSumAvg(pxData, pxPos, byteWidth, bpp) {\n\n  var sum = 0;\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;\n    var val = pxData[pxPos + x] - ((left + up) >> 1);\n\n    sum += Math.abs(val);\n  }\n\n  return sum;\n}\n\nfunction filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {\n\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;\n    var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;\n    var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);\n\n    rawData[rawPos + x] = val;\n  }\n}\n\nfunction filterSumPaeth(pxData, pxPos, byteWidth, bpp) {\n  var sum = 0;\n  for (var x = 0; x < byteWidth; x++) {\n\n    var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;\n    var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;\n    var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;\n    var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);\n\n    sum += Math.abs(val);\n  }\n\n  return sum;\n}\n\nvar filters = {\n  0: filterNone,\n  1: filterSub,\n  2: filterUp,\n  3: filterAvg,\n  4: filterPaeth\n};\n\nvar filterSums = {\n  0: filterSumNone,\n  1: filterSumSub,\n  2: filterSumUp,\n  3: filterSumAvg,\n  4: filterSumPaeth\n};\n\nmodule.exports = function(pxData, width, height, options, bpp) {\n\n  var filterTypes;\n  if (!('filterType' in options) || options.filterType === -1) {\n    filterTypes = [0, 1, 2, 3, 4];\n  }\n  else if (typeof options.filterType === 'number') {\n    filterTypes = [options.filterType];\n  }\n  else {\n    throw new Error('unrecognised filter types');\n  }\n\n  if (options.bitDepth === 16) bpp *= 2;\n  var byteWidth = width * bpp;\n  var rawPos = 0;\n  var pxPos = 0;\n  var rawData = new Buffer((byteWidth + 1) * height);\n\n  var sel = filterTypes[0];\n\n  for (var y = 0; y < height; y++) {\n\n    if (filterTypes.length > 1) {\n      // find best filter for this line (with lowest sum of values)\n      var min = Infinity;\n\n      for (var i = 0; i < filterTypes.length; i++) {\n        var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);\n        if (sum < min) {\n          sel = filterTypes[i];\n          min = sum;\n        }\n      }\n    }\n\n    rawData[rawPos] = sel;\n    rawPos++;\n    filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);\n    rawPos += byteWidth;\n    pxPos += byteWidth;\n  }\n  return rawData;\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/filter-pack.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/filter-parse-async.js":
/*!*******************************************************!*\
  !*** ../node_modules/pngjs/lib/filter-parse-async.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar ChunkStream = __webpack_require__(/*! ./chunkstream */ \"../node_modules/pngjs/lib/chunkstream.js\");\nvar Filter = __webpack_require__(/*! ./filter-parse */ \"../node_modules/pngjs/lib/filter-parse.js\");\n\n\nvar FilterAsync = module.exports = function(bitmapInfo) {\n  ChunkStream.call(this);\n\n  var buffers = [];\n  var that = this;\n  this._filter = new Filter(bitmapInfo, {\n    read: this.read.bind(this),\n    write: function(buffer) {\n      buffers.push(buffer);\n    },\n    complete: function() {\n      that.emit('complete', Buffer.concat(buffers));\n    }\n  });\n\n  this._filter.start();\n};\nutil.inherits(FilterAsync, ChunkStream);\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/filter-parse-async.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/filter-parse-sync.js":
/*!******************************************************!*\
  !*** ../node_modules/pngjs/lib/filter-parse-sync.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar SyncReader = __webpack_require__(/*! ./sync-reader */ \"../node_modules/pngjs/lib/sync-reader.js\");\nvar Filter = __webpack_require__(/*! ./filter-parse */ \"../node_modules/pngjs/lib/filter-parse.js\");\n\n\nexports.process = function(inBuffer, bitmapInfo) {\n\n  var outBuffers = [];\n  var reader = new SyncReader(inBuffer);\n  var filter = new Filter(bitmapInfo, {\n    read: reader.read.bind(reader),\n    write: function(bufferPart) {\n      outBuffers.push(bufferPart);\n    },\n    complete: function() {\n    }\n  });\n\n  filter.start();\n  reader.process();\n\n  return Buffer.concat(outBuffers);\n};\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/filter-parse-sync.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/filter-parse.js":
/*!*************************************************!*\
  !*** ../node_modules/pngjs/lib/filter-parse.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar interlaceUtils = __webpack_require__(/*! ./interlace */ \"../node_modules/pngjs/lib/interlace.js\");\nvar paethPredictor = __webpack_require__(/*! ./paeth-predictor */ \"../node_modules/pngjs/lib/paeth-predictor.js\");\n\nfunction getByteWidth(width, bpp, depth) {\n  var byteWidth = width * bpp;\n  if (depth !== 8) {\n    byteWidth = Math.ceil(byteWidth / (8 / depth));\n  }\n  return byteWidth;\n}\n\nvar Filter = module.exports = function(bitmapInfo, dependencies) {\n\n  var width = bitmapInfo.width;\n  var height = bitmapInfo.height;\n  var interlace = bitmapInfo.interlace;\n  var bpp = bitmapInfo.bpp;\n  var depth = bitmapInfo.depth;\n\n  this.read = dependencies.read;\n  this.write = dependencies.write;\n  this.complete = dependencies.complete;\n\n  this._imageIndex = 0;\n  this._images = [];\n  if (interlace) {\n    var passes = interlaceUtils.getImagePasses(width, height);\n    for (var i = 0; i < passes.length; i++) {\n      this._images.push({\n        byteWidth: getByteWidth(passes[i].width, bpp, depth),\n        height: passes[i].height,\n        lineIndex: 0\n      });\n    }\n  }\n  else {\n    this._images.push({\n      byteWidth: getByteWidth(width, bpp, depth),\n      height: height,\n      lineIndex: 0\n    });\n  }\n\n  // when filtering the line we look at the pixel to the left\n  // the spec also says it is done on a byte level regardless of the number of pixels\n  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back\n  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.\n  if (depth === 8) {\n    this._xComparison = bpp;\n  }\n  else if (depth === 16) {\n    this._xComparison = bpp * 2;\n  }\n  else {\n    this._xComparison = 1;\n  }\n};\n\nFilter.prototype.start = function() {\n  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));\n};\n\nFilter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    unfilteredLine[x] = rawByte + f1Left;\n  }\n};\n\nFilter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {\n\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f2Up = lastLine ? lastLine[x] : 0;\n    unfilteredLine[x] = rawByte + f2Up;\n  }\n};\n\nFilter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f3Up = lastLine ? lastLine[x] : 0;\n    var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f3Add = Math.floor((f3Left + f3Up) / 2);\n    unfilteredLine[x] = rawByte + f3Add;\n  }\n};\n\nFilter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {\n\n  var xComparison = this._xComparison;\n  var xBiggerThan = xComparison - 1;\n  var lastLine = this._lastLine;\n\n  for (var x = 0; x < byteWidth; x++) {\n    var rawByte = rawData[1 + x];\n    var f4Up = lastLine ? lastLine[x] : 0;\n    var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;\n    var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);\n    unfilteredLine[x] = rawByte + f4Add;\n  }\n};\n\nFilter.prototype._reverseFilterLine = function(rawData) {\n\n  var filter = rawData[0];\n  var unfilteredLine;\n  var currentImage = this._images[this._imageIndex];\n  var byteWidth = currentImage.byteWidth;\n\n  if (filter === 0) {\n    unfilteredLine = rawData.slice(1, byteWidth + 1);\n  }\n  else {\n\n    unfilteredLine = new Buffer(byteWidth);\n\n    switch (filter) {\n      case 1:\n        this._unFilterType1(rawData, unfilteredLine, byteWidth);\n        break;\n      case 2:\n        this._unFilterType2(rawData, unfilteredLine, byteWidth);\n        break;\n      case 3:\n        this._unFilterType3(rawData, unfilteredLine, byteWidth);\n        break;\n      case 4:\n        this._unFilterType4(rawData, unfilteredLine, byteWidth);\n        break;\n      default:\n        throw new Error('Unrecognised filter type - ' + filter);\n    }\n  }\n\n  this.write(unfilteredLine);\n\n  currentImage.lineIndex++;\n  if (currentImage.lineIndex >= currentImage.height) {\n    this._lastLine = null;\n    this._imageIndex++;\n    currentImage = this._images[this._imageIndex];\n  }\n  else {\n    this._lastLine = unfilteredLine;\n  }\n\n  if (currentImage) {\n    // read, using the byte width that may be from the new current image\n    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));\n  }\n  else {\n    this._lastLine = null;\n    this.complete();\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/filter-parse.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/format-normaliser.js":
/*!******************************************************!*\
  !*** ../node_modules/pngjs/lib/format-normaliser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction dePalette(indata, outdata, width, height, palette) {\n  var pxPos = 0;\n  // use values from palette\n  for (var y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++) {\n      var color = palette[indata[pxPos]];\n\n      if (!color) {\n        throw new Error('index ' + indata[pxPos] + ' not in palette');\n      }\n\n      for (var i = 0; i < 4; i++) {\n        outdata[pxPos + i] = color[i];\n      }\n      pxPos += 4;\n    }\n  }\n}\n\nfunction replaceTransparentColor(indata, outdata, width, height, transColor) {\n  var pxPos = 0;\n  for (var y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++) {\n      var makeTrans = false;\n\n      if (transColor.length === 1) {\n        if (transColor[0] === indata[pxPos]) {\n          makeTrans = true;\n        }\n      }\n      else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {\n        makeTrans = true;\n      }\n      if (makeTrans) {\n        for (var i = 0; i < 4; i++) {\n          outdata[pxPos + i] = 0;\n        }\n      }\n      pxPos += 4;\n    }\n  }\n}\n\nfunction scaleDepth(indata, outdata, width, height, depth) {\n  var maxOutSample = 255;\n  var maxInSample = Math.pow(2, depth) - 1;\n  var pxPos = 0;\n\n  for (var y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++) {\n      for (var i = 0; i < 4; i++) {\n        outdata[pxPos + i] = Math.floor((indata[pxPos + i] * maxOutSample) / maxInSample + 0.5);\n      }\n      pxPos += 4;\n    }\n  }\n}\n\nmodule.exports = function(indata, imageData) {\n\n  var depth = imageData.depth;\n  var width = imageData.width;\n  var height = imageData.height;\n  var colorType = imageData.colorType;\n  var transColor = imageData.transColor;\n  var palette = imageData.palette;\n\n  var outdata = indata; // only different for 16 bits\n\n  if (colorType === 3) { // paletted\n    dePalette(indata, outdata, width, height, palette);\n  }\n  else {\n    if (transColor) {\n      replaceTransparentColor(indata, outdata, width, height, transColor);\n    }\n    // if it needs scaling\n    if (depth !== 8) {\n      // if we need to change the buffer size\n      if (depth === 16) {\n        outdata = new Buffer(width * height * 4);\n      }\n      scaleDepth(indata, outdata, width, height, depth);\n    }\n  }\n  return outdata;\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/format-normaliser.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/interlace.js":
/*!**********************************************!*\
  !*** ../node_modules/pngjs/lib/interlace.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Adam 7\n//   0 1 2 3 4 5 6 7\n// 0 x 6 4 6 x 6 4 6\n// 1 7 7 7 7 7 7 7 7\n// 2 5 6 5 6 5 6 5 6\n// 3 7 7 7 7 7 7 7 7\n// 4 3 6 4 6 3 6 4 6\n// 5 7 7 7 7 7 7 7 7\n// 6 5 6 5 6 5 6 5 6\n// 7 7 7 7 7 7 7 7 7\n\n\nvar imagePasses = [\n  { // pass 1 - 1px\n    x: [0],\n    y: [0]\n  },\n  { // pass 2 - 1px\n    x: [4],\n    y: [0]\n  },\n  { // pass 3 - 2px\n    x: [0, 4],\n    y: [4]\n  },\n  { // pass 4 - 4px\n    x: [2, 6],\n    y: [0, 4]\n  },\n  { // pass 5 - 8px\n    x: [0, 2, 4, 6],\n    y: [2, 6]\n  },\n  { // pass 6 - 16px\n    x: [1, 3, 5, 7],\n    y: [0, 2, 4, 6]\n  },\n  { // pass 7 - 32px\n    x: [0, 1, 2, 3, 4, 5, 6, 7],\n    y: [1, 3, 5, 7]\n  }\n];\n\nexports.getImagePasses = function(width, height) {\n  var images = [];\n  var xLeftOver = width % 8;\n  var yLeftOver = height % 8;\n  var xRepeats = (width - xLeftOver) / 8;\n  var yRepeats = (height - yLeftOver) / 8;\n  for (var i = 0; i < imagePasses.length; i++) {\n    var pass = imagePasses[i];\n    var passWidth = xRepeats * pass.x.length;\n    var passHeight = yRepeats * pass.y.length;\n    for (var j = 0; j < pass.x.length; j++) {\n      if (pass.x[j] < xLeftOver) {\n        passWidth++;\n      }\n      else {\n        break;\n      }\n    }\n    for (j = 0; j < pass.y.length; j++) {\n      if (pass.y[j] < yLeftOver) {\n        passHeight++;\n      }\n      else {\n        break;\n      }\n    }\n    if (passWidth > 0 && passHeight > 0) {\n      images.push({ width: passWidth, height: passHeight, index: i });\n    }\n  }\n  return images;\n};\n\nexports.getInterlaceIterator = function(width) {\n  return function(x, y, pass) {\n    var outerXLeftOver = x % imagePasses[pass].x.length;\n    var outerX = (((x - outerXLeftOver) / imagePasses[pass].x.length) * 8) + imagePasses[pass].x[outerXLeftOver];\n    var outerYLeftOver = y % imagePasses[pass].y.length;\n    var outerY = (((y - outerYLeftOver) / imagePasses[pass].y.length) * 8) + imagePasses[pass].y[outerYLeftOver];\n    return (outerX * 4) + (outerY * width * 4);\n  };\n};\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/interlace.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/packer-async.js":
/*!*************************************************!*\
  !*** ../node_modules/pngjs/lib/packer-async.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\nvar constants = __webpack_require__(/*! ./constants */ \"../node_modules/pngjs/lib/constants.js\");\nvar Packer = __webpack_require__(/*! ./packer */ \"../node_modules/pngjs/lib/packer.js\");\n\nvar PackerAsync = module.exports = function(opt) {\n  Stream.call(this);\n\n  var options = opt || {};\n\n  this._packer = new Packer(options);\n  this._deflate = this._packer.createDeflate();\n\n  this.readable = true;\n};\nutil.inherits(PackerAsync, Stream);\n\n\nPackerAsync.prototype.pack = function(data, width, height, gamma) {\n  // Signature\n  this.emit('data', new Buffer(constants.PNG_SIGNATURE));\n  this.emit('data', this._packer.packIHDR(width, height));\n\n  if (gamma) {\n    this.emit('data', this._packer.packGAMA(gamma));\n  }\n\n  var filteredData = this._packer.filterData(data, width, height);\n\n  // compress it\n  this._deflate.on('error', this.emit.bind(this, 'error'));\n\n  this._deflate.on('data', function(compressedData) {\n    this.emit('data', this._packer.packIDAT(compressedData));\n  }.bind(this));\n\n  this._deflate.on('end', function() {\n    this.emit('data', this._packer.packIEND());\n    this.emit('end');\n  }.bind(this));\n\n  this._deflate.end(filteredData);\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/packer-async.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/packer-sync.js":
/*!************************************************!*\
  !*** ../node_modules/pngjs/lib/packer-sync.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar hasSyncZlib = true;\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\nif (!zlib.deflateSync) {\n  hasSyncZlib = false;\n}\nvar constants = __webpack_require__(/*! ./constants */ \"../node_modules/pngjs/lib/constants.js\");\nvar Packer = __webpack_require__(/*! ./packer */ \"../node_modules/pngjs/lib/packer.js\");\n\nmodule.exports = function(metaData, opt) {\n\n  if (!hasSyncZlib) {\n    throw new Error('To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0');\n  }\n\n  var options = opt || {};\n\n  var packer = new Packer(options);\n\n  var chunks = [];\n\n  // Signature\n  chunks.push(new Buffer(constants.PNG_SIGNATURE));\n\n  // Header\n  chunks.push(packer.packIHDR(metaData.width, metaData.height));\n\n  if (metaData.gamma) {\n    chunks.push(packer.packGAMA(metaData.gamma));\n  }\n\n  var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);\n\n  // compress it\n  var compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());\n  filteredData = null;\n\n  if (!compressedData || !compressedData.length) {\n    throw new Error('bad png - invalid compressed data response');\n  }\n  chunks.push(packer.packIDAT(compressedData));\n\n  // End\n  chunks.push(packer.packIEND());\n\n  return Buffer.concat(chunks);\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/packer-sync.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/packer.js":
/*!*******************************************!*\
  !*** ../node_modules/pngjs/lib/packer.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar constants = __webpack_require__(/*! ./constants */ \"../node_modules/pngjs/lib/constants.js\");\nvar CrcStream = __webpack_require__(/*! ./crc */ \"../node_modules/pngjs/lib/crc.js\");\nvar bitPacker = __webpack_require__(/*! ./bitpacker */ \"../node_modules/pngjs/lib/bitpacker.js\");\nvar filter = __webpack_require__(/*! ./filter-pack */ \"../node_modules/pngjs/lib/filter-pack.js\");\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nvar Packer = module.exports = function(options) {\n  this._options = options;\n\n  options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;\n  options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;\n  options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;\n  options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;\n  options.deflateFactory = options.deflateFactory || zlib.createDeflate;\n  options.bitDepth = options.bitDepth || 8;\n  // This is outputColorType\n  options.colorType = (typeof options.colorType === 'number') ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;\n  options.inputColorType = (typeof options.inputColorType === 'number') ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;\n\n  if ([\n    constants.COLORTYPE_GRAYSCALE,\n    constants.COLORTYPE_COLOR,\n    constants.COLORTYPE_COLOR_ALPHA,\n    constants.COLORTYPE_ALPHA\n  ].indexOf(options.colorType) === -1) {\n    throw new Error('option color type:' + options.colorType + ' is not supported at present');\n  }\n  if ([\n    constants.COLORTYPE_GRAYSCALE,\n    constants.COLORTYPE_COLOR,\n    constants.COLORTYPE_COLOR_ALPHA,\n    constants.COLORTYPE_ALPHA\n  ].indexOf(options.inputColorType) === -1) {\n    throw new Error('option input color type:' + options.inputColorType + ' is not supported at present');\n  }\n  if (options.bitDepth !== 8 && options.bitDepth !== 16) {\n    throw new Error('option bit depth:' + options.bitDepth + ' is not supported at present');\n  }\n};\n\nPacker.prototype.getDeflateOptions = function() {\n  return {\n    chunkSize: this._options.deflateChunkSize,\n    level: this._options.deflateLevel,\n    strategy: this._options.deflateStrategy\n  };\n};\n\nPacker.prototype.createDeflate = function() {\n  return this._options.deflateFactory(this.getDeflateOptions());\n};\n\nPacker.prototype.filterData = function(data, width, height) {\n  // convert to correct format for filtering (e.g. right bpp and bit depth)\n  var packedData = bitPacker(data, width, height, this._options);\n\n  // filter pixel data\n  var bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];\n  var filteredData = filter(packedData, width, height, this._options, bpp);\n  return filteredData;\n};\n\nPacker.prototype._packChunk = function(type, data) {\n\n  var len = (data ? data.length : 0);\n  var buf = new Buffer(len + 12);\n\n  buf.writeUInt32BE(len, 0);\n  buf.writeUInt32BE(type, 4);\n\n  if (data) {\n    data.copy(buf, 8);\n  }\n\n  buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);\n  return buf;\n};\n\nPacker.prototype.packGAMA = function(gamma) {\n  var buf = new Buffer(4);\n  buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);\n  return this._packChunk(constants.TYPE_gAMA, buf);\n};\n\nPacker.prototype.packIHDR = function(width, height) {\n\n  var buf = new Buffer(13);\n  buf.writeUInt32BE(width, 0);\n  buf.writeUInt32BE(height, 4);\n  buf[8] = this._options.bitDepth; // Bit depth\n  buf[9] = this._options.colorType; // colorType\n  buf[10] = 0; // compression\n  buf[11] = 0; // filter\n  buf[12] = 0; // interlace\n\n  return this._packChunk(constants.TYPE_IHDR, buf);\n};\n\nPacker.prototype.packIDAT = function(data) {\n  return this._packChunk(constants.TYPE_IDAT, data);\n};\n\nPacker.prototype.packIEND = function() {\n  return this._packChunk(constants.TYPE_IEND, null);\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/packer.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/paeth-predictor.js":
/*!****************************************************!*\
  !*** ../node_modules/pngjs/lib/paeth-predictor.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nmodule.exports = function paethPredictor(left, above, upLeft) {\r\n\r\n  var paeth = left + above - upLeft;\r\n  var pLeft = Math.abs(paeth - left);\r\n  var pAbove = Math.abs(paeth - above);\r\n  var pUpLeft = Math.abs(paeth - upLeft);\r\n\r\n  if (pLeft <= pAbove && pLeft <= pUpLeft) {\r\n    return left;\r\n  }\r\n  if (pAbove <= pUpLeft) {\r\n    return above;\r\n  }\r\n  return upLeft;\r\n};\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/paeth-predictor.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/parser-async.js":
/*!*************************************************!*\
  !*** ../node_modules/pngjs/lib/parser-async.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\nvar ChunkStream = __webpack_require__(/*! ./chunkstream */ \"../node_modules/pngjs/lib/chunkstream.js\");\nvar FilterAsync = __webpack_require__(/*! ./filter-parse-async */ \"../node_modules/pngjs/lib/filter-parse-async.js\");\nvar Parser = __webpack_require__(/*! ./parser */ \"../node_modules/pngjs/lib/parser.js\");\nvar bitmapper = __webpack_require__(/*! ./bitmapper */ \"../node_modules/pngjs/lib/bitmapper.js\");\nvar formatNormaliser = __webpack_require__(/*! ./format-normaliser */ \"../node_modules/pngjs/lib/format-normaliser.js\");\n\nvar ParserAsync = module.exports = function(options) {\n  ChunkStream.call(this);\n\n  this._parser = new Parser(options, {\n    read: this.read.bind(this),\n    error: this._handleError.bind(this),\n    metadata: this._handleMetaData.bind(this),\n    gamma: this.emit.bind(this, 'gamma'),\n    palette: this._handlePalette.bind(this),\n    transColor: this._handleTransColor.bind(this),\n    finished: this._finished.bind(this),\n    inflateData: this._inflateData.bind(this)\n  });\n  this._options = options;\n  this.writable = true;\n\n  this._parser.start();\n};\nutil.inherits(ParserAsync, ChunkStream);\n\n\nParserAsync.prototype._handleError = function(err) {\n\n  this.emit('error', err);\n\n  this.writable = false;\n\n  this.destroy();\n\n  if (this._inflate && this._inflate.destroy) {\n    this._inflate.destroy();\n  }\n\n  if (this._filter) {\n    this._filter.destroy();\n    // For backward compatibility with Node 7 and below.\n    // Suppress errors due to _inflate calling write() even after\n    // it's destroy()'ed.\n    this._filter.on('error', function() {});\n  }\n\n  this.errord = true;\n};\n\nParserAsync.prototype._inflateData = function(data) {\n  if (!this._inflate) {\n    if (this._bitmapInfo.interlace) {\n      this._inflate = zlib.createInflate();\n\n      this._inflate.on('error', this.emit.bind(this, 'error'));\n      this._filter.on('complete', this._complete.bind(this));\n\n      this._inflate.pipe(this._filter);\n    } else {\n      var rowSize = ((this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7) >> 3) + 1;\n      var imageSize = rowSize * this._bitmapInfo.height;\n      var chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);\n      \n      this._inflate = zlib.createInflate({ chunkSize: chunkSize });\n      var leftToInflate = imageSize;\n\n      var emitError = this.emit.bind(this, 'error');\n      this._inflate.on('error', function(err) {\n        if (!leftToInflate) {\n          return;\n        }\n\n        emitError(err);\n      });\n      this._filter.on('complete', this._complete.bind(this));\n\n      var filterWrite = this._filter.write.bind(this._filter);\n      this._inflate.on('data', function(chunk) {\n        if (!leftToInflate) {\n          return;\n        }\n\n        if (chunk.length > leftToInflate) {\n          chunk = chunk.slice(0, leftToInflate);\n        }\n\n        leftToInflate -= chunk.length;\n\n        filterWrite(chunk);\n      });\n\n      this._inflate.on('end', this._filter.end.bind(this._filter));\n    }\n  }\n  this._inflate.write(data);\n};\n\nParserAsync.prototype._handleMetaData = function(metaData) {\n\n  this.emit('metadata', metaData);\n\n  this._bitmapInfo = Object.create(metaData);\n\n  this._filter = new FilterAsync(this._bitmapInfo);\n};\n\nParserAsync.prototype._handleTransColor = function(transColor) {\n  this._bitmapInfo.transColor = transColor;\n};\n\nParserAsync.prototype._handlePalette = function(palette) {\n  this._bitmapInfo.palette = palette;\n};\n\n\nParserAsync.prototype._finished = function() {\n  if (this.errord) {\n    return;\n  }\n\n  if (!this._inflate) {\n    this.emit('error', 'No Inflate block');\n  }\n  else {\n    // no more data to inflate\n    this._inflate.end();\n  }\n  this.destroySoon();\n};\n\nParserAsync.prototype._complete = function(filteredData) {\n\n  if (this.errord) {\n    return;\n  }\n\n  try {\n    var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);\n\n    var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);\n    bitmapData = null;\n  }\n  catch (ex) {\n    this._handleError(ex);\n    return;\n  }\n\n  this.emit('parsed', normalisedBitmapData);\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/parser-async.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/parser-sync.js":
/*!************************************************!*\
  !*** ../node_modules/pngjs/lib/parser-sync.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar hasSyncZlib = true;\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\nvar inflateSync = __webpack_require__(/*! ./sync-inflate */ \"../node_modules/pngjs/lib/sync-inflate.js\");\nif (!zlib.deflateSync) {\n  hasSyncZlib = false;\n}\nvar SyncReader = __webpack_require__(/*! ./sync-reader */ \"../node_modules/pngjs/lib/sync-reader.js\");\nvar FilterSync = __webpack_require__(/*! ./filter-parse-sync */ \"../node_modules/pngjs/lib/filter-parse-sync.js\");\nvar Parser = __webpack_require__(/*! ./parser */ \"../node_modules/pngjs/lib/parser.js\");\nvar bitmapper = __webpack_require__(/*! ./bitmapper */ \"../node_modules/pngjs/lib/bitmapper.js\");\nvar formatNormaliser = __webpack_require__(/*! ./format-normaliser */ \"../node_modules/pngjs/lib/format-normaliser.js\");\n\n\nmodule.exports = function(buffer, options) {\n\n  if (!hasSyncZlib) {\n    throw new Error('To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0');\n  }\n\n  var err;\n  function handleError(_err_) {\n    err = _err_;\n  }\n\n  var metaData;\n  function handleMetaData(_metaData_) {\n    metaData = _metaData_;\n  }\n\n  function handleTransColor(transColor) {\n    metaData.transColor = transColor;\n  }\n\n  function handlePalette(palette) {\n    metaData.palette = palette;\n  }\n\n  var gamma;\n  function handleGamma(_gamma_) {\n    gamma = _gamma_;\n  }\n\n  var inflateDataList = [];\n  function handleInflateData(inflatedData) {\n    inflateDataList.push(inflatedData);\n  }\n\n  var reader = new SyncReader(buffer);\n\n  var parser = new Parser(options, {\n    read: reader.read.bind(reader),\n    error: handleError,\n    metadata: handleMetaData,\n    gamma: handleGamma,\n    palette: handlePalette,\n    transColor: handleTransColor,\n    inflateData: handleInflateData\n  });\n\n  parser.start();\n  reader.process();\n\n  if (err) {\n    throw err;\n  }\n\n  //join together the inflate datas\n  var inflateData = Buffer.concat(inflateDataList);\n  inflateDataList.length = 0;\n\n  var inflatedData;\n  if (metaData.interlace) {\n    inflatedData = zlib.inflateSync(inflateData);\n  } else {\n    var rowSize = ((metaData.width * metaData.bpp * metaData.depth + 7) >> 3) + 1;\n    var imageSize = rowSize * metaData.height;\n    inflatedData = inflateSync(inflateData, { chunkSize: imageSize, maxLength: imageSize });\n  }\n  inflateData = null;\n\n  if (!inflatedData || !inflatedData.length) {\n    throw new Error('bad png - invalid inflate data response');\n  }\n\n  var unfilteredData = FilterSync.process(inflatedData, metaData);\n  inflateData = null;\n\n  var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);\n  unfilteredData = null;\n\n  var normalisedBitmapData = formatNormaliser(bitmapData, metaData);\n\n  metaData.data = normalisedBitmapData;\n  metaData.gamma = gamma || 0;\n\n  return metaData;\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/parser-sync.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/parser.js":
/*!*******************************************!*\
  !*** ../node_modules/pngjs/lib/parser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar constants = __webpack_require__(/*! ./constants */ \"../node_modules/pngjs/lib/constants.js\");\nvar CrcCalculator = __webpack_require__(/*! ./crc */ \"../node_modules/pngjs/lib/crc.js\");\n\n\nvar Parser = module.exports = function(options, dependencies) {\n\n  this._options = options;\n  options.checkCRC = options.checkCRC !== false;\n\n  this._hasIHDR = false;\n  this._hasIEND = false;\n\n  // input flags/metadata\n  this._palette = [];\n  this._colorType = 0;\n\n  this._chunks = {};\n  this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);\n  this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);\n  this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);\n  this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);\n  this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);\n  this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);\n\n  this.read = dependencies.read;\n  this.error = dependencies.error;\n  this.metadata = dependencies.metadata;\n  this.gamma = dependencies.gamma;\n  this.transColor = dependencies.transColor;\n  this.palette = dependencies.palette;\n  this.parsed = dependencies.parsed;\n  this.inflateData = dependencies.inflateData;\n  this.finished = dependencies.finished;\n};\n\nParser.prototype.start = function() {\n  this.read(constants.PNG_SIGNATURE.length,\n    this._parseSignature.bind(this)\n  );\n};\n\nParser.prototype._parseSignature = function(data) {\n\n  var signature = constants.PNG_SIGNATURE;\n\n  for (var i = 0; i < signature.length; i++) {\n    if (data[i] !== signature[i]) {\n      this.error(new Error('Invalid file signature'));\n      return;\n    }\n  }\n  this.read(8, this._parseChunkBegin.bind(this));\n};\n\nParser.prototype._parseChunkBegin = function(data) {\n\n  // chunk content length\n  var length = data.readUInt32BE(0);\n\n  // chunk type\n  var type = data.readUInt32BE(4);\n  var name = '';\n  for (var i = 4; i < 8; i++) {\n    name += String.fromCharCode(data[i]);\n  }\n\n  //console.log('chunk ', name, length);\n\n  // chunk flags\n  var ancillary = Boolean(data[4] & 0x20); // or critical\n//    priv = Boolean(data[5] & 0x20), // or public\n//    safeToCopy = Boolean(data[7] & 0x20); // or unsafe\n\n  if (!this._hasIHDR && type !== constants.TYPE_IHDR) {\n    this.error(new Error('Expected IHDR on beggining'));\n    return;\n  }\n\n  this._crc = new CrcCalculator();\n  this._crc.write(new Buffer(name));\n\n  if (this._chunks[type]) {\n    return this._chunks[type](length);\n  }\n\n  if (!ancillary) {\n    this.error(new Error('Unsupported critical chunk type ' + name));\n    return;\n  }\n\n  this.read(length + 4, this._skipChunk.bind(this));\n};\n\nParser.prototype._skipChunk = function(/*data*/) {\n  this.read(8, this._parseChunkBegin.bind(this));\n};\n\nParser.prototype._handleChunkEnd = function() {\n  this.read(4, this._parseChunkEnd.bind(this));\n};\n\nParser.prototype._parseChunkEnd = function(data) {\n\n  var fileCrc = data.readInt32BE(0);\n  var calcCrc = this._crc.crc32();\n\n  // check CRC\n  if (this._options.checkCRC && calcCrc !== fileCrc) {\n    this.error(new Error('Crc error - ' + fileCrc + ' - ' + calcCrc));\n    return;\n  }\n\n  if (!this._hasIEND) {\n    this.read(8, this._parseChunkBegin.bind(this));\n  }\n};\n\nParser.prototype._handleIHDR = function(length) {\n  this.read(length, this._parseIHDR.bind(this));\n};\nParser.prototype._parseIHDR = function(data) {\n\n  this._crc.write(data);\n\n  var width = data.readUInt32BE(0);\n  var height = data.readUInt32BE(4);\n  var depth = data[8];\n  var colorType = data[9]; // bits: 1 palette, 2 color, 4 alpha\n  var compr = data[10];\n  var filter = data[11];\n  var interlace = data[12];\n\n  // console.log('    width', width, 'height', height,\n  //     'depth', depth, 'colorType', colorType,\n  //     'compr', compr, 'filter', filter, 'interlace', interlace\n  // );\n\n  if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {\n    this.error(new Error('Unsupported bit depth ' + depth));\n    return;\n  }\n  if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {\n    this.error(new Error('Unsupported color type'));\n    return;\n  }\n  if (compr !== 0) {\n    this.error(new Error('Unsupported compression method'));\n    return;\n  }\n  if (filter !== 0) {\n    this.error(new Error('Unsupported filter method'));\n    return;\n  }\n  if (interlace !== 0 && interlace !== 1) {\n    this.error(new Error('Unsupported interlace method'));\n    return;\n  }\n\n  this._colorType = colorType;\n\n  var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];\n\n  this._hasIHDR = true;\n\n  this.metadata({\n    width: width,\n    height: height,\n    depth: depth,\n    interlace: Boolean(interlace),\n    palette: Boolean(colorType & constants.COLORTYPE_PALETTE),\n    color: Boolean(colorType & constants.COLORTYPE_COLOR),\n    alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),\n    bpp: bpp,\n    colorType: colorType\n  });\n\n  this._handleChunkEnd();\n};\n\n\nParser.prototype._handlePLTE = function(length) {\n  this.read(length, this._parsePLTE.bind(this));\n};\nParser.prototype._parsePLTE = function(data) {\n\n  this._crc.write(data);\n\n  var entries = Math.floor(data.length / 3);\n  // console.log('Palette:', entries);\n\n  for (var i = 0; i < entries; i++) {\n    this._palette.push([\n      data[i * 3],\n      data[i * 3 + 1],\n      data[i * 3 + 2],\n      0xff\n    ]);\n  }\n\n  this.palette(this._palette);\n\n  this._handleChunkEnd();\n};\n\nParser.prototype._handleTRNS = function(length) {\n  this.read(length, this._parseTRNS.bind(this));\n};\nParser.prototype._parseTRNS = function(data) {\n\n  this._crc.write(data);\n\n  // palette\n  if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {\n    if (this._palette.length === 0) {\n      this.error(new Error('Transparency chunk must be after palette'));\n      return;\n    }\n    if (data.length > this._palette.length) {\n      this.error(new Error('More transparent colors than palette size'));\n      return;\n    }\n    for (var i = 0; i < data.length; i++) {\n      this._palette[i][3] = data[i];\n    }\n    this.palette(this._palette);\n  }\n\n  // for colorType 0 (grayscale) and 2 (rgb)\n  // there might be one gray/color defined as transparent\n  if (this._colorType === constants.COLORTYPE_GRAYSCALE) {\n    // grey, 2 bytes\n    this.transColor([data.readUInt16BE(0)]);\n  }\n  if (this._colorType === constants.COLORTYPE_COLOR) {\n    this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);\n  }\n\n  this._handleChunkEnd();\n};\n\nParser.prototype._handleGAMA = function(length) {\n  this.read(length, this._parseGAMA.bind(this));\n};\nParser.prototype._parseGAMA = function(data) {\n\n  this._crc.write(data);\n  this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);\n\n  this._handleChunkEnd();\n};\n\nParser.prototype._handleIDAT = function(length) {\n  this.read(-length, this._parseIDAT.bind(this, length));\n};\nParser.prototype._parseIDAT = function(length, data) {\n\n  this._crc.write(data);\n\n  if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {\n    throw new Error('Expected palette not found');\n  }\n\n  this.inflateData(data);\n  var leftOverLength = length - data.length;\n\n  if (leftOverLength > 0) {\n    this._handleIDAT(leftOverLength);\n  }\n  else {\n    this._handleChunkEnd();\n  }\n};\n\nParser.prototype._handleIEND = function(length) {\n  this.read(length, this._parseIEND.bind(this));\n};\nParser.prototype._parseIEND = function(data) {\n\n  this._crc.write(data);\n\n  this._hasIEND = true;\n  this._handleChunkEnd();\n\n  if (this.finished) {\n    this.finished();\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/parser.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/png-sync.js":
/*!*********************************************!*\
  !*** ../node_modules/pngjs/lib/png-sync.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar parse = __webpack_require__(/*! ./parser-sync */ \"../node_modules/pngjs/lib/parser-sync.js\");\nvar pack = __webpack_require__(/*! ./packer-sync */ \"../node_modules/pngjs/lib/packer-sync.js\");\n\n\nexports.read = function(buffer, options) {\n\n  return parse(buffer, options || {});\n};\n\nexports.write = function(png, options) {\n\n  return pack(png, options);\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/png-sync.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/png.js":
/*!****************************************!*\
  !*** ../node_modules/pngjs/lib/png.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\nvar Parser = __webpack_require__(/*! ./parser-async */ \"../node_modules/pngjs/lib/parser-async.js\");\nvar Packer = __webpack_require__(/*! ./packer-async */ \"../node_modules/pngjs/lib/packer-async.js\");\nvar PNGSync = __webpack_require__(/*! ./png-sync */ \"../node_modules/pngjs/lib/png-sync.js\");\n\n\nvar PNG = exports.PNG = function(options) {\n  Stream.call(this);\n\n  options = options || {}; // eslint-disable-line no-param-reassign\n\n  // coerce pixel dimensions to integers (also coerces undefined -> 0):\n  this.width = options.width | 0;\n  this.height = options.height | 0;\n\n  this.data = this.width > 0 && this.height > 0 ?\n    new Buffer(4 * this.width * this.height) : null;\n\n  if (options.fill && this.data) {\n    this.data.fill(0);\n  }\n\n  this.gamma = 0;\n  this.readable = this.writable = true;\n\n  this._parser = new Parser(options);\n\n  this._parser.on('error', this.emit.bind(this, 'error'));\n  this._parser.on('close', this._handleClose.bind(this));\n  this._parser.on('metadata', this._metadata.bind(this));\n  this._parser.on('gamma', this._gamma.bind(this));\n  this._parser.on('parsed', function(data) {\n    this.data = data;\n    this.emit('parsed', data);\n  }.bind(this));\n\n  this._packer = new Packer(options);\n  this._packer.on('data', this.emit.bind(this, 'data'));\n  this._packer.on('end', this.emit.bind(this, 'end'));\n  this._parser.on('close', this._handleClose.bind(this));\n  this._packer.on('error', this.emit.bind(this, 'error'));\n\n};\nutil.inherits(PNG, Stream);\n\nPNG.sync = PNGSync;\n\nPNG.prototype.pack = function() {\n\n  if (!this.data || !this.data.length) {\n    this.emit('error', 'No data provided');\n    return this;\n  }\n\n  process.nextTick(function() {\n    this._packer.pack(this.data, this.width, this.height, this.gamma);\n  }.bind(this));\n\n  return this;\n};\n\n\nPNG.prototype.parse = function(data, callback) {\n\n  if (callback) {\n    var onParsed, onError;\n\n    onParsed = function(parsedData) {\n      this.removeListener('error', onError);\n\n      this.data = parsedData;\n      callback(null, this);\n    }.bind(this);\n\n    onError = function(err) {\n      this.removeListener('parsed', onParsed);\n\n      callback(err, null);\n    }.bind(this);\n\n    this.once('parsed', onParsed);\n    this.once('error', onError);\n  }\n\n  this.end(data);\n  return this;\n};\n\nPNG.prototype.write = function(data) {\n  this._parser.write(data);\n  return true;\n};\n\nPNG.prototype.end = function(data) {\n  this._parser.end(data);\n};\n\nPNG.prototype._metadata = function(metadata) {\n  this.width = metadata.width;\n  this.height = metadata.height;\n\n  this.emit('metadata', metadata);\n};\n\nPNG.prototype._gamma = function(gamma) {\n  this.gamma = gamma;\n};\n\nPNG.prototype._handleClose = function() {\n  if (!this._parser.writable && !this._packer.readable) {\n    this.emit('close');\n  }\n};\n\n\nPNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) { // eslint-disable-line max-params\n  // coerce pixel dimensions to integers (also coerces undefined -> 0):\n  /* eslint-disable no-param-reassign */\n  srcX |= 0;\n  srcY |= 0;\n  width |= 0;\n  height |= 0;\n  deltaX |= 0;\n  deltaY |= 0;\n  /* eslint-enable no-param-reassign */\n\n  if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {\n    throw new Error('bitblt reading outside image');\n  }\n\n  if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {\n    throw new Error('bitblt writing outside image');\n  }\n\n  for (var y = 0; y < height; y++) {\n    src.data.copy(dst.data,\n      ((deltaY + y) * dst.width + deltaX) << 2,\n      ((srcY + y) * src.width + srcX) << 2,\n      ((srcY + y) * src.width + srcX + width) << 2\n    );\n  }\n};\n\n\nPNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) { // eslint-disable-line max-params\n\n  PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);\n  return this;\n};\n\nPNG.adjustGamma = function(src) {\n  if (src.gamma) {\n    for (var y = 0; y < src.height; y++) {\n      for (var x = 0; x < src.width; x++) {\n        var idx = (src.width * y + x) << 2;\n\n        for (var i = 0; i < 3; i++) {\n          var sample = src.data[idx + i] / 255;\n          sample = Math.pow(sample, 1 / 2.2 / src.gamma);\n          src.data[idx + i] = Math.round(sample * 255);\n        }\n      }\n    }\n    src.gamma = 0;\n  }\n};\n\nPNG.prototype.adjustGamma = function() {\n  PNG.adjustGamma(this);\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/png.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/sync-inflate.js":
/*!*************************************************!*\
  !*** ../node_modules/pngjs/lib/sync-inflate.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! assert */ \"assert\").ok;\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\nvar kMaxLength = __webpack_require__(/*! buffer */ \"buffer\").kMaxLength;\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) {\n    return new Inflate(opts);\n  }\n\n  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {\n    opts.chunkSize = zlib.Z_MIN_CHUNK;\n  }\n\n  zlib.Inflate.call(this, opts);\n\n  // Node 8 --> 9 compatibility check\n  this._offset = this._offset === undefined ? this._outOffset : this._offset;\n  this._buffer = this._buffer || this._outBuffer;\n\n  if (opts && opts.maxLength != null) {\n    this._maxLength = opts.maxLength;\n  }\n}\n\nfunction createInflate(opts) {\n  return new Inflate(opts);\n}\n\nfunction _close(engine, callback) {\n  if (callback) {\n    process.nextTick(callback);\n  }\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) {\n    return;\n  }\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nInflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {\n  if (typeof asyncCb === 'function') {\n    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);\n  }\n\n  var self = this;\n\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var leftToInflate = this._maxLength;\n  var inOff = 0;\n\n  var buffers = [];\n  var nread = 0;\n\n  var error;\n  this.on('error', function(err) {\n    error = err;\n  });\n\n  function handleChunk(availInAfter, availOutAfter) {\n    if (self._hadError) {\n      return;\n    }\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n\n      if (out.length > leftToInflate) {\n        out = out.slice(0, leftToInflate);\n      }\n\n      buffers.push(out);\n      nread += out.length;\n      leftToInflate -= out.length;\n\n      if (leftToInflate === 0) {\n        return false;\n      }\n    }\n\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      inOff += (availInBefore - availInAfter);\n      availInBefore = availInAfter;\n\n      return true;\n    }\n\n    return false;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n  do {\n    var res = this._handle.writeSync(flushFlag,\n                                     chunk, // in\n                                     inOff, // in_off\n                                     availInBefore, // in_len\n                                     this._buffer, // out\n                                     this._offset, //out_off\n                                     availOutBefore); // out_len\n    // Node 8 --> 9 compatibility check\n    res = res || this._writeState;\n  } while (!this._hadError && handleChunk(res[0], res[1]));\n\n  if (this._hadError) {\n    throw error;\n  }\n\n  if (nread >= kMaxLength) {\n    _close(this);\n    throw new RangeError('Cannot create final Buffer. It would be larger than 0x' + kMaxLength.toString(16) + ' bytes');\n  }\n\n  var buf = Buffer.concat(buffers, nread);\n  _close(this);\n\n  return buf;\n};\n\nutil.inherits(Inflate, zlib.Inflate);\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  }\n  if (!(buffer instanceof Buffer)) {\n    throw new TypeError('Not a string or buffer');\n  }\n\n  var flushFlag = engine._finishFlushFlag;\n  if (flushFlag == null) {\n    flushFlag = zlib.Z_FINISH;\n  }\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\nfunction inflateSync(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n}\n\nmodule.exports = exports = inflateSync;\nexports.Inflate = Inflate;\nexports.createInflate = createInflate;\nexports.inflateSync = inflateSync;\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/sync-inflate.js?");

/***/ }),

/***/ "../node_modules/pngjs/lib/sync-reader.js":
/*!************************************************!*\
  !*** ../node_modules/pngjs/lib/sync-reader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar SyncReader = module.exports = function(buffer) {\n\n  this._buffer = buffer;\n  this._reads = [];\n};\n\nSyncReader.prototype.read = function(length, callback) {\n\n  this._reads.push({\n    length: Math.abs(length),  // if length < 0 then at most this length\n    allowLess: length < 0,\n    func: callback\n  });\n};\n\nSyncReader.prototype.process = function() {\n\n  // as long as there is any data and read requests\n  while (this._reads.length > 0 && this._buffer.length) {\n\n    var read = this._reads[0];\n\n    if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {\n\n      // ok there is any data so that we can satisfy this request\n      this._reads.shift(); // == read\n\n      var buf = this._buffer;\n\n      this._buffer = buf.slice(read.length);\n\n      read.func.call(this, buf.slice(0, read.length));\n\n    }\n    else {\n      break;\n    }\n\n  }\n\n  if (this._reads.length > 0) {\n    return new Error('There are some read requests waitng on finished stream');\n  }\n\n  if (this._buffer.length > 0) {\n    return new Error('unrecognised content at end of stream');\n  }\n\n};\n\n\n//# sourceURL=webpack:///../node_modules/pngjs/lib/sync-reader.js?");

/***/ }),

/***/ "../node_modules/rimraf/rimraf.js":
/*!****************************************!*\
  !*** ../node_modules/rimraf/rimraf.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = rimraf\nrimraf.sync = rimrafSync\n\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar glob = __webpack_require__(/*! glob */ \"../node_modules/glob/glob.js\")\nvar _0666 = parseInt('666', 8)\n\nvar defaultGlobOpts = {\n  nosort: true,\n  silent: true\n}\n\n// for EMFILE handling\nvar timeout = 0\n\nvar isWindows = (process.platform === \"win32\")\n\nfunction defaults (options) {\n  var methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(function(m) {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n  options.emfileWait = options.emfileWait || 1000\n  if (options.glob === false) {\n    options.disableGlob = true\n  }\n  options.disableGlob = options.disableGlob || false\n  options.glob = options.glob || defaultGlobOpts\n}\n\nfunction rimraf (p, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  var busyTries = 0\n  var errState = null\n  var n = 0\n\n  if (options.disableGlob || !glob.hasMagic(p))\n    return afterGlob(null, [p])\n\n  options.lstat(p, function (er, stat) {\n    if (!er)\n      return afterGlob(null, [p])\n\n    glob(p, options.glob, afterGlob)\n  })\n\n  function next (er) {\n    errState = errState || er\n    if (--n === 0)\n      cb(errState)\n  }\n\n  function afterGlob (er, results) {\n    if (er)\n      return cb(er)\n\n    n = results.length\n    if (n === 0)\n      return cb()\n\n    results.forEach(function (p) {\n      rimraf_(p, options, function CB (er) {\n        if (er) {\n          if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") &&\n              busyTries < options.maxBusyTries) {\n            busyTries ++\n            var time = busyTries * 100\n            // try again, with the same exact callback as this one.\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, time)\n          }\n\n          // this one won't happen if graceful-fs is used.\n          if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, timeout ++)\n          }\n\n          // already gone\n          if (er.code === \"ENOENT\") er = null\n        }\n\n        timeout = 0\n        next(er)\n      })\n    })\n  }\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, function (er, st) {\n    if (er && er.code === \"ENOENT\")\n      return cb(null)\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === \"EPERM\" && isWindows)\n      fixWinEPERM(p, options, er, cb)\n\n    if (st && st.isDirectory())\n      return rmdir(p, options, er, cb)\n\n    options.unlink(p, function (er) {\n      if (er) {\n        if (er.code === \"ENOENT\")\n          return cb(null)\n        if (er.code === \"EPERM\")\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        if (er.code === \"EISDIR\")\n          return rmdir(p, options, er, cb)\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er)\n    assert(er instanceof Error)\n\n  options.chmod(p, _0666, function (er2) {\n    if (er2)\n      cb(er2.code === \"ENOENT\" ? null : er)\n    else\n      options.stat(p, function(er3, stats) {\n        if (er3)\n          cb(er3.code === \"ENOENT\" ? null : er)\n        else if (stats.isDirectory())\n          rmdir(p, options, er, cb)\n        else\n          options.unlink(p, cb)\n      })\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  assert(p)\n  assert(options)\n  if (er)\n    assert(er instanceof Error)\n\n  try {\n    options.chmodSync(p, _0666)\n  } catch (er2) {\n    if (er2.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  try {\n    var stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  if (stats.isDirectory())\n    rmdirSync(p, options, er)\n  else\n    options.unlinkSync(p)\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, function (er) {\n    if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\"))\n      rmkids(p, options, cb)\n    else if (er && er.code === \"ENOTDIR\")\n      cb(originalEr)\n    else\n      cb(er)\n  })\n}\n\nfunction rmkids(p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, function (er, files) {\n    if (er)\n      return cb(er)\n    var n = files.length\n    if (n === 0)\n      return options.rmdir(p, cb)\n    var errState\n    files.forEach(function (f) {\n      rimraf(path.join(p, f), options, function (er) {\n        if (errState)\n          return\n        if (er)\n          return cb(errState = er)\n        if (--n === 0)\n          options.rmdir(p, cb)\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  var results\n\n  if (options.disableGlob || !glob.hasMagic(p)) {\n    results = [p]\n  } else {\n    try {\n      options.lstatSync(p)\n      results = [p]\n    } catch (er) {\n      results = glob.sync(p, options.glob)\n    }\n  }\n\n  if (!results.length)\n    return\n\n  for (var i = 0; i < results.length; i++) {\n    var p = results[i]\n\n    try {\n      var st = options.lstatSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n\n      // Windows can EPERM on stat.  Life is suffering.\n      if (er.code === \"EPERM\" && isWindows)\n        fixWinEPERMSync(p, options, er)\n    }\n\n    try {\n      // sunos lets the root user unlink directories, which is... weird.\n      if (st && st.isDirectory())\n        rmdirSync(p, options, null)\n      else\n        options.unlinkSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n      if (er.code === \"EPERM\")\n        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n      if (er.code !== \"EISDIR\")\n        throw er\n\n      rmdirSync(p, options, er)\n    }\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === \"ENOENT\")\n      return\n    if (er.code === \"ENOTDIR\")\n      throw originalEr\n    if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")\n      rmkidsSync(p, options)\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(function (f) {\n    rimrafSync(path.join(p, f), options)\n  })\n\n  // We only end up here once we got ENOTEMPTY at least once, and\n  // at this point, we are guaranteed to have removed all the kids.\n  // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n  // try really hard to delete stuff on windows, because it has a\n  // PROFOUNDLY annoying habit of not closing handles promptly when\n  // files are deleted, resulting in spurious ENOTEMPTY errors.\n  var retries = isWindows ? 100 : 1\n  var i = 0\n  do {\n    var threw = true\n    try {\n      var ret = options.rmdirSync(p, options)\n      threw = false\n      return ret\n    } finally {\n      if (++i < retries && threw)\n        continue\n    }\n  } while (true)\n}\n\n\n//# sourceURL=webpack:///../node_modules/rimraf/rimraf.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/chrome.js":
/*!****************************************************!*\
  !*** ../node_modules/selenium-webdriver/chrome.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a {@linkplain Driver WebDriver} client for the Chrome\n * web browser. Before using this module, you must download the latest\n * [ChromeDriver release] and ensure it can be found on your system [PATH].\n *\n * There are three primary classes exported by this module:\n *\n * 1. {@linkplain ServiceBuilder}: configures the\n *     {@link selenium-webdriver/remote.DriverService remote.DriverService}\n *     that manages the [ChromeDriver] child process.\n *\n * 2. {@linkplain Options}: defines configuration options for each new Chrome\n *     session, such as which {@linkplain Options#setProxy proxy} to use,\n *     what {@linkplain Options#addExtensions extensions} to install, or\n *     what {@linkplain Options#addArguments command-line switches} to use when\n *     starting the browser.\n *\n * 3. {@linkplain Driver}: the WebDriver client; each new instance will control\n *     a unique browser session with a clean user profile (unless otherwise\n *     configured through the {@link Options} class).\n *\n * __Headless Chrome__ <a id=\"headless\"></a>\n *\n * To start Chrome in headless mode, simply call\n * {@linkplain Options#headless Options.headless()}. Note, starting in headless\n * mode currently also disables GPU acceleration.\n *\n *     let chrome = require('selenium-webdriver/chrome');\n *     let {Builder} = require('selenium-webdriver');\n *\n *     let driver = new Builder()\n *         .forBrowser('chrome')\n *         .setChromeOptions(new chrome.Options().headless())\n *         .build();\n *\n * __Customizing the ChromeDriver Server__ <a id=\"custom-server\"></a>\n *\n * By default, every Chrome session will use a single driver service, which is\n * started the first time a {@link Driver} instance is created and terminated\n * when this process exits. The default service will inherit its environment\n * from the current process and direct all output to /dev/null. You may obtain\n * a handle to this default service using\n * {@link #getDefaultService getDefaultService()} and change its configuration\n * with {@link #setDefaultService setDefaultService()}.\n *\n * You may also create a {@link Driver} with its own driver service. This is\n * useful if you need to capture the server's log output for a specific session:\n *\n *     let chrome = require('selenium-webdriver/chrome');\n *\n *     let service = new chrome.ServiceBuilder()\n *         .loggingTo('/my/log/file.txt')\n *         .enableVerboseLogging()\n *         .build();\n *\n *     let options = new chrome.Options();\n *     // configure browser options ...\n *\n *     let driver = chrome.Driver.createSession(options, service);\n *\n * Users should only instantiate the {@link Driver} class directly when they\n * need a custom driver service configuration (as shown above). For normal\n * operation, users should start Chrome using the\n * {@link selenium-webdriver.Builder}.\n *\n * __Working with Android__ <a id=\"android\"></a>\n *\n * The [ChromeDriver][android] supports running tests on the Chrome browser as\n * well as [WebView apps][webview] starting in Android 4.4 (KitKat). In order to\n * work with Android, you must first start the adb\n *\n *     adb start-server\n *\n * By default, adb will start on port 5037. You may change this port, but this\n * will require configuring a [custom server](#custom-server) that will connect\n * to adb on the {@linkplain ServiceBuilder#setAdbPort correct port}:\n *\n *     let service = new chrome.ServiceBuilder()\n *         .setAdbPort(1234)\n *         build();\n *     // etc.\n *\n * The ChromeDriver may be configured to launch Chrome on Android using\n * {@link Options#androidChrome()}:\n *\n *     let driver = new Builder()\n *         .forBrowser('chrome')\n *         .setChromeOptions(new chrome.Options().androidChrome())\n *         .build();\n *\n * Alternatively, you can configure the ChromeDriver to launch an app with a\n * Chrome-WebView by setting the {@linkplain Options#androidActivity\n * androidActivity} option:\n *\n *     let driver = new Builder()\n *         .forBrowser('chrome')\n *         .setChromeOptions(new chrome.Options()\n *             .androidPackage('com.example')\n *             .androidActivity('com.example.Activity'))\n *         .build();\n *\n * [Refer to the ChromeDriver site] for more information on using the\n * [ChromeDriver with Android][android].\n *\n * [ChromeDriver]: https://sites.google.com/a/chromium.org/chromedriver/\n * [ChromeDriver release]: http://chromedriver.storage.googleapis.com/index.html\n * [PATH]: http://en.wikipedia.org/wiki/PATH_%28variable%29\n * [android]: https://sites.google.com/a/chromium.org/chromedriver/getting-started/getting-started---android\n * [webview]: https://developer.chrome.com/multidevice/webview/overview\n */\n\n\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst http = __webpack_require__(/*! ./http */ \"../node_modules/selenium-webdriver/http/index.js\");\nconst io = __webpack_require__(/*! ./io */ \"../node_modules/selenium-webdriver/io/index.js\");\nconst {Browser, Capabilities, Capability} = __webpack_require__(/*! ./lib/capabilities */ \"../node_modules/selenium-webdriver/lib/capabilities.js\");\nconst command = __webpack_require__(/*! ./lib/command */ \"../node_modules/selenium-webdriver/lib/command.js\");\nconst error = __webpack_require__(/*! ./lib/error */ \"../node_modules/selenium-webdriver/lib/error.js\");\nconst logging = __webpack_require__(/*! ./lib/logging */ \"../node_modules/selenium-webdriver/lib/logging.js\");\nconst promise = __webpack_require__(/*! ./lib/promise */ \"../node_modules/selenium-webdriver/lib/promise.js\");\nconst Symbols = __webpack_require__(/*! ./lib/symbols */ \"../node_modules/selenium-webdriver/lib/symbols.js\");\nconst webdriver = __webpack_require__(/*! ./lib/webdriver */ \"../node_modules/selenium-webdriver/lib/webdriver.js\");\nconst portprober = __webpack_require__(/*! ./net/portprober */ \"../node_modules/selenium-webdriver/net/portprober.js\");\nconst remote = __webpack_require__(/*! ./remote */ \"../node_modules/selenium-webdriver/remote/index.js\");\n\n\n/**\n * Name of the ChromeDriver executable.\n * @type {string}\n * @const\n */\nconst CHROMEDRIVER_EXE =\n    process.platform === 'win32' ? 'chromedriver.exe' : 'chromedriver';\n\n\n/**\n * Custom command names supported by ChromeDriver.\n * @enum {string}\n */\nconst Command = {\n  LAUNCH_APP: 'launchApp',\n  GET_NETWORK_CONDITIONS: 'getNetworkConditions',\n  SET_NETWORK_CONDITIONS: 'setNetworkConditions',\n  SEND_DEVTOOLS_COMMAND: 'sendDevToolsCommand',\n};\n\n\n/**\n * Creates a command executor with support for ChromeDriver's custom commands.\n * @param {!Promise<string>} url The server's URL.\n * @return {!command.Executor} The new command executor.\n */\nfunction createExecutor(url) {\n  let client = url.then(url => new http.HttpClient(url));\n  let executor = new http.Executor(client);\n  configureExecutor(executor);\n  return executor;\n}\n\n\n/**\n * Configures the given executor with Chrome-specific commands.\n * @param {!http.Executor} executor the executor to configure.\n */\nfunction configureExecutor(executor) {\n  executor.defineCommand(\n      Command.LAUNCH_APP,\n      'POST',\n      '/session/:sessionId/chromium/launch_app');\n  executor.defineCommand(\n      Command.GET_NETWORK_CONDITIONS,\n      'GET',\n      '/session/:sessionId/chromium/network_conditions');\n  executor.defineCommand(\n      Command.SET_NETWORK_CONDITIONS,\n      'POST',\n      '/session/:sessionId/chromium/network_conditions');\n  executor.defineCommand(\n      Command.SEND_DEVTOOLS_COMMAND,\n      'POST',\n      '/session/:sessionId/chromium/send_command');\n}\n\n\n/**\n * _Synchronously_ attempts to locate the chromedriver executable on the current\n * system.\n *\n * @return {?string} the located executable, or `null`.\n */\nfunction locateSynchronously() {\n  return io.findInPath(CHROMEDRIVER_EXE, true);\n}\n\n\n/**\n * Creates {@link selenium-webdriver/remote.DriverService} instances that manage\n * a [ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/)\n * server in a child process.\n */\nclass ServiceBuilder extends remote.DriverService.Builder {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *     the builder will attempt to locate the chromedriver on the current\n   *     PATH.\n   * @throws {Error} If provided executable does not exist, or the chromedriver\n   *     cannot be found on the PATH.\n   */\n  constructor(opt_exe) {\n    let exe = opt_exe || locateSynchronously();\n    if (!exe) {\n      throw Error(\n          'The ChromeDriver could not be found on the current PATH. Please ' +\n          'download the latest version of the ChromeDriver from ' +\n          'http://chromedriver.storage.googleapis.com/index.html and ensure ' +\n          'it can be found on your PATH.');\n    }\n\n    super(exe);\n    this.setLoopback(true);  // Required\n  }\n\n  /**\n   * Sets which port adb is listening to. _The ChromeDriver will connect to adb\n   * if an {@linkplain Options#androidPackage Android session} is requested, but\n   * adb **must** be started beforehand._\n   *\n   * @param {number} port Which port adb is running on.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  setAdbPort(port) {\n    return this.addArguments('--adb-port=' + port);\n  }\n\n  /**\n   * Sets the path of the log file the driver should log to. If a log file is\n   * not specified, the driver will log to stderr.\n   * @param {string} path Path of the log file to use.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  loggingTo(path) {\n    return this.addArguments('--log-path=' + path);\n  }\n\n  /**\n   * Enables verbose logging.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  enableVerboseLogging() {\n    return this.addArguments('--verbose');\n  }\n\n  /**\n   * Sets the number of threads the driver should use to manage HTTP requests.\n   * By default, the driver will use 4 threads.\n   * @param {number} n The number of threads to use.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  setNumHttpThreads(n) {\n    return this.addArguments('--http-threads=' + n);\n  }\n\n  /**\n   * @override\n   */\n  setPath(path) {\n    super.setPath(path);\n    return this.addArguments('--url-base=' + path);\n  }\n}\n\n\n\n/** @type {remote.DriverService} */\nlet defaultService = null;\n\n\n/**\n * Sets the default service to use for new ChromeDriver instances.\n * @param {!remote.DriverService} service The service to use.\n * @throws {Error} If the default service is currently running.\n */\nfunction setDefaultService(service) {\n  if (defaultService && defaultService.isRunning()) {\n    throw Error(\n        'The previously configured ChromeDriver service is still running. ' +\n        'You must shut it down before you may adjust its configuration.');\n  }\n  defaultService = service;\n}\n\n\n/**\n * Returns the default ChromeDriver service. If such a service has not been\n * configured, one will be constructed using the default configuration for\n * a ChromeDriver executable found on the system PATH.\n * @return {!remote.DriverService} The default ChromeDriver service.\n */\nfunction getDefaultService() {\n  if (!defaultService) {\n    defaultService = new ServiceBuilder().build();\n  }\n  return defaultService;\n}\n\n\nconst OPTIONS_CAPABILITY_KEY = 'chromeOptions';\n\n\n/**\n * Class for managing ChromeDriver specific options.\n */\nclass Options extends Capabilities {\n  /**\n   * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of\n   *     capabilities to initialize this instance from.\n   */\n  constructor(other = undefined) {\n    super(other);\n\n    /** @private {!Object} */\n    this.options_ = this.get(OPTIONS_CAPABILITY_KEY) || {};\n\n    this.setBrowserName(Browser.CHROME);\n    this.set(OPTIONS_CAPABILITY_KEY, this.options_);\n  }\n\n  /**\n   * Add additional command line arguments to use when launching the Chrome\n   * browser.  Each argument may be specified with or without the \"--\" prefix\n   * (e.g. \"--foo\" and \"foo\"). Arguments with an associated value should be\n   * delimited by an \"=\": \"foo=bar\".\n   *\n   * @param {...(string|!Array<string>)} args The arguments to add.\n   * @return {!Options} A self reference.\n   */\n  addArguments(...args) {\n    let newArgs = (this.options_.args || []).concat(...args);\n    if (newArgs.length) {\n      this.options_.args = newArgs;\n    }\n    return this;\n  }\n\n  /**\n   * Configures the chromedriver to start Chrome in headless mode.\n   *\n   * > __NOTE:__ Resizing the browser window in headless mode is only supported\n   * > in Chrome 60. Users are encouraged to set an initial window size with\n   * > the {@link #windowSize windowSize({width, height})} option.\n   *\n   * > __NOTE__: For security, Chrome disables downloads by default when\n   * > in headless mode (to prevent sites from silently downloading files to\n   * > your machine). After creating a session, you may call\n   * > {@link ./chrome.Driver#setDownloadPath setDownloadPath} to re-enable\n   * > downloads, saving files in the specified directory.\n   *\n   * @return {!Options} A self reference.\n   */\n  headless() {\n    // TODO(jleyba): Remove `disable-gpu` once head Chrome no longer requires\n    // that to be set.\n    return this.addArguments('headless', 'disable-gpu');\n  }\n\n  /**\n   * Sets the initial window size.\n   *\n   * @param {{width: number, height: number}} size The desired window size.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if width or height is unspecified, not a number, or\n   *     less than or equal to 0.\n   */\n  windowSize({width, height}) {\n    function checkArg(arg) {\n      if (typeof arg !== 'number' || arg <= 0) {\n        throw TypeError('Arguments must be {width, height} with numbers > 0');\n      }\n    }\n    checkArg(width);\n    checkArg(height);\n    return this.addArguments(`window-size=${width},${height}`);\n  }\n\n  /**\n   * List of Chrome command line switches to exclude that ChromeDriver by default\n   * passes when starting Chrome.  Do not prefix switches with \"--\".\n   *\n   * @param {...(string|!Array<string>)} args The switches to exclude.\n   * @return {!Options} A self reference.\n   */\n  excludeSwitches(...args) {\n    let switches = (this.options_.excludeSwitches || []).concat(...args);\n    if (switches.length) {\n      this.options_.excludeSwitches = switches;\n    }\n    return this;\n  }\n\n  /**\n   * Add additional extensions to install when launching Chrome. Each extension\n   * should be specified as the path to the packed CRX file, or a Buffer for an\n   * extension.\n   * @param {...(string|!Buffer|!Array<(string|!Buffer)>)} args The\n   *     extensions to add.\n   * @return {!Options} A self reference.\n   */\n  addExtensions(...args) {\n    let current = this.options_.extensions || [];\n    this.options_.extensions = current.concat(...args);\n    return this;\n  }\n\n  /**\n   * Sets the path to the Chrome binary to use. On Mac OS X, this path should\n   * reference the actual Chrome executable, not just the application binary\n   * (e.g. \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\").\n   *\n   * The binary path be absolute or relative to the chromedriver server\n   * executable, but it must exist on the machine that will launch Chrome.\n   *\n   * @param {string} path The path to the Chrome binary to use.\n   * @return {!Options} A self reference.\n   */\n  setChromeBinaryPath(path) {\n    this.options_.binary = path;\n    return this;\n  }\n\n  /**\n   * Sets whether to leave the started Chrome browser running if the controlling\n   * ChromeDriver service is killed before {@link webdriver.WebDriver#quit()} is\n   * called.\n   * @param {boolean} detach Whether to leave the browser running if the\n   *     chromedriver service is killed before the session.\n   * @return {!Options} A self reference.\n   */\n  detachDriver(detach) {\n    this.options_.detach = detach;\n    return this;\n  }\n\n  /**\n   * Sets the user preferences for Chrome's user profile. See the \"Preferences\"\n   * file in Chrome's user data directory for examples.\n   * @param {!Object} prefs Dictionary of user preferences to use.\n   * @return {!Options} A self reference.\n   */\n  setUserPreferences(prefs) {\n    this.options_.prefs = prefs;\n    return this;\n  }\n\n  /**\n   * Sets the performance logging preferences. Options include:\n   *\n   * - `enableNetwork`: Whether or not to collect events from Network domain.\n   * - `enablePage`: Whether or not to collect events from Page domain.\n   * - `enableTimeline`: Whether or not to collect events from Timeline domain.\n   *     Note: when tracing is enabled, Timeline domain is implicitly disabled,\n   *     unless `enableTimeline` is explicitly set to true.\n   * - `tracingCategories`: A comma-separated string of Chrome tracing\n   *     categories for which trace events should be collected. An unspecified\n   *     or empty string disables tracing.\n   * - `bufferUsageReportingInterval`: The requested number of milliseconds\n   *     between DevTools trace buffer usage events. For example, if 1000, then\n   *     once per second, DevTools will report how full the trace buffer is. If\n   *     a report indicates the buffer usage is 100%, a warning will be issued.\n   *\n   * @param {{enableNetwork: boolean,\n   *          enablePage: boolean,\n   *          enableTimeline: boolean,\n   *          tracingCategories: string,\n   *          bufferUsageReportingInterval: number}} prefs The performance\n   *     logging preferences.\n   * @return {!Options} A self reference.\n   */\n  setPerfLoggingPrefs(prefs) {\n    this.options_.perfLoggingPrefs = prefs;\n    return this;\n  }\n\n  /**\n   * Sets preferences for the \"Local State\" file in Chrome's user data\n   * directory.\n   * @param {!Object} state Dictionary of local state preferences.\n   * @return {!Options} A self reference.\n   */\n  setLocalState(state) {\n    this.options_.localState = state;\n    return this;\n  }\n\n  /**\n   * Sets the name of the activity hosting a Chrome-based Android WebView. This\n   * option must be set to connect to an [Android WebView](\n   * https://sites.google.com/a/chromium.org/chromedriver/getting-started/getting-started---android)\n   *\n   * @param {string} name The activity name.\n   * @return {!Options} A self reference.\n   */\n  androidActivity(name) {\n    this.options_.androidActivity = name;\n    return this;\n  }\n\n  /**\n   * Sets the device serial number to connect to via ADB. If not specified, the\n   * ChromeDriver will select an unused device at random. An error will be\n   * returned if all devices already have active sessions.\n   *\n   * @param {string} serial The device serial number to connect to.\n   * @return {!Options} A self reference.\n   */\n  androidDeviceSerial(serial) {\n    this.options_.androidDeviceSerial = serial;\n    return this;\n  }\n\n  /**\n   * Configures the ChromeDriver to launch Chrome on Android via adb. This\n   * function is shorthand for\n   * {@link #androidPackage options.androidPackage('com.android.chrome')}.\n   * @return {!Options} A self reference.\n   */\n  androidChrome() {\n    return this.androidPackage('com.android.chrome');\n  }\n\n  /**\n   * Sets the package name of the Chrome or WebView app.\n   *\n   * @param {?string} pkg The package to connect to, or `null` to disable Android\n   *     and switch back to using desktop Chrome.\n   * @return {!Options} A self reference.\n   */\n  androidPackage(pkg) {\n    this.options_.androidPackage = pkg;\n    return this;\n  }\n\n  /**\n   * Sets the process name of the Activity hosting the WebView (as given by\n   * `ps`). If not specified, the process name is assumed to be the same as\n   * {@link #androidPackage}.\n   *\n   * @param {string} processName The main activity name.\n   * @return {!Options} A self reference.\n   */\n  androidProcess(processName) {\n    this.options_.androidProcess = processName;\n    return this;\n  }\n\n  /**\n   * Sets whether to connect to an already-running instead of the specified\n   * {@linkplain #androidProcess app} instead of launching the app with a clean\n   * data directory.\n   *\n   * @param {boolean} useRunning Whether to connect to a running instance.\n   * @return {!Options} A self reference.\n   */\n  androidUseRunningApp(useRunning) {\n    this.options_.androidUseRunningApp = useRunning;\n    return this;\n  }\n\n  /**\n   * Sets the path to Chrome's log file. This path should exist on the machine\n   * that will launch Chrome.\n   * @param {string} path Path to the log file to use.\n   * @return {!Options} A self reference.\n   */\n  setChromeLogFile(path) {\n    this.options_.logPath = path;\n    return this;\n  }\n\n  /**\n   * Sets the directory to store Chrome minidumps in. This option is only\n   * supported when ChromeDriver is running on Linux.\n   * @param {string} path The directory path.\n   * @return {!Options} A self reference.\n   */\n  setChromeMinidumpPath(path) {\n    this.options_.minidumpPath = path;\n    return this;\n  }\n\n  /**\n   * Configures Chrome to emulate a mobile device. For more information, refer\n   * to the ChromeDriver project page on [mobile emulation][em]. Configuration\n   * options include:\n   *\n   * - `deviceName`: The name of a pre-configured [emulated device][devem]\n   * - `width`: screen width, in pixels\n   * - `height`: screen height, in pixels\n   * - `pixelRatio`: screen pixel ratio\n   *\n   * __Example 1: Using a Pre-configured Device__\n   *\n   *     let options = new chrome.Options().setMobileEmulation(\n   *         {deviceName: 'Google Nexus 5'});\n   *\n   *     let driver = chrome.Driver.createSession(options);\n   *\n   * __Example 2: Using Custom Screen Configuration__\n   *\n   *     let options = new chrome.Options().setMobileEmulation({\n   *         width: 360,\n   *         height: 640,\n   *         pixelRatio: 3.0\n   *     });\n   *\n   *     let driver = chrome.Driver.createSession(options);\n   *\n   *\n   * [em]: https://sites.google.com/a/chromium.org/chromedriver/mobile-emulation\n   * [devem]: https://developer.chrome.com/devtools/docs/device-mode\n   *\n   * @param {?({deviceName: string}|\n   *           {width: number, height: number, pixelRatio: number})} config The\n   *     mobile emulation configuration, or `null` to disable emulation.\n   * @return {!Options} A self reference.\n   */\n  setMobileEmulation(config) {\n    this.options_.mobileEmulation = config;\n    return this;\n  }\n\n  /**\n   * Converts this instance to its JSON wire protocol representation. Note this\n   * function is an implementation not intended for general use.\n   *\n   * @return {!Object} The JSON wire protocol representation of this instance.\n   * @suppress {checkTypes} Suppress [] access on a struct.\n   */\n  [Symbols.serialize]() {\n    if (this.options_.extensions &&  this.options_.extensions.length) {\n      this.options_.extensions =\n          this.options_.extensions.map(function(extension) {\n            if (Buffer.isBuffer(extension)) {\n              return extension.toString('base64');\n            }\n            return io.read(/** @type {string} */(extension))\n                .then(buffer => buffer.toString('base64'));\n          });\n    }\n    return super[Symbols.serialize]();\n  }\n}\n\n\n/**\n * Creates a new WebDriver client for Chrome.\n */\nclass Driver extends webdriver.WebDriver {\n\n  /**\n   * Creates a new session with the ChromeDriver.\n   *\n   * @param {(Capabilities|Options)=} opt_config The configuration options.\n   * @param {(remote.DriverService|http.Executor)=} opt_serviceExecutor Either\n   *     a  DriverService to use for the remote end, or a preconfigured executor\n   *     for an externally managed endpoint. If neither is provided, the\n   *     {@linkplain ##getDefaultService default service} will be used by\n   *     default.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(opt_config, opt_serviceExecutor) {\n    let executor;\n    if (opt_serviceExecutor instanceof http.Executor) {\n      executor = opt_serviceExecutor;\n      configureExecutor(executor);\n    } else {\n      let service = opt_serviceExecutor || getDefaultService();\n      executor = createExecutor(service.start());\n    }\n\n    let caps = opt_config || Capabilities.chrome();\n\n    // W3C spec requires noProxy value to be an array of strings, but Chrome\n    // expects a single host as a string.\n    let proxy = caps.get(Capability.PROXY);\n    if (proxy && Array.isArray(proxy.noProxy)) {\n      proxy.noProxy = proxy.noProxy[0];\n      if (!proxy.noProxy) {\n        proxy.noProxy = undefined;\n      }\n    }\n\n    return /** @type {!Driver} */(super.createSession(executor, caps));\n  }\n\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n  setFileDetector() {}\n\n  /**\n   * Schedules a command to launch Chrome App with given ID.\n   * @param {string} id ID of the App to launch.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when app is launched.\n   */\n  launchApp(id) {\n    return this.execute(\n        new command.Command(Command.LAUNCH_APP).setParameter('id', id));\n  }\n\n  /**\n   * Schedules a command to get Chrome network emulation settings.\n   * @return {!Promise} A promise that will be resolved when network\n   *     emulation settings are retrievied.\n   */\n  getNetworkConditions() {\n    return this.execute(new command.Command(Command.GET_NETWORK_CONDITIONS));\n  }\n\n  /**\n   * Schedules a command to set Chrome network emulation settings.\n   *\n   * __Sample Usage:__\n   *\n   *  driver.setNetworkConditions({\n   *    offline: false,\n   *    latency: 5, // Additional latency (ms).\n   *    download_throughput: 500 * 1024, // Maximal aggregated download throughput.\n   *    upload_throughput: 500 * 1024 // Maximal aggregated upload throughput.\n   * });\n   *\n   * @param {Object} spec Defines the network conditions to set\n   * @return {!Promise<void>} A promise that will be resolved when network\n   *     emulation settings are set.\n   */\n  setNetworkConditions(spec) {\n    if (!spec || typeof spec !== 'object') {\n      throw TypeError('setNetworkConditions called with non-network-conditions parameter');\n    }\n    return this.execute(\n        new command.Command(Command.SET_NETWORK_CONDITIONS)\n            .setParameter('network_conditions', spec));\n  }\n\n  /**\n   * Sends an arbitrary devtools command to the browser.\n   *\n   * @param {string} cmd The name of the command to send.\n   * @param {Object=} params The command parameters.\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has finished.\n   * @see <https://chromedevtools.github.io/devtools-protocol/>\n   */\n  sendDevToolsCommand(cmd, params = {}) {\n    return this.execute(\n        new command.Command(Command.SEND_DEVTOOLS_COMMAND)\n            .setParameter('cmd', cmd)\n            .setParameter('params', params));\n  }\n\n  /**\n   * Sends a DevTools command to change Chrome's download directory.\n   *\n   * @param {string} path The desired download directory.\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has finished.\n   * @see #sendDevToolsCommand\n   */\n  async setDownloadPath(path) {\n    if (!path || typeof path !== 'string') {\n      throw new error.InvalidArgumentError('invalid download path');\n    }\n    const stat = await io.stat(path);\n    if (!stat.isDirectory()) {\n      throw new error.InvalidArgumentError('not a directory: ' + path);\n    }\n    return this.sendDevToolsCommand('Page.setDownloadBehavior', {\n      'behavior': 'allow',\n      'downloadPath': path\n    });\n  }\n}\n\n\n// PUBLIC API\n\n\nexports.Driver = Driver;\nexports.Options = Options;\nexports.ServiceBuilder = ServiceBuilder;\nexports.getDefaultService = getDefaultService;\nexports.setDefaultService = setDefaultService;\nexports.locateSynchronously = locateSynchronously;\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/chrome.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/edge.js":
/*!**************************************************!*\
  !*** ../node_modules/selenium-webdriver/edge.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a {@linkplain Driver WebDriver} client for\n * Microsoft's Edge web browser. Before using this module,\n * you must download and install the latest\n * [MicrosoftEdgeDriver](http://go.microsoft.com/fwlink/?LinkId=619687) server.\n * Ensure that the MicrosoftEdgeDriver is on your\n * [PATH](http://en.wikipedia.org/wiki/PATH_%28variable%29).\n *\n * There are three primary classes exported by this module:\n *\n * 1. {@linkplain ServiceBuilder}: configures the\n *     {@link ./remote.DriverService remote.DriverService}\n *     that manages the [MicrosoftEdgeDriver] child process.\n *\n * 2. {@linkplain Options}: defines configuration options for each new\n *     MicrosoftEdgeDriver session, such as which\n *     {@linkplain Options#setProxy proxy} to use when starting the browser.\n *\n * 3. {@linkplain Driver}: the WebDriver client; each new instance will control\n *     a unique browser session.\n *\n * __Customizing the MicrosoftEdgeDriver Server__ <a id=\"custom-server\"></a>\n *\n * By default, every MicrosoftEdge session will use a single driver service,\n * which is started the first time a {@link Driver} instance is created and\n * terminated when this process exits. The default service will inherit its\n * environment from the current process.\n * You may obtain a handle to this default service using\n * {@link #getDefaultService getDefaultService()} and change its configuration\n * with {@link #setDefaultService setDefaultService()}.\n *\n * You may also create a {@link Driver} with its own driver service. This is\n * useful if you need to capture the server's log output for a specific session:\n *\n *     var edge = require('selenium-webdriver/edge');\n *\n *     var service = new edge.ServiceBuilder()\n *         .setPort(55555)\n *         .build();\n *\n *     var options = new edge.Options();\n *     // configure browser options ...\n *\n *     var driver = edge.Driver.createSession(options, service);\n *\n * Users should only instantiate the {@link Driver} class directly when they\n * need a custom driver service configuration (as shown above). For normal\n * operation, users should start MicrosoftEdge using the\n * {@link ./builder.Builder selenium-webdriver.Builder}.\n *\n * [MicrosoftEdgeDriver]: https://msdn.microsoft.com/en-us/library/mt188085(v=vs.85).aspx\n */\n\n\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst http = __webpack_require__(/*! ./http */ \"../node_modules/selenium-webdriver/http/index.js\");\nconst io = __webpack_require__(/*! ./io */ \"../node_modules/selenium-webdriver/io/index.js\");\nconst portprober = __webpack_require__(/*! ./net/portprober */ \"../node_modules/selenium-webdriver/net/portprober.js\");\nconst promise = __webpack_require__(/*! ./lib/promise */ \"../node_modules/selenium-webdriver/lib/promise.js\");\nconst remote = __webpack_require__(/*! ./remote */ \"../node_modules/selenium-webdriver/remote/index.js\");\nconst Symbols = __webpack_require__(/*! ./lib/symbols */ \"../node_modules/selenium-webdriver/lib/symbols.js\");\nconst webdriver = __webpack_require__(/*! ./lib/webdriver */ \"../node_modules/selenium-webdriver/lib/webdriver.js\");\nconst {Browser, Capabilities} = __webpack_require__(/*! ./lib/capabilities */ \"../node_modules/selenium-webdriver/lib/capabilities.js\");\n\nconst EDGEDRIVER_EXE = 'MicrosoftWebDriver.exe';\n\n\n/**\n * _Synchronously_ attempts to locate the edge driver executable on the current\n * system.\n *\n * @return {?string} the located executable, or `null`.\n */\nfunction locateSynchronously() {\n  return process.platform === 'win32'\n      ? io.findInPath(EDGEDRIVER_EXE, true) : null;\n}\n\n\n/**\n * Class for managing MicrosoftEdgeDriver specific options.\n */\nclass Options extends Capabilities {\n  /**\n   * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of\n   *     capabilities to initialize this instance from.\n   */\n  constructor(other = undefined) {\n    super(other);\n    this.setBrowserName(Browser.EDGE);\n  }\n}\n\n\n/**\n * Creates {@link remote.DriverService} instances that manage a\n * MicrosoftEdgeDriver server in a child process.\n */\nclass ServiceBuilder extends remote.DriverService.Builder {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *   the builder will attempt to locate the MicrosoftEdgeDriver on the current\n   *   PATH.\n   * @throws {Error} If provided executable does not exist, or the\n   *   MicrosoftEdgeDriver cannot be found on the PATH.\n   */\n  constructor(opt_exe) {\n    let exe = opt_exe || locateSynchronously();\n    if (!exe) {\n      throw Error(\n        'The ' + EDGEDRIVER_EXE + ' could not be found on the current PATH. ' +\n        'Please download the latest version of the MicrosoftEdgeDriver from ' +\n        'https://www.microsoft.com/en-us/download/details.aspx?id=48212 and ' +\n        'ensure it can be found on your PATH.');\n    }\n\n    super(exe);\n\n    // Binding to the loopback address will fail if not running with\n    // administrator privileges. Since we cannot test for that in script\n    // (or can we?), force the DriverService to use \"localhost\".\n    this.setHostname('localhost');\n  }\n\n  /**\n   * Enables verbose logging.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  enableVerboseLogging() {\n    return this.addArguments('--verbose');\n  }\n}\n\n\n/** @type {remote.DriverService} */\nvar defaultService = null;\n\n\n/**\n * Sets the default service to use for new MicrosoftEdgeDriver instances.\n * @param {!remote.DriverService} service The service to use.\n * @throws {Error} If the default service is currently running.\n */\nfunction setDefaultService(service) {\n  if (defaultService && defaultService.isRunning()) {\n    throw Error(\n      'The previously configured EdgeDriver service is still running. ' +\n      'You must shut it down before you may adjust its configuration.');\n  }\n  defaultService = service;\n}\n\n\n/**\n * Returns the default MicrosoftEdgeDriver service. If such a service has\n * not been configured, one will be constructed using the default configuration\n * for an MicrosoftEdgeDriver executable found on the system PATH.\n * @return {!remote.DriverService} The default MicrosoftEdgeDriver service.\n */\nfunction getDefaultService() {\n  if (!defaultService) {\n    defaultService = new ServiceBuilder().build();\n  }\n  return defaultService;\n}\n\n\n/**\n * Creates a new WebDriver client for Microsoft's Edge.\n */\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new browser session for Microsoft's Edge browser.\n   *\n   * @param {(Capabilities|Options)=} options The configuration options.\n   * @param {remote.DriverService=} service The session to use; will use\n   *     the {@linkplain #getDefaultService default service} by default.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(options, service = getDefaultService()) {\n    let client = service.start().then(url => new http.HttpClient(url));\n    let executor = new http.Executor(client);\n\n    options = options || new Options();\n    return /** @type {!Driver} */(super.createSession(\n        executor, options, () => service.kill()));\n  }\n\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n  setFileDetector() {}\n}\n\n\n// PUBLIC API\n\n\nexports.Driver = Driver;\nexports.Options = Options;\nexports.ServiceBuilder = ServiceBuilder;\nexports.getDefaultService = getDefaultService;\nexports.setDefaultService = setDefaultService;\nexports.locateSynchronously = locateSynchronously;\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/edge.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/firefox.js":
/*!*****************************************************!*\
  !*** ../node_modules/selenium-webdriver/firefox.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines the {@linkplain Driver WebDriver} client for Firefox.\n * Before using this module, you must download the latest\n * [geckodriver release] and ensure it can be found on your system [PATH].\n *\n * Each FirefoxDriver instance will be created with an anonymous profile,\n * ensuring browser historys do not share session data (cookies, history, cache,\n * offline storage, etc.)\n *\n * __Customizing the Firefox Profile__\n *\n * The profile used for each WebDriver session may be configured using the\n * {@linkplain Options} class. For example, you may install an extension, like\n * Firebug:\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options()\n *         .addExtensions('/path/to/firebug.xpi')\n *         .setPreference('extensions.firebug.showChromeErrors', true);\n *\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * The {@linkplain Options} class may also be used to configure WebDriver based\n * on a pre-existing browser profile:\n *\n *     let profile = '/usr/local/home/bob/.mozilla/firefox/3fgog75h.testing';\n *     let options = new firefox.Options().setProfile(profile);\n *\n * The FirefoxDriver will _never_ modify a pre-existing profile; instead it will\n * create a copy for it to modify. By extension, there are certain browser\n * preferences that are required for WebDriver to function properly and they\n * will always be overwritten.\n *\n * __Using a Custom Firefox Binary__\n *\n * On Windows and MacOS, the FirefoxDriver will search for Firefox in its\n * default installation location:\n *\n * - Windows: C:\\Program Files and C:\\Program Files (x86).\n * - MacOS: /Applications/Firefox.app\n *\n * For Linux, Firefox will always be located on the PATH: `$(where firefox)`.\n *\n * Several methods are provided for starting Firefox with a custom executable.\n * First, on Windows and MacOS, you may configure WebDriver to check the default\n * install location for a non-release channel. If the requested channel cannot\n * be found in its default location, WebDriver will fallback to searching your\n * PATH. _Note:_ on Linux, Firefox is _always_ located on your path, regardless\n * of the requested channel.\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options().setBinary(firefox.Channel.NIGHTLY);\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * On all platforms, you may configrue WebDriver to use a Firefox specific\n * executable:\n *\n *     let options = new firefox.Options()\n *         .setBinary('/my/firefox/install/dir/firefox-bin');\n *\n * __Remote Testing__\n *\n * You may customize the Firefox binary and profile when running against a\n * remote Selenium server. Your custom profile will be packaged as a zip and\n * transfered to the remote host for use. The profile will be transferred\n * _once for each new session_. The performance impact should be minimal if\n * you've only configured a few extra browser preferences. If you have a large\n * profile with several extensions, you should consider installing it on the\n * remote host and defining its path via the {@link Options} class. Custom\n * binaries are never copied to remote machines and must be referenced by\n * installation path.\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options()\n *         .setProfile('/profile/path/on/remote/host')\n *         .setBinary('/install/dir/on/remote/host/firefox-bin');\n *\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .usingServer('http://127.0.0.1:4444/wd/hub')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * [geckodriver release]: https://github.com/mozilla/geckodriver/releases/\n * [PATH]: http://en.wikipedia.org/wiki/PATH_%28variable%29\n */\n\n\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst url = __webpack_require__(/*! url */ \"url\");\n\nconst Symbols = __webpack_require__(/*! ./lib/symbols */ \"../node_modules/selenium-webdriver/lib/symbols.js\");\nconst command = __webpack_require__(/*! ./lib/command */ \"../node_modules/selenium-webdriver/lib/command.js\");\nconst exec = __webpack_require__(/*! ./io/exec */ \"../node_modules/selenium-webdriver/io/exec.js\");\nconst http = __webpack_require__(/*! ./http */ \"../node_modules/selenium-webdriver/http/index.js\");\nconst httpUtil = __webpack_require__(/*! ./http/util */ \"../node_modules/selenium-webdriver/http/util.js\");\nconst io = __webpack_require__(/*! ./io */ \"../node_modules/selenium-webdriver/io/index.js\");\nconst net = __webpack_require__(/*! ./net */ \"../node_modules/selenium-webdriver/net/index.js\");\nconst portprober = __webpack_require__(/*! ./net/portprober */ \"../node_modules/selenium-webdriver/net/portprober.js\");\nconst remote = __webpack_require__(/*! ./remote */ \"../node_modules/selenium-webdriver/remote/index.js\");\nconst webdriver = __webpack_require__(/*! ./lib/webdriver */ \"../node_modules/selenium-webdriver/lib/webdriver.js\");\nconst zip = __webpack_require__(/*! ./io/zip */ \"../node_modules/selenium-webdriver/io/zip.js\");\nconst {Browser, Capabilities} = __webpack_require__(/*! ./lib/capabilities */ \"../node_modules/selenium-webdriver/lib/capabilities.js\");\nconst {Zip} = __webpack_require__(/*! ./io/zip */ \"../node_modules/selenium-webdriver/io/zip.js\");\n\n\n/**\n * Thrown when there an add-on is malformed.\n * @final\n */\nclass AddonFormatError extends Error {\n  /** @param {string} msg The error message. */\n  constructor(msg) {\n    super(msg);\n    /** @override */\n    this.name = this.constructor.name;\n  }\n}\n\n\n/**\n * Installs an extension to the given directory.\n * @param {string} extension Path to the xpi extension file to install.\n * @param {string} dir Path to the directory to install the extension in.\n * @return {!Promise<string>} A promise for the add-on ID once\n *     installed.\n */\nasync function installExtension(extension, dir) {\n  if (extension.slice(-4) !== '.xpi') {\n    throw Error('Path ath is not a xpi file: ' + extension);\n  }\n\n  let archive = await zip.load(extension);\n  if (!archive.has('manifest.json')) {\n    throw new AddonFormatError(`Couldn't find manifest.json in ${extension}`);\n  }\n\n  let buf = await archive.getFile('manifest.json');\n  let {applications} =\n      /** @type {{applications:{gecko:{id:string}}}} */(\n          JSON.parse(buf.toString('utf8')));\n  if (!(applications && applications.gecko && applications.gecko.id)) {\n    throw new AddonFormatError(`Could not find add-on ID for ${extension}`);\n  }\n\n  await io.copy(extension, `${path.join(dir, applications.gecko.id)}.xpi`);\n  return applications.gecko.id;\n}\n\n\nclass Profile {\n  constructor() {\n    /** @private {?string} */\n    this.template_ = null;\n\n    /** @private {!Array<string>} */\n    this.extensions_ = [];\n  }\n\n  addExtensions(/** !Array<string> */paths) {\n    this.extensions_ = this.extensions_.concat(...paths);\n  }\n\n  /**\n   * @return {(!Promise<string>|undefined)} a promise for a base64 encoded\n   *     profile, or undefined if there's no data to include.\n   */\n  [Symbols.serialize]() {\n    if (this.template_ || this.extensions_.length) {\n      return buildProfile(this.template_, this.extensions_);\n    }\n    return undefined;\n  }\n}\n\n\n/**\n * @param {?string} template path to an existing profile to use as a template.\n * @param {!Array<string>} extensions paths to extensions to install in the new\n *     profile.\n * @return {!Promise<string>} a promise for the base64 encoded profile.\n */\nasync function buildProfile(template, extensions) {\n  let dir = template;\n\n  if (extensions.length) {\n    dir = await io.tmpDir();\n    if (template) {\n      await io.copyDir(\n          /** @type {string} */(template),\n          dir, /(parent\\.lock|lock|\\.parentlock)/);\n    }\n\n    const extensionsDir = path.join(dir, 'extensions');\n    await io.mkdir(extensionsDir);\n\n    for (let i = 0; i < extensions.length; i++) {\n      await installExtension(extensions[i], extensionsDir);\n    }\n  }\n\n  let zip = new Zip;\n  return zip.addDir(dir)\n      .then(() => zip.toBuffer())\n      .then(buf => buf.toString('base64'));\n}\n\n\n/**\n * Configuration options for the FirefoxDriver.\n */\nclass Options extends Capabilities {\n  /**\n   * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of\n   *     capabilities to initialize this instance from.\n   */\n  constructor(other) {\n    super(other);\n    this.setBrowserName(Browser.FIREFOX);\n  }\n\n  /**\n   * @return {!Object}\n   * @private\n   */\n  firefoxOptions_() {\n    let options = this.get('moz:firefoxOptions');\n    if (!options) {\n      options = {};\n      this.set('moz:firefoxOptions', options);\n    }\n    return options;\n  }\n\n  /**\n   * @return {!Profile}\n   * @private\n   */\n  profile_() {\n    let options = this.firefoxOptions_();\n    if (!options.profile) {\n      options.profile = new Profile();\n    }\n    return options.profile;\n  }\n\n  /**\n   * Specify additional command line arguments that should be used when starting\n   * the Firefox browser.\n   *\n   * @param {...(string|!Array<string>)} args The arguments to include.\n   * @return {!Options} A self reference.\n   */\n  addArguments(...args) {\n    if (args.length) {\n      let options = this.firefoxOptions_();\n      options.args = options.args ? options.args.concat(...args) : args;\n    }\n    return this;\n  }\n\n  /**\n   * Configures the geckodriver to start Firefox in headless mode.\n   *\n   * @return {!Options} A self reference.\n   */\n  headless() {\n    return this.addArguments('-headless');\n  }\n\n  /**\n   * Sets the initial window size when running in\n   * {@linkplain #headless headless} mode.\n   *\n   * @param {{width: number, height: number}} size The desired window size.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if width or height is unspecified, not a number, or\n   *     less than or equal to 0.\n   */\n  windowSize({width, height}) {\n    function checkArg(arg) {\n      if (typeof arg !== 'number' || arg <= 0) {\n        throw TypeError('Arguments must be {width, height} with numbers > 0');\n      }\n    }\n    checkArg(width);\n    checkArg(height);\n    return this.addArguments(`--window-size=${width},${height}`);\n  }\n\n  /**\n   * Add extensions that should be installed when starting Firefox.\n   *\n   * @param {...string} paths The paths to the extension XPI files to install.\n   * @return {!Options} A self reference.\n   */\n  addExtensions(...paths) {\n    this.profile_().addExtensions(paths);\n    return this;\n  }\n\n  /**\n   * @param {string} key the preference key.\n   * @param {(string|number|boolean)} value the preference value.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if either the key or value has an invalid type.\n   */\n  setPreference(key, value) {\n    if (typeof key !== 'string') {\n      throw TypeError(`key must be a string, but got ${typeof key}`);\n    }\n    if (typeof value !== 'string'\n        && typeof value !== 'number'\n        && typeof value !== 'boolean') {\n      throw TypeError(\n          `value must be a string, number, or boolean, but got ${typeof value}`);\n    }\n    let options = this.firefoxOptions_();\n    options.prefs = options.prefs || {};\n    options.prefs[key] = value;\n    return this;\n  }\n\n  /**\n   * Sets the path to an existing profile to use as a template for new browser\n   * sessions. This profile will be copied for each new session - changes will\n   * not be applied to the profile itself.\n   *\n   * @param {string} profile The profile to use.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if profile is not a string.\n   */\n  setProfile(profile) {\n    if (typeof profile !== 'string') {\n      throw TypeError(`profile must be a string, but got ${typeof profile}`);\n    }\n    this.profile_().template_ = profile;\n    return this;\n  }\n\n  /**\n   * Sets the binary to use. The binary may be specified as the path to a\n   * Firefox executable or a desired release {@link Channel}.\n   *\n   * @param {(string|!Channel)} binary The binary to use.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} If `binary` is an invalid type.\n   */\n  setBinary(binary) {\n    if (binary instanceof Channel || typeof binary === 'string') {\n      this.firefoxOptions_().binary = binary;\n      return this;\n    }\n    throw TypeError('binary must be a string path or Channel object');\n  }\n}\n\n\n/**\n * Enum of available command contexts.\n *\n * Command contexts are specific to Marionette, and may be used with the\n * {@link #context=} method. Contexts allow you to direct all subsequent\n * commands to either \"content\" (default) or \"chrome\". The latter gives\n * you elevated security permissions.\n *\n * @enum {string}\n */\nconst Context = {\n  CONTENT: \"content\",\n  CHROME: \"chrome\",\n};\n\n\nconst GECKO_DRIVER_EXE =\n    process.platform === 'win32' ? 'geckodriver.exe' : 'geckodriver';\n\n\n/**\n * _Synchronously_ attempts to locate the geckodriver executable on the current\n * system.\n *\n * @return {?string} the located executable, or `null`.\n */\nfunction locateSynchronously() {\n  return io.findInPath(GECKO_DRIVER_EXE, true);\n}\n\n\n/**\n * @return {string} .\n * @throws {Error}\n */\nfunction findGeckoDriver() {\n  let exe = locateSynchronously();\n  if (!exe) {\n    throw Error(\n      'The ' + GECKO_DRIVER_EXE + ' executable could not be found on the current ' +\n      'PATH. Please download the latest version from ' +\n      'https://github.com/mozilla/geckodriver/releases/ ' +\n      'and ensure it can be found on your PATH.');\n  }\n  return exe;\n}\n\n\n/**\n * @param {string} file Path to the file to find, relative to the program files\n *     root.\n * @return {!Promise<?string>} A promise for the located executable.\n *     The promise will resolve to {@code null} if Firefox was not found.\n */\nfunction findInProgramFiles(file) {\n  let files = [\n    process.env['PROGRAMFILES'] || 'C:\\\\Program Files',\n    process.env['PROGRAMFILES(X86)'] || 'C:\\\\Program Files (x86)'\n  ].map(prefix => path.join(prefix, file));\n  return io.exists(files[0]).then(function(exists) {\n    return exists ? files[0] : io.exists(files[1]).then(function(exists) {\n      return exists ? files[1] : null;\n    });\n  });\n}\n\n\n/** @enum {string} */\nconst ExtensionCommand = {\n  GET_CONTEXT: 'getContext',\n  SET_CONTEXT: 'setContext',\n  INSTALL_ADDON: 'install addon',\n  UNINSTALL_ADDON: 'uninstall addon',\n};\n\n\n/**\n * Creates a command executor with support for Marionette's custom commands.\n * @param {!Promise<string>} serverUrl The server's URL.\n * @return {!command.Executor} The new command executor.\n */\nfunction createExecutor(serverUrl) {\n  let client = serverUrl.then(url => new http.HttpClient(url));\n  let executor = new http.Executor(client);\n  configureExecutor(executor);\n  return executor;\n}\n\n\n/**\n * Configures the given executor with Firefox-specific commands.\n * @param {!http.Executor} executor the executor to configure.\n */\nfunction configureExecutor(executor) {\n  executor.defineCommand(\n      ExtensionCommand.GET_CONTEXT,\n      'GET',\n      '/session/:sessionId/moz/context');\n\n  executor.defineCommand(\n      ExtensionCommand.SET_CONTEXT,\n      'POST',\n      '/session/:sessionId/moz/context');\n\n  executor.defineCommand(\n      ExtensionCommand.INSTALL_ADDON,\n      'POST',\n      '/session/:sessionId/moz/addon/install');\n\n  executor.defineCommand(\n      ExtensionCommand.UNINSTALL_ADDON,\n      'POST',\n      '/session/:sessionId/moz/addon/uninstall');\n}\n\n\n/**\n * Creates {@link selenium-webdriver/remote.DriverService} instances that manage\n * a [geckodriver](https://github.com/mozilla/geckodriver) server in a child\n * process.\n */\nclass ServiceBuilder extends remote.DriverService.Builder {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *     the builder will attempt to locate the geckodriver on the system PATH.\n   */\n  constructor(opt_exe) {\n    super(opt_exe || findGeckoDriver());\n    this.setLoopback(true);  // Required.\n  }\n\n  /**\n   * Enables verbose logging.\n   *\n   * @param {boolean=} opt_trace Whether to enable trace-level logging. By\n   *     default, only debug logging is enabled.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  enableVerboseLogging(opt_trace) {\n    return this.addArguments(opt_trace ? '-vv' : '-v');\n  }\n}\n\n\n/**\n * A WebDriver client for Firefox.\n */\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new Firefox session.\n   *\n   * @param {(Options|Capabilities|Object)=} opt_config The\n   *    configuration options for this driver, specified as either an\n   *    {@link Options} or {@link Capabilities}, or as a raw hash object.\n   * @param {(http.Executor|remote.DriverService)=} opt_executor Either a\n   *   pre-configured command executor to use for communicating with an\n   *   externally managed remote end (which is assumed to already be running),\n   *   or the `DriverService` to use to start the geckodriver in a child\n   *   process.\n   *\n   *   If an executor is provided, care should e taken not to use reuse it with\n   *   other clients as its internal command mappings will be updated to support\n   *   Firefox-specific commands.\n   *\n   *   _This parameter may only be used with Mozilla's GeckoDriver._\n   *\n   * @throws {Error} If a custom command executor is provided and the driver is\n   *     configured to use the legacy FirefoxDriver from the Selenium project.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(opt_config, opt_executor) {\n    let caps =\n        opt_config instanceof Capabilities\n            ? opt_config : new Options(opt_config);\n\n    let executor;\n    let onQuit;\n\n    if (opt_executor instanceof http.Executor) {\n      executor = opt_executor;\n      configureExecutor(executor);\n    } else if (opt_executor instanceof remote.DriverService) {\n      executor = createExecutor(opt_executor.start());\n      onQuit = () => opt_executor.kill();\n    } else {\n      let service = new ServiceBuilder().build();\n      executor = createExecutor(service.start());\n      onQuit = () => service.kill();\n    }\n\n    return /** @type {!Driver} */(super.createSession(executor, caps, onQuit));\n  }\n\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n  setFileDetector() {\n  }\n\n  /**\n   * Get the context that is currently in effect.\n   *\n   * @return {!Promise<Context>} Current context.\n   */\n  getContext() {\n    return this.execute(new command.Command(ExtensionCommand.GET_CONTEXT));\n  }\n\n  /**\n   * Changes target context for commands between chrome- and content.\n   *\n   * Changing the current context has a stateful impact on all subsequent\n   * commands. The {@link Context.CONTENT} context has normal web\n   * platform document permissions, as if you would evaluate arbitrary\n   * JavaScript. The {@link Context.CHROME} context gets elevated\n   * permissions that lets you manipulate the browser chrome itself,\n   * with full access to the XUL toolkit.\n   *\n   * Use your powers wisely.\n   *\n   * @param {!Promise<void>} ctx The context to switch to.\n   */\n  setContext(ctx) {\n    return this.execute(\n        new command.Command(ExtensionCommand.SET_CONTEXT)\n            .setParameter(\"context\", ctx));\n  }\n\n  /**\n   * Installs a new addon with the current session. This function will return an\n   * ID that may later be used to {@linkplain #uninstallAddon uninstall} the\n   * addon.\n   *\n   *\n   * @param {string} path Path on the local filesystem to the web extension to\n   *     install.\n   * @return {!Promise<string>} A promise that will resolve to an ID for the\n   *     newly installed addon.\n   * @see #uninstallAddon\n   */\n  async installAddon(path) {\n    let buf = await io.read(path);\n    return this.execute(\n        new command.Command(ExtensionCommand.INSTALL_ADDON)\n            .setParameter('addon', buf.toString('base64')));\n  }\n\n  /**\n   * Uninstalls an addon from the current browser session's profile.\n   *\n   * @param {(string|!Promise<string>)} id ID of the addon to uninstall.\n   * @return {!Promise} A promise that will resolve when the operation has\n   *     completed.\n   * @see #installAddon\n   */\n  async uninstallAddon(id) {\n    id = await Promise.resolve(id);\n    return this.execute(\n        new command.Command(ExtensionCommand.UNINSTALL_ADDON)\n            .setParameter('id', id));\n  }\n}\n\n\n/**\n * Provides methods for locating the executable for a Firefox release channel\n * on Windows and MacOS. For other systems (i.e. Linux), Firefox will always\n * be located on the system PATH.\n *\n * @final\n */\nclass Channel {\n  /**\n   * @param {string} darwin The path to check when running on MacOS.\n   * @param {string} win32 The path to check when running on Windows.\n   */\n  constructor(darwin, win32) {\n    /** @private @const */ this.darwin_ = darwin;\n    /** @private @const */ this.win32_ = win32;\n    /** @private {Promise<string>} */\n    this.found_ = null;\n  }\n\n  /**\n   * Attempts to locate the Firefox executable for this release channel. This\n   * will first check the default installation location for the channel before\n   * checking the user's PATH. The returned promise will be rejected if Firefox\n   * can not be found.\n   *\n   * @return {!Promise<string>} A promise for the location of the located\n   *     Firefox executable.\n   */\n  locate() {\n    if (this.found_) {\n      return this.found_;\n    }\n\n    let found;\n    switch (process.platform) {\n      case 'darwin':\n        found = io.exists(this.darwin_)\n            .then(exists => exists ? this.darwin_ : io.findInPath('firefox'));\n        break;\n\n      case 'win32':\n        found = findInProgramFiles(this.win32_)\n            .then(found => found || io.findInPath('firefox.exe'));\n        break;\n\n      default:\n        found = Promise.resolve(io.findInPath('firefox'));\n        break;\n    }\n\n    this.found_ = found.then(found => {\n      if (found) {\n        // TODO: verify version info.\n        return found;\n      }\n      throw Error('Could not locate Firefox on the current system');\n    });\n    return this.found_;\n  }\n\n  /** @return {!Promise<string>} */\n  [Symbols.serialize]() {\n    return this.locate();\n  }\n}\n\n\n/**\n * Firefox's developer channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#aurora>\n */\nChannel.AURORA = new Channel(\n  '/Applications/FirefoxDeveloperEdition.app/Contents/MacOS/firefox-bin',\n  'Firefox Developer Edition\\\\firefox.exe');\n\n/**\n * Firefox's beta channel. Note this is provided mainly for convenience as\n * the beta channel has the same installation location as the main release\n * channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#beta>\n */\nChannel.BETA = new Channel(\n  '/Applications/Firefox.app/Contents/MacOS/firefox-bin',\n  'Mozilla Firefox\\\\firefox.exe');\n\n/**\n * Firefox's release channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/desktop/>\n */\nChannel.RELEASE = new Channel(\n  '/Applications/Firefox.app/Contents/MacOS/firefox-bin',\n  'Mozilla Firefox\\\\firefox.exe');\n\n/**\n * Firefox's nightly release channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#nightly>\n */\nChannel.NIGHTLY = new Channel(\n  '/Applications/Firefox Nightly.app/Contents/MacOS/firefox-bin',\n  'Nightly\\\\firefox.exe');\n\n\n// PUBLIC API\n\n\nexports.Channel = Channel;\nexports.Context = Context;\nexports.Driver = Driver;\nexports.Options = Options;\nexports.ServiceBuilder = ServiceBuilder;\nexports.locateSynchronously = locateSynchronously;\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/firefox.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/http/index.js":
/*!********************************************************!*\
  !*** ../node_modules/selenium-webdriver/http/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines an {@linkplain cmd.Executor command executor} that\n * communicates with a remote end using HTTP + JSON.\n */\n\n\n\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst url = __webpack_require__(/*! url */ \"url\");\n\nconst httpLib = __webpack_require__(/*! ../lib/http */ \"../node_modules/selenium-webdriver/lib/http.js\");\n\n\n/**\n * @typedef {{protocol: (?string|undefined),\n *            auth: (?string|undefined),\n *            hostname: (?string|undefined),\n *            host: (?string|undefined),\n *            port: (?string|undefined),\n *            path: (?string|undefined),\n *            pathname: (?string|undefined)}}\n */\nvar RequestOptions;\n\n\n/**\n * @param {string} aUrl The request URL to parse.\n * @return {RequestOptions} The request options.\n * @throws {Error} if the URL does not include a hostname.\n */\nfunction getRequestOptions(aUrl) {\n  let options = url.parse(aUrl);\n  if (!options.hostname) {\n    throw new Error('Invalid URL: ' + aUrl);\n  }\n  // Delete the search and has portions as they are not used.\n  options.search = null;\n  options.hash = null;\n  options.path = options.pathname;\n  return options;\n}\n\n\n/**\n * A basic HTTP client used to send messages to a remote end.\n *\n * @implements {httpLib.Client}\n */\nclass HttpClient {\n  /**\n   * @param {string} serverUrl URL for the WebDriver server to send commands to.\n   * @param {http.Agent=} opt_agent The agent to use for each request.\n   *     Defaults to `http.globalAgent`.\n   * @param {?string=} opt_proxy The proxy to use for the connection to the\n   *     server. Default is to use no proxy.\n   */\n  constructor(serverUrl, opt_agent, opt_proxy) {\n    /** @private {http.Agent} */\n    this.agent_ = opt_agent || null;\n\n    /**\n     * Base options for each request.\n     * @private {RequestOptions}\n     */\n    this.options_ = getRequestOptions(serverUrl);\n\n    /**\n     * @private {?RequestOptions}\n     */\n    this.proxyOptions_ = opt_proxy ? getRequestOptions(opt_proxy) : null;\n  }\n\n  /** @override */\n  send(httpRequest) {\n    let data;\n\n    let headers = {};\n    httpRequest.headers.forEach(function(value, name) {\n      headers[name] = value;\n    });\n\n    headers['Content-Length'] = 0;\n    if (httpRequest.method == 'POST' || httpRequest.method == 'PUT') {\n      data = JSON.stringify(httpRequest.data);\n      headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n      headers['Content-Type'] = 'application/json;charset=UTF-8';\n    }\n\n    let path = this.options_.path;\n    if (path.endsWith('/') && httpRequest.path.startsWith('/')) {\n      path += httpRequest.path.substring(1);\n    } else {\n      path += httpRequest.path;\n    }\n    let parsedPath = url.parse(path);\n\n    let options = {\n      agent: this.agent_ || null,\n      method: httpRequest.method,\n\n      auth: this.options_.auth,\n      hostname: this.options_.hostname,\n      port: this.options_.port,\n      protocol: this.options_.protocol,\n\n      path: parsedPath.path,\n      pathname: parsedPath.pathname,\n      search: parsedPath.search,\n      hash: parsedPath.hash,\n\n      headers,\n    };\n\n    return new Promise((fulfill, reject) => {\n      sendRequest(options, fulfill, reject, data, this.proxyOptions_);\n    });\n  }\n}\n\n\n/**\n * Sends a single HTTP request.\n * @param {!Object} options The request options.\n * @param {function(!httpLib.Response)} onOk The function to call if the\n *     request succeeds.\n * @param {function(!Error)} onError The function to call if the request fails.\n * @param {?string=} opt_data The data to send with the request.\n * @param {?RequestOptions=} opt_proxy The proxy server to use for the request.\n * @param {number=} opt_retries The current number of retries.\n */\nfunction sendRequest(options, onOk, onError, opt_data, opt_proxy, opt_retries) {\n  var hostname = options.hostname;\n  var port = options.port;\n\n  if (opt_proxy) {\n    let proxy = /** @type {RequestOptions} */(opt_proxy);\n\n    // RFC 2616, section 5.1.2:\n    // The absoluteURI form is REQUIRED when the request is being made to a\n    // proxy.\n    let absoluteUri = url.format(options);\n\n    // RFC 2616, section 14.23:\n    // An HTTP/1.1 proxy MUST ensure that any request message it forwards does\n    // contain an appropriate Host header field that identifies the service\n    // being requested by the proxy.\n    let targetHost = options.hostname;\n    if (options.port) {\n      targetHost += ':' + options.port;\n    }\n\n    // Update the request options with our proxy info.\n    options.headers['Host'] = targetHost;\n    options.path = absoluteUri;\n    options.host = proxy.host;\n    options.hostname = proxy.hostname;\n    options.port = proxy.port;\n\n    if (proxy.auth) {\n      options.headers['Proxy-Authorization'] =\n          'Basic ' + new Buffer(proxy.auth).toString('base64');\n    }\n  }\n\n  let requestFn = options.protocol === 'https:' ? https.request : http.request;\n  var request = requestFn(options, function onResponse(response) {\n    if (response.statusCode == 302 || response.statusCode == 303) {\n      try {\n        var location = url.parse(response.headers['location']);\n      } catch (ex) {\n        onError(Error(\n            'Failed to parse \"Location\" header for server redirect: ' +\n            ex.message + '\\nResponse was: \\n' +\n            new httpLib.Response(response.statusCode, response.headers, '')));\n        return;\n      }\n\n      if (!location.hostname) {\n        location.hostname = hostname;\n        location.port = port;\n      }\n\n      request.abort();\n      sendRequest({\n        method: 'GET',\n        protocol: location.protocol || options.protocol,\n        hostname: location.hostname,\n        port: location.port,\n        path: location.path,\n        pathname: location.pathname,\n        search: location.search,\n        hash: location.hash,\n        headers: {\n          'Accept': 'application/json; charset=utf-8'\n        }\n      }, onOk, onError, undefined, opt_proxy);\n      return;\n    }\n\n    var body = [];\n    response.on('data', body.push.bind(body));\n    response.on('end', function() {\n      var resp = new httpLib.Response(\n          /** @type {number} */(response.statusCode),\n          /** @type {!Object<string>} */(response.headers),\n          body.join('').replace(/\\0/g, ''));\n      onOk(resp);\n    });\n  });\n\n  request.on('error', function(e) {\n    if (typeof opt_retries === 'undefined') {\n      opt_retries = 0;\n    }\n\n    if (shouldRetryRequest(opt_retries, e)) {\n      opt_retries += 1;\n      setTimeout(function() {\n        sendRequest(options, onOk, onError, opt_data, opt_proxy, opt_retries);\n      }, 15);\n    } else {\n      var message = e.message;\n      if (e.code) {\n        message = e.code + ' ' + message;\n      }\n      onError(new Error(message));\n    }\n  });\n\n  if (opt_data) {\n    request.write(opt_data);\n  }\n\n  request.end();\n}\n\n\nconst MAX_RETRIES = 3;\n\n/**\n * A retry is sometimes needed on Windows where we may quickly run out of\n * ephemeral ports. A more robust solution is bumping the MaxUserPort setting\n * as described here: http://msdn.microsoft.com/en-us/library/aa560610%28v=bts.20%29.aspx\n *\n * @param {!number} retries\n * @param {!Error} err\n * @return {boolean}\n */\nfunction shouldRetryRequest(retries, err) {\n  return retries < MAX_RETRIES && isRetryableNetworkError(err);\n}\n\n/**\n * @param {!Error} err\n * @return {boolean}\n */\nfunction isRetryableNetworkError(err) {\n  if (err && err.code) {\n    return err.code === 'ECONNABORTED' ||\n          err.code === 'ECONNRESET' ||\n          err.code === 'EADDRINUSE' ||\n          err.code === 'EPIPE';\n  }\n\n  return false;\n}\n\n\n// PUBLIC API\n\nexports.Executor = httpLib.Executor;\nexports.HttpClient = HttpClient;\nexports.Request = httpLib.Request;\nexports.Response = httpLib.Response;\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/http/index.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/http/util.js":
/*!*******************************************************!*\
  !*** ../node_modules/selenium-webdriver/http/util.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Various HTTP utilities.\n */\n\n\n\nconst Executor = __webpack_require__(/*! ./index */ \"../node_modules/selenium-webdriver/http/index.js\").Executor,\n    HttpClient = __webpack_require__(/*! ./index */ \"../node_modules/selenium-webdriver/http/index.js\").HttpClient,\n    HttpRequest = __webpack_require__(/*! ./index */ \"../node_modules/selenium-webdriver/http/index.js\").Request,\n    Command = __webpack_require__(/*! ../lib/command */ \"../node_modules/selenium-webdriver/lib/command.js\").Command,\n    CommandName = __webpack_require__(/*! ../lib/command */ \"../node_modules/selenium-webdriver/lib/command.js\").Name,\n    error = __webpack_require__(/*! ../lib/error */ \"../node_modules/selenium-webdriver/lib/error.js\");\n\n\n\n/**\n * Queries a WebDriver server for its current status.\n * @param {string} url Base URL of the server to query.\n * @return {!Promise<!Object>} A promise that resolves with\n *     a hash of the server status.\n */\nfunction getStatus(url) {\n  var client = new HttpClient(url);\n  var executor = new Executor(client);\n  var command = new Command(CommandName.GET_SERVER_STATUS);\n  return executor.execute(command);\n}\n\n\nclass CancellationError {}\n\n\n// PUBLIC API\n\n\n/**\n * Queries a WebDriver server for its current status.\n * @param {string} url Base URL of the server to query.\n * @return {!Promise<!Object>} A promise that resolves with\n *     a hash of the server status.\n */\nexports.getStatus = getStatus;\n\n\nexports.CancellationError = CancellationError;\n\n\n/**\n * Waits for a WebDriver server to be healthy and accepting requests.\n * @param {string} url Base URL of the server to query.\n * @param {number} timeout How long to wait for the server.\n * @param {Promise=} opt_cancelToken A promise used as a cancellation signal:\n *     if resolved before the server is ready, the wait will be terminated\n *     early with a {@link CancellationError}.\n * @return {!Promise} A promise that will resolve when the server is ready, or\n *     if the wait is cancelled.\n */\nexports.waitForServer = function(url, timeout, opt_cancelToken) {\n  return new Promise((onResolve, onReject) => {\n    let start = Date.now();\n\n    let done = false;\n    let resolve = (status) => {\n      done = true;\n      onResolve(status);\n    };\n    let reject = (err) => {\n      done = true;\n      onReject(err);\n    };\n\n    if (opt_cancelToken) {\n      opt_cancelToken.then(_ => reject(new CancellationError));\n    }\n\n    checkServerStatus();\n    function checkServerStatus() {\n      return getStatus(url).then(status => resolve(status), onError);\n    }\n\n    function onError(e) {\n      // Some servers don't support the status command. If they are able to\n      // response with an error, then can consider the server ready.\n      if (e instanceof error.UnsupportedOperationError) {\n        resolve({});\n        return;\n      }\n\n      if (Date.now() - start > timeout) {\n        reject(Error('Timed out waiting for the WebDriver server at ' + url));\n      } else {\n        setTimeout(function() {\n          if (!done) {\n            checkServerStatus();\n          }\n        }, 50);\n      }\n    }\n  });\n};\n\n\n/**\n * Polls a URL with GET requests until it returns a 2xx response or the\n * timeout expires.\n * @param {string} url The URL to poll.\n * @param {number} timeout How long to wait, in milliseconds.\n * @param {Promise=} opt_cancelToken A promise used as a cancellation signal:\n *     if resolved before the a 2xx response is received, the wait will be\n *     terminated early with a {@link CancellationError}.\n * @return {!Promise} A promise that will resolve when a 2xx is received from\n *     the given URL, or if the wait is cancelled.\n */\nexports.waitForUrl = function(url, timeout, opt_cancelToken) {\n  return new Promise((onResolve, onReject) => {\n    let client = new HttpClient(url);\n    let request = new HttpRequest('GET', '');\n    let start = Date.now();\n\n    let done = false;\n    let resolve = () => {\n      done = true;\n      onResolve();\n    };\n    let reject = (err) => {\n      done = true;\n      onReject(err);\n    };\n\n    if (opt_cancelToken) {\n      opt_cancelToken.then(_ => reject(new CancellationError));\n    }\n\n    testUrl();\n\n    function testUrl() {\n      client.send(request).then(onResponse, onError);\n    }\n\n    function onError() {\n      if (Date.now() - start > timeout) {\n        reject(Error('Timed out waiting for the URL to return 2xx: ' + url));\n      } else {\n        setTimeout(function() {\n          if (!done) {\n            testUrl();\n          }\n        }, 50);\n      }\n    }\n\n    function onResponse(response) {\n      if (done) {\n        return;\n      }\n      if (response.status > 199 && response.status < 300) {\n        resolve();\n        return;\n      }\n      onError();\n    }\n  });\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/http/util.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/ie.js":
/*!************************************************!*\
  !*** ../node_modules/selenium-webdriver/ie.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a {@linkplain Driver WebDriver} client for Microsoft's\n * Internet Explorer. Before using the IEDriver, you must download the latest\n * [IEDriverServer](http://selenium-release.storage.googleapis.com/index.html)\n * and place it on your\n * [PATH](http://en.wikipedia.org/wiki/PATH_%28variable%29). You must also apply\n * the system configuration outlined on the Selenium project\n * [wiki](https://github.com/SeleniumHQ/selenium/wiki/InternetExplorerDriver)\n */\n\n\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst http = __webpack_require__(/*! ./http */ \"../node_modules/selenium-webdriver/http/index.js\");\nconst io = __webpack_require__(/*! ./io */ \"../node_modules/selenium-webdriver/io/index.js\");\nconst portprober = __webpack_require__(/*! ./net/portprober */ \"../node_modules/selenium-webdriver/net/portprober.js\");\nconst promise = __webpack_require__(/*! ./lib/promise */ \"../node_modules/selenium-webdriver/lib/promise.js\");\nconst remote = __webpack_require__(/*! ./remote */ \"../node_modules/selenium-webdriver/remote/index.js\");\nconst webdriver = __webpack_require__(/*! ./lib/webdriver */ \"../node_modules/selenium-webdriver/lib/webdriver.js\");\nconst {Browser, Capabilities, Capability} = __webpack_require__(/*! ./lib/capabilities */ \"../node_modules/selenium-webdriver/lib/capabilities.js\");\n\n\nconst IEDRIVER_EXE = 'IEDriverServer.exe';\n\n\n\n/**\n * IEDriverServer logging levels.\n * @enum {string}\n */\nconst Level = {\n  FATAL: 'FATAL',\n  ERROR: 'ERROR',\n  WARN: 'WARN',\n  INFO: 'INFO',\n  DEBUG: 'DEBUG',\n  TRACE: 'TRACE'\n};\n\n\n\n/**\n * Option keys:\n * https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities#ie-specific\n * @enum {string}\n */\nconst Key = {\n  IGNORE_PROTECTED_MODE_SETTINGS: 'ignoreProtectedModeSettings',\n  IGNORE_ZOOM_SETTING: 'ignoreZoomSetting',\n  INITIAL_BROWSER_URL: 'initialBrowserUrl',\n  ENABLE_PERSISTENT_HOVER: 'enablePersistentHover',\n  ENABLE_ELEMENT_CACHE_CLEANUP: 'enableElementCacheCleanup',\n  REQUIRE_WINDOW_FOCUS: 'requireWindowFocus',\n  BROWSER_ATTACH_TIMEOUT: 'browserAttachTimeout',\n  FORCE_CREATE_PROCESS: 'ie.forceCreateProcessApi',\n  BROWSER_COMMAND_LINE_SWITCHES: 'ie.browserCommandLineSwitches',\n  USE_PER_PROCESS_PROXY: 'ie.usePerProcessProxy',\n  ENSURE_CLEAN_SESSION: 'ie.ensureCleanSession',\n  LOG_FILE: 'logFile',\n  LOG_LEVEL: 'logLevel',\n  HOST: 'host',\n  EXTRACT_PATH: 'extractPath',\n  SILENT: 'silent'\n};\n\n\n/**\n * Class for managing IEDriver specific options.\n */\nclass Options extends Capabilities {\n  /**\n   * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of\n   *     capabilities to initialize this instance from.\n   */\n  constructor(other = undefined) {\n    super(other);\n    this.setBrowserName(Browser.IE);\n  }\n\n  /**\n   * Whether to disable the protected mode settings check when the session is\n   * created. Disbling this setting may lead to significant instability as the\n   * browser may become unresponsive/hang. Only \"best effort\" support is provided\n   * when using this capability.\n   *\n   * For more information, refer to the IEDriver's\n   * [required system configuration](http://goo.gl/eH0Yi3).\n   *\n   * @param {boolean} ignoreSettings Whether to ignore protected mode settings.\n   * @return {!Options} A self reference.\n   */\n  introduceFlakinessByIgnoringProtectedModeSettings(ignoreSettings) {\n    this.set(Key.IGNORE_PROTECTED_MODE_SETTINGS, !!ignoreSettings);\n    return this;\n  }\n\n  /**\n   * Indicates whether to skip the check that the browser's zoom level is set to\n   * 100%.\n   *\n   * @param {boolean} ignore Whether to ignore the browser's zoom level settings.\n   * @return {!Options} A self reference.\n   */\n  ignoreZoomSetting(ignore) {\n    this.set(Key.IGNORE_ZOOM_SETTING, !!ignore);\n    return this;\n  }\n\n  /**\n   * Sets the initial URL loaded when IE starts. This is intended to be used with\n   * {@link #ignoreProtectedModeSettings} to allow the user to initialize IE in\n   * the proper Protected Mode zone. Setting this option may cause browser\n   * instability or flaky and unresponsive code. Only \"best effort\" support is\n   * provided when using this option.\n   *\n   * @param {string} url The initial browser URL.\n   * @return {!Options} A self reference.\n   */\n  initialBrowserUrl(url) {\n    this.set(Key.INITIAL_BROWSER_URL, url);\n    return this;\n  }\n\n  /**\n   * Configures whether to enable persistent mouse hovering (true by default).\n   * Persistent hovering is achieved by continuously firing mouse over events at\n   * the last location the mouse cursor has been moved to.\n   *\n   * @param {boolean} enable Whether to enable persistent hovering.\n   * @return {!Options} A self reference.\n   */\n  enablePersistentHover(enable) {\n    this.set(Key.ENABLE_PERSISTENT_HOVER, !!enable);\n    return this;\n  }\n\n  /**\n   * Configures whether the driver should attempt to remove obsolete\n   * {@linkplain webdriver.WebElement WebElements} from its internal cache on\n   * page navigation (true by default). Disabling this option will cause the\n   * driver to run with a larger memory footprint.\n   *\n   * @param {boolean} enable Whether to enable element reference cleanup.\n   * @return {!Options} A self reference.\n   */\n  enableElementCacheCleanup(enable) {\n    this.set(Key.ENABLE_ELEMENT_CACHE_CLEANUP, !!enable);\n    return this;\n  }\n\n  /**\n   * Configures whether to require the IE window to have input focus before\n   * performing any user interactions (i.e. mouse or keyboard events). This\n   * option is disabled by default, but delivers much more accurate interaction\n   * events when enabled.\n   *\n   * @param {boolean} require Whether to require window focus.\n   * @return {!Options} A self reference.\n   */\n  requireWindowFocus(require) {\n    this.set(Key.REQUIRE_WINDOW_FOCUS, !!require);\n    return this;\n  }\n\n  /**\n   * Configures the timeout, in milliseconds, that the driver will attempt to\n   * located and attach to a newly opened instance of Internet Explorer. The\n   * default is zero, which indicates waiting indefinitely.\n   *\n   * @param {number} timeout How long to wait for IE.\n   * @return {!Options} A self reference.\n   */\n  browserAttachTimeout(timeout) {\n    this.set(Key.BROWSER_ATTACH_TIMEOUT, Math.max(timeout, 0));\n    return this;\n  }\n\n  /**\n   * Configures whether to launch Internet Explorer using the CreateProcess API.\n   * If this option is not specified, IE is launched using IELaunchURL, if\n   * available. For IE 8 and above, this option requires the TabProcGrowth\n   * registry value to be set to 0.\n   *\n   * @param {boolean} force Whether to use the CreateProcess API.\n   * @return {!Options} A self reference.\n   */\n  forceCreateProcessApi(force) {\n    this.set(Key.FORCE_CREATE_PROCESS, !!force);\n    return this;\n  }\n\n  /**\n   * Specifies command-line switches to use when launching Internet Explorer.\n   * This is only valid when used with {@link #forceCreateProcessApi}.\n   *\n   * @param {...(string|!Array.<string>)} args The arguments to add.\n   * @return {!Options} A self reference.\n   */\n  addArguments(...args) {\n    let current = this.get(Key.BROWSER_COMMAND_LINE_SWITCHES) || [];\n    this.set(\n        Key.BROWSER_COMMAND_LINE_SWITCHES,\n        current.concat.apply(current, args));\n    return this;\n  }\n\n  /**\n   * Configures whether proxies should be configured on a per-process basis. If\n   * not set, setting a {@linkplain #setProxy proxy} will configure the system\n   * proxy. The default behavior is to use the system proxy.\n   *\n   * @param {boolean} enable Whether to enable per-process proxy settings.\n   * @return {!Options} A self reference.\n   */\n  usePerProcessProxy(enable) {\n    this.set(Key.USE_PER_PROCESS_PROXY, !!enable);\n    return this;\n  }\n\n  /**\n   * Configures whether to clear the cache, cookies, history, and saved form data\n   * before starting the browser. _Using this capability will clear session data\n   * for all running instances of Internet Explorer, including those started\n   * manually._\n   *\n   * @param {boolean} cleanSession Whether to clear all session data on startup.\n   * @return {!Options} A self reference.\n   */\n  ensureCleanSession(cleanSession) {\n    this.set(Key.ENSURE_CLEAN_SESSION, !!cleanSession);\n    return this;\n  }\n\n  /**\n   * Sets the path to the log file the driver should log to.\n   * @param {string} file The log file path.\n   * @return {!Options} A self reference.\n   */\n  setLogFile(file) {\n    this.set(Key.LOG_FILE, file);\n    return this;\n  }\n\n  /**\n   * Sets the IEDriverServer's logging {@linkplain Level level}.\n   * @param {Level} level The logging level.\n   * @return {!Options} A self reference.\n   */\n  setLogLevel(level) {\n    this.set(Key.LOG_LEVEL, level);\n    return this;\n  }\n\n  /**\n   * Sets the IP address of the driver's host adapter.\n   * @param {string} host The IP address to use.\n   * @return {!Options} A self reference.\n   */\n  setHost(host) {\n    this.set(Key.HOST, host);\n    return this;\n  }\n\n  /**\n   * Sets the path of the temporary data directory to use.\n   * @param {string} path The log file path.\n   * @return {!Options} A self reference.\n   */\n  setExtractPath(path) {\n    this.set(Key.EXTRACT_PATH, path);\n    return this;\n  }\n\n  /**\n   * Sets whether the driver should start in silent mode.\n   * @param {boolean} silent Whether to run in silent mode.\n   * @return {!Options} A self reference.\n   */\n  silent(silent) {\n    this.set(Key.SILENT, silent);\n    return this;\n  }\n}\n\n\n/**\n * _Synchronously_ attempts to locate the IE driver executable on the current\n * system.\n *\n * @return {?string} the located executable, or `null`.\n */\nfunction locateSynchronously() {\n  return process.platform === 'win32'\n      ? io.findInPath(IEDRIVER_EXE, true) : null;\n}\n\n\nfunction createServiceFromCapabilities(capabilities) {\n  if (process.platform !== 'win32') {\n    throw Error(\n        'The IEDriver may only be used on Windows, but you appear to be on ' +\n        process.platform + '. Did you mean to run against a remote ' +\n        'WebDriver server?');\n  }\n\n  let exe = locateSynchronously();\n  if (!exe || !fs.existsSync(exe)) {\n    throw Error(\n        `${IEDRIVER_EXE} could not be found on the current PATH. Please ` +\n        `download the latest version of ${IEDRIVER_EXE} from ` +\n        'http://selenium-release.storage.googleapis.com/index.html and ' +\n        'ensure it can be found on your system PATH.');\n  }\n\n  var args = [];\n  if (capabilities.has(Key.HOST)) {\n    args.push('--host=' + capabilities.get(Key.HOST));\n  }\n  if (capabilities.has(Key.LOG_FILE)) {\n    args.push('--log-file=' + capabilities.get(Key.LOG_FILE));\n  }\n  if (capabilities.has(Key.LOG_LEVEL)) {\n    args.push('--log-level=' + capabilities.get(Key.LOG_LEVEL));\n  }\n  if (capabilities.has(Key.EXTRACT_PATH)) {\n    args.push('--extract-path=' + capabilities.get(Key.EXTRACT_PATH));\n  }\n  if (capabilities.get(Key.SILENT)) {\n    args.push('--silent');\n  }\n\n  var port = portprober.findFreePort();\n  return new remote.DriverService(exe, {\n    loopback: true,\n    port: port,\n    args: port.then(function(port) {\n      return args.concat('--port=' + port);\n    }),\n    stdio: 'ignore'\n  });\n}\n\n\n/**\n * A WebDriver client for Microsoft's Internet Explorer.\n */\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new session for Microsoft's Internet Explorer.\n   *\n   * @param {(Capabilities|Options)=} options The configuration options.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(options) {\n    options = options || new Options();\n\n    let service = createServiceFromCapabilities(options);\n    let client = service.start().then(url => new http.HttpClient(url));\n    let executor = new http.Executor(client);\n\n    return /** @type {!Driver} */(super.createSession(\n        executor, options, () => service.kill()));\n  }\n\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n  setFileDetector() {}\n}\n\n\n// PUBLIC API\n\n\nexports.Driver = Driver;\nexports.Options = Options;\nexports.Level = Level;\nexports.locateSynchronously = locateSynchronously;\n\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/ie.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/index.js":
/*!***************************************************!*\
  !*** ../node_modules/selenium-webdriver/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview The main user facing module. Exports WebDriver's primary\n * public API and provides convenience assessors to certain sub-modules.\n */\n\n\n\nconst _http = __webpack_require__(/*! ./http */ \"../node_modules/selenium-webdriver/http/index.js\");\nconst by = __webpack_require__(/*! ./lib/by */ \"../node_modules/selenium-webdriver/lib/by.js\");\nconst capabilities = __webpack_require__(/*! ./lib/capabilities */ \"../node_modules/selenium-webdriver/lib/capabilities.js\");\nconst chrome = __webpack_require__(/*! ./chrome */ \"../node_modules/selenium-webdriver/chrome.js\");\nconst command = __webpack_require__(/*! ./lib/command */ \"../node_modules/selenium-webdriver/lib/command.js\");\nconst edge = __webpack_require__(/*! ./edge */ \"../node_modules/selenium-webdriver/edge.js\");\nconst error = __webpack_require__(/*! ./lib/error */ \"../node_modules/selenium-webdriver/lib/error.js\");\nconst firefox = __webpack_require__(/*! ./firefox */ \"../node_modules/selenium-webdriver/firefox.js\");\nconst ie = __webpack_require__(/*! ./ie */ \"../node_modules/selenium-webdriver/ie.js\");\nconst input = __webpack_require__(/*! ./lib/input */ \"../node_modules/selenium-webdriver/lib/input.js\");\nconst logging = __webpack_require__(/*! ./lib/logging */ \"../node_modules/selenium-webdriver/lib/logging.js\");\nconst promise = __webpack_require__(/*! ./lib/promise */ \"../node_modules/selenium-webdriver/lib/promise.js\");\nconst remote = __webpack_require__(/*! ./remote */ \"../node_modules/selenium-webdriver/remote/index.js\");\nconst safari = __webpack_require__(/*! ./safari */ \"../node_modules/selenium-webdriver/safari.js\");\nconst session = __webpack_require__(/*! ./lib/session */ \"../node_modules/selenium-webdriver/lib/session.js\");\nconst until = __webpack_require__(/*! ./lib/until */ \"../node_modules/selenium-webdriver/lib/until.js\");\nconst webdriver = __webpack_require__(/*! ./lib/webdriver */ \"../node_modules/selenium-webdriver/lib/webdriver.js\");\n\nconst Browser = capabilities.Browser;\nconst Capabilities = capabilities.Capabilities;\nconst Capability = capabilities.Capability;\nconst Session = session.Session;\nconst WebDriver = webdriver.WebDriver;\n\n\n\nvar seleniumServer;\n\n/**\n * Starts an instance of the Selenium server if not yet running.\n * @param {string} jar Path to the server jar to use.\n * @return {!Promise<string>} A promise for the server's\n *     address once started.\n */\nfunction startSeleniumServer(jar) {\n  if (!seleniumServer) {\n    seleniumServer = new remote.SeleniumServer(jar);\n  }\n  return seleniumServer.start();\n}\n\n\n/**\n * {@linkplain webdriver.WebDriver#setFileDetector WebDriver's setFileDetector}\n * method uses a non-standard command to transfer files from the local client\n * to the remote end hosting the browser. Many of the WebDriver sub-types, like\n * the {@link chrome.Driver} and {@link firefox.Driver}, do not support this\n * command. Thus, these classes override the `setFileDetector` to no-op.\n *\n * This function uses a mixin to re-enable `setFileDetector` by calling the\n * original method on the WebDriver prototype directly. This is used only when\n * the builder creates a Chrome or Firefox instance that communicates with a\n * remote end (and thus, support for remote file detectors is unknown).\n *\n * @param {function(new: webdriver.WebDriver, ...?)} ctor\n * @return {function(new: webdriver.WebDriver, ...?)}\n */\nfunction ensureFileDetectorsAreEnabled(ctor) {\n  const mixin = class extends ctor {\n    /** @param {input.FileDetector} detector */\n    setFileDetector(detector) {\n      webdriver.WebDriver.prototype.setFileDetector.call(this, detector);\n    }\n  };\n  return mixin;\n}\n\n\n/**\n * A thenable wrapper around a {@linkplain webdriver.IWebDriver IWebDriver}\n * instance that allows commands to be issued directly instead of having to\n * repeatedly call `then`:\n *\n *     let driver = new Builder().build();\n *     driver.then(d => d.get(url));  // You can do this...\n *     driver.get(url);               // ...or this\n *\n * If the driver instance fails to resolve (e.g. the session cannot be created),\n * every issued command will fail.\n *\n * @extends {webdriver.IWebDriver}\n * @extends {IThenable<!webdriver.IWebDriver>}\n * @interface\n */\nclass ThenableWebDriver {\n  /** @param {...?} args */\n  static createSession(...args) {}\n}\n\n\n/**\n * @const {!Map<function(new: WebDriver, !IThenable<!Session>, ...?),\n *              function(new: ThenableWebDriver, !IThenable<!Session>, ...?)>}\n */\nconst THENABLE_DRIVERS = new Map;\n\n\n/**\n * @param {function(new: WebDriver, !IThenable<!Session>, ...?)} ctor\n * @param {...?} args\n * @return {!ThenableWebDriver}\n */\nfunction createDriver(ctor, ...args) {\n  let thenableWebDriverProxy = THENABLE_DRIVERS.get(ctor);\n  if (!thenableWebDriverProxy) {\n    /**\n     * @extends {WebDriver}  // Needed since `ctor` is dynamically typed.\n     * @implements {ThenableWebDriver}\n     */\n    thenableWebDriverProxy = class extends ctor {\n      /**\n       * @param {!IThenable<!Session>} session\n       * @param {...?} rest\n       */\n      constructor(session, ...rest) {\n        super(session, ...rest);\n\n        const pd = this.getSession().then(session => {\n          return new ctor(session, ...rest);\n        });\n\n        /** @override */\n        this.then = pd.then.bind(pd);\n\n        /** @override */\n        this.catch = pd.catch.bind(pd);\n      }\n    };\n    THENABLE_DRIVERS.set(ctor, thenableWebDriverProxy);\n  }\n  return thenableWebDriverProxy.createSession(...args);\n}\n\n\n/**\n * Creates new {@link webdriver.WebDriver WebDriver} instances. The environment\n * variables listed below may be used to override a builder's configuration,\n * allowing quick runtime changes.\n *\n * - {@code SELENIUM_BROWSER}: defines the target browser in the form\n *   {@code browser[:version][:platform]}.\n *\n * - {@code SELENIUM_REMOTE_URL}: defines the remote URL for all builder\n *   instances. This environment variable should be set to a fully qualified\n *   URL for a WebDriver server (e.g. http://localhost:4444/wd/hub). This\n *   option always takes precedence over {@code SELENIUM_SERVER_JAR}.\n *\n * - {@code SELENIUM_SERVER_JAR}: defines the path to the\n *   <a href=\"http://selenium-release.storage.googleapis.com/index.html\">\n *   standalone Selenium server</a> jar to use. The server will be started the\n *   first time a WebDriver instance and be killed when the process exits.\n *\n * Suppose you had mytest.js that created WebDriver with\n *\n *     var driver = new webdriver.Builder()\n *         .forBrowser('chrome')\n *         .build();\n *\n * This test could be made to use Firefox on the local machine by running with\n * `SELENIUM_BROWSER=firefox node mytest.js`. Rather than change the code to\n * target Google Chrome on a remote machine, you can simply set the\n * `SELENIUM_BROWSER` and `SELENIUM_REMOTE_URL` environment variables:\n *\n *     SELENIUM_BROWSER=chrome:36:LINUX \\\n *     SELENIUM_REMOTE_URL=http://www.example.com:4444/wd/hub \\\n *     node mytest.js\n *\n * You could also use a local copy of the standalone Selenium server:\n *\n *     SELENIUM_BROWSER=chrome:36:LINUX \\\n *     SELENIUM_SERVER_JAR=/path/to/selenium-server-standalone.jar \\\n *     node mytest.js\n */\nclass Builder {\n  constructor() {\n    /** @private @const */\n    this.log_ = logging.getLogger('webdriver.Builder');\n\n    /** @private {string} */\n    this.url_ = '';\n\n    /** @private {?string} */\n    this.proxy_ = null;\n\n    /** @private {!Capabilities} */\n    this.capabilities_ = new Capabilities();\n\n    /** @private {chrome.Options} */\n    this.chromeOptions_ = null;\n\n    /** @private {chrome.ServiceBuilder} */\n    this.chromeService_ = null;\n\n    /** @private {firefox.Options} */\n    this.firefoxOptions_ = null;\n\n    /** @private {firefox.ServiceBuilder} */\n    this.firefoxService_ = null;\n\n    /** @private {ie.Options} */\n    this.ieOptions_ = null;\n\n    /** @private {safari.Options} */\n    this.safariOptions_ = null;\n\n    /** @private {edge.Options} */\n    this.edgeOptions_ = null;\n\n    /** @private {remote.DriverService.Builder} */\n    this.edgeService_ = null;\n\n    /** @private {boolean} */\n    this.ignoreEnv_ = false;\n\n    /** @private {http.Agent} */\n    this.agent_ = null;\n  }\n\n  /**\n   * Configures this builder to ignore any environment variable overrides and to\n   * only use the configuration specified through this instance's API.\n   *\n   * @return {!Builder} A self reference.\n   */\n  disableEnvironmentOverrides() {\n    this.ignoreEnv_ = true;\n    return this;\n  }\n\n  /**\n   * Sets the URL of a remote WebDriver server to use. Once a remote URL has\n   * been specified, the builder direct all new clients to that server. If this\n   * method is never called, the Builder will attempt to create all clients\n   * locally.\n   *\n   * As an alternative to this method, you may also set the\n   * `SELENIUM_REMOTE_URL` environment variable.\n   *\n   * @param {string} url The URL of a remote server to use.\n   * @return {!Builder} A self reference.\n   */\n  usingServer(url) {\n    this.url_ = url;\n    return this;\n  }\n\n  /**\n   * @return {string} The URL of the WebDriver server this instance is\n   *     configured to use.\n   */\n  getServerUrl() {\n    return this.url_;\n  }\n\n  /**\n   * Sets the URL of the proxy to use for the WebDriver's HTTP connections.\n   * If this method is never called, the Builder will create a connection\n   * without a proxy.\n   *\n   * @param {string} proxy The URL of a proxy to use.\n   * @return {!Builder} A self reference.\n   */\n  usingWebDriverProxy(proxy) {\n    this.proxy_ = proxy;\n    return this;\n  }\n\n  /**\n   * @return {?string} The URL of the proxy server to use for the WebDriver's\n   *    HTTP connections, or `null` if not set.\n   */\n  getWebDriverProxy() {\n    return this.proxy_;\n  }\n\n  /**\n   * Sets the http agent to use for each request.\n   * If this method is not called, the Builder will use http.globalAgent by default.\n   *\n   * @param {http.Agent} agent The agent to use for each request.\n   * @return {!Builder} A self reference.\n   */\n  usingHttpAgent(agent) {\n    this.agent_ = agent;\n    return this;\n  }\n\n  /**\n   * @return {http.Agent} The http agent used for each request\n   */\n  getHttpAgent() {\n    return this.agent_;\n  }\n\n  /**\n   * Sets the desired capabilities when requesting a new session. This will\n   * overwrite any previously set capabilities.\n   * @param {!(Object|Capabilities)} capabilities The desired capabilities for\n   *     a new session.\n   * @return {!Builder} A self reference.\n   */\n  withCapabilities(capabilities) {\n    this.capabilities_ = new Capabilities(capabilities);\n    return this;\n  }\n\n  /**\n   * Returns the base set of capabilities this instance is currently configured\n   * to use.\n   * @return {!Capabilities} The current capabilities for this builder.\n   */\n  getCapabilities() {\n    return this.capabilities_;\n  }\n\n  /**\n   * Configures the target browser for clients created by this instance.\n   * Any calls to {@link #withCapabilities} after this function will\n   * overwrite these settings.\n   *\n   * You may also define the target browser using the {@code SELENIUM_BROWSER}\n   * environment variable. If set, this environment variable should be of the\n   * form `browser[:[version][:platform]]`.\n   *\n   * @param {(string|!Browser)} name The name of the target browser;\n   *     common defaults are available on the {@link webdriver.Browser} enum.\n   * @param {string=} opt_version A desired version; may be omitted if any\n   *     version should be used.\n   * @param {(string|!capabilities.Platform)=} opt_platform\n   *     The desired platform; may be omitted if any platform may be used.\n   * @return {!Builder} A self reference.\n   */\n  forBrowser(name, opt_version, opt_platform) {\n    this.capabilities_.setBrowserName(name);\n    if (opt_version) {\n      this.capabilities_.setBrowserVersion(opt_version);\n    }\n    if (opt_platform) {\n      this.capabilities_.setPlatform(opt_platform);\n    }\n    return this;\n  }\n\n  /**\n   * Sets the proxy configuration for the target browser.\n   * Any calls to {@link #withCapabilities} after this function will\n   * overwrite these settings.\n   *\n   * @param {!./lib/proxy.Config} config The configuration to use.\n   * @return {!Builder} A self reference.\n   */\n  setProxy(config) {\n    this.capabilities_.setProxy(config);\n    return this;\n  }\n\n  /**\n   * Sets the logging preferences for the created session. Preferences may be\n   * changed by repeated calls, or by calling {@link #withCapabilities}.\n   * @param {!(./lib/logging.Preferences|Object<string, string>)} prefs The\n   *     desired logging preferences.\n   * @return {!Builder} A self reference.\n   */\n  setLoggingPrefs(prefs) {\n    this.capabilities_.setLoggingPrefs(prefs);\n    return this;\n  }\n\n  /**\n   * Sets the default action to take with an unexpected alert before returning\n   * an error.\n   *\n   * @param {?capabilities.UserPromptHandler} behavior The desired behavior.\n   * @return {!Builder} A self reference.\n   * @see capabilities.Capabilities#setAlertBehavior\n   */\n  setAlertBehavior(behavior) {\n    this.capabilities_.setAlertBehavior(behavior);\n    return this;\n  }\n\n  /**\n   * Sets Chrome specific {@linkplain chrome.Options options} for drivers\n   * created by this builder. Any logging or proxy settings defined on the given\n   * options will take precedence over those set through\n   * {@link #setLoggingPrefs} and {@link #setProxy}, respectively.\n   *\n   * @param {!chrome.Options} options The ChromeDriver options to use.\n   * @return {!Builder} A self reference.\n   */\n  setChromeOptions(options) {\n    this.chromeOptions_ = options;\n    return this;\n  }\n\n  /**\n   * @return {chrome.Options} the Chrome specific options currently configured\n   *     for this builder.\n   */\n  getChromeOptions() {\n    return this.chromeOptions_;\n  }\n\n  /**\n   * Sets the service builder to use for managing the chromedriver child process\n   * when creating new Chrome sessions.\n   *\n   * @param {chrome.ServiceBuilder} service the service to use.\n   * @return {!Builder} A self reference.\n   */\n  setChromeService(service) {\n    if (service && !(service instanceof chrome.ServiceBuilder)) {\n      throw TypeError('not a chrome.ServiceBuilder object');\n    }\n    this.chromeService_ = service;\n    return this;\n  }\n\n  /**\n   * Sets Firefox specific {@linkplain firefox.Options options} for drivers\n   * created by this builder. Any logging or proxy settings defined on the given\n   * options will take precedence over those set through\n   * {@link #setLoggingPrefs} and {@link #setProxy}, respectively.\n   *\n   * @param {!firefox.Options} options The FirefoxDriver options to use.\n   * @return {!Builder} A self reference.\n   */\n  setFirefoxOptions(options) {\n    this.firefoxOptions_ = options;\n    return this;\n  }\n\n  /**\n   * @return {firefox.Options} the Firefox specific options currently configured\n   *     for this instance.\n   */\n  getFirefoxOptions() {\n    return this.firefoxOptions_;\n  }\n\n  /**\n   * Sets the {@link firefox.ServiceBuilder} to use to manage the geckodriver\n   * child process when creating Firefox sessions locally.\n   *\n   * @param {firefox.ServiceBuilder} service the service to use.\n   * @return {!Builder} a self reference.\n   */\n  setFirefoxService(service) {\n    if (service && !(service instanceof firefox.ServiceBuilder)) {\n      throw TypeError('not a firefox.ServiceBuilder object');\n    }\n    this.firefoxService_ = service;\n    return this;\n  }\n\n  /**\n   * Set Internet Explorer specific {@linkplain ie.Options options} for drivers\n   * created by this builder. Any proxy settings defined on the given options\n   * will take precedence over those set through {@link #setProxy}.\n   *\n   * @param {!ie.Options} options The IEDriver options to use.\n   * @return {!Builder} A self reference.\n   */\n  setIeOptions(options) {\n    this.ieOptions_ = options;\n    return this;\n  }\n\n  /**\n   * Set {@linkplain edge.Options options} specific to Microsoft's Edge browser\n   * for drivers created by this builder. Any proxy settings defined on the\n   * given options will take precedence over those set through\n   * {@link #setProxy}.\n   *\n   * @param {!edge.Options} options The MicrosoftEdgeDriver options to use.\n   * @return {!Builder} A self reference.\n   */\n  setEdgeOptions(options) {\n    this.edgeOptions_ = options;\n    return this;\n  }\n\n  /**\n   * Sets the {@link edge.ServiceBuilder} to use to manage the\n   * MicrosoftEdgeDriver child process when creating sessions locally.\n   *\n   * @param {edge.ServiceBuilder} service the service to use.\n   * @return {!Builder} a self reference.\n   */\n  setEdgeService(service) {\n    if (service && !(service instanceof edge.ServiceBuilder)) {\n      throw TypeError('not a edge.ServiceBuilder object');\n    }\n    this.edgeService_ = service;\n    return this;\n  }\n\n  /**\n   * Sets Safari specific {@linkplain safari.Options options} for drivers\n   * created by this builder. Any logging settings defined on the given options\n   * will take precedence over those set through {@link #setLoggingPrefs}.\n   *\n   * @param {!safari.Options} options The Safari options to use.\n   * @return {!Builder} A self reference.\n   */\n  setSafariOptions(options) {\n    this.safariOptions_ = options;\n    return this;\n  }\n\n  /**\n   * @return {safari.Options} the Safari specific options currently configured\n   *     for this instance.\n   */\n  getSafariOptions() {\n    return this.safariOptions_;\n  }\n\n  /**\n   * Creates a new WebDriver client based on this builder's current\n   * configuration.\n   *\n   * This method will return a {@linkplain ThenableWebDriver} instance, allowing\n   * users to issue commands directly without calling `then()`. The returned\n   * thenable wraps a promise that will resolve to a concrete\n   * {@linkplain webdriver.WebDriver WebDriver} instance. The promise will be\n   * rejected if the remote end fails to create a new session.\n   *\n   * @return {!ThenableWebDriver} A new WebDriver instance.\n   * @throws {Error} If the current configuration is invalid.\n   */\n  build() {\n    // Create a copy for any changes we may need to make based on the current\n    // environment.\n    var capabilities = new Capabilities(this.capabilities_);\n\n    var browser;\n    if (!this.ignoreEnv_ && process.env.SELENIUM_BROWSER) {\n      this.log_.fine(`SELENIUM_BROWSER=${process.env.SELENIUM_BROWSER}`);\n      browser = process.env.SELENIUM_BROWSER.split(/:/, 3);\n      capabilities.setBrowserName(browser[0]);\n\n      browser[1] && capabilities.setBrowserVersion(browser[1]);\n      browser[2] && capabilities.setPlatform(browser[2]);\n    }\n\n    browser = capabilities.get(Capability.BROWSER_NAME);\n\n    if (typeof browser !== 'string') {\n      throw TypeError(\n          `Target browser must be a string, but is <${typeof browser}>;` +\n          ' did you forget to call forBrowser()?');\n    }\n\n    if (browser === 'ie') {\n      browser = Browser.INTERNET_EXPLORER;\n    }\n\n    // Apply browser specific overrides.\n    if (browser === Browser.CHROME && this.chromeOptions_) {\n      capabilities.merge(this.chromeOptions_);\n\n    } else if (browser === Browser.FIREFOX && this.firefoxOptions_) {\n      capabilities.merge(this.firefoxOptions_);\n\n    } else if (browser === Browser.INTERNET_EXPLORER && this.ieOptions_) {\n      capabilities.merge(this.ieOptions_);\n\n    } else if (browser === Browser.SAFARI && this.safariOptions_) {\n      capabilities.merge(this.safariOptions_);\n\n    } else if (browser === Browser.EDGE && this.edgeOptions_) {\n      capabilities.merge(this.edgeOptions_);\n    }\n\n    checkOptions(\n        capabilities, 'chromeOptions', chrome.Options, 'setChromeOptions');\n    checkOptions(\n        capabilities, 'moz:firefoxOptions', firefox.Options,\n        'setFirefoxOptions');\n    checkOptions(\n        capabilities, 'safari.options', safari.Options, 'setSafariOptions');\n\n    // Check for a remote browser.\n    let url = this.url_;\n    if (!this.ignoreEnv_) {\n      if (process.env.SELENIUM_REMOTE_URL) {\n        this.log_.fine(\n            `SELENIUM_REMOTE_URL=${process.env.SELENIUM_REMOTE_URL}`);\n        url = process.env.SELENIUM_REMOTE_URL;\n      } else if (process.env.SELENIUM_SERVER_JAR) {\n        this.log_.fine(\n            `SELENIUM_SERVER_JAR=${process.env.SELENIUM_SERVER_JAR}`);\n        url = startSeleniumServer(process.env.SELENIUM_SERVER_JAR);\n      }\n    }\n\n    if (url) {\n      this.log_.fine('Creating session on remote server');\n      let client = Promise.resolve(url)\n          .then(url => new _http.HttpClient(url, this.agent_, this.proxy_));\n      let executor = new _http.Executor(client);\n\n      if (browser === Browser.CHROME) {\n        const driver = ensureFileDetectorsAreEnabled(chrome.Driver);\n        return createDriver(driver, capabilities, executor);\n      }\n\n      if (browser === Browser.FIREFOX) {\n        const driver = ensureFileDetectorsAreEnabled(firefox.Driver);\n        return createDriver(driver, capabilities, executor);\n      }\n      return createDriver(WebDriver, executor, capabilities);\n    }\n\n    // Check for a native browser.\n    switch (browser) {\n      case Browser.CHROME: {\n        let service = null;\n        if (this.chromeService_) {\n          service = this.chromeService_.build();\n        }\n        return createDriver(chrome.Driver, capabilities, service);\n      }\n\n      case Browser.FIREFOX: {\n        let service = null;\n        if (this.firefoxService_) {\n          service = this.firefoxService_.build();\n        }\n        return createDriver(firefox.Driver, capabilities, service);\n      }\n\n      case Browser.INTERNET_EXPLORER:\n        return createDriver(ie.Driver, capabilities);\n\n      case Browser.EDGE: {\n        let service = null;\n        if (this.edgeService_) {\n          service = this.edgeService_.build();\n        }\n        return createDriver(edge.Driver, capabilities, service);\n      }\n\n      case Browser.SAFARI:\n        return createDriver(safari.Driver, capabilities);\n\n      default:\n        throw new Error('Do not know how to build driver: ' + browser\n            + '; did you forget to call usingServer(url)?');\n    }\n  }\n}\n\n\n/**\n * In the 3.x releases, the various browser option classes\n * (e.g. firefox.Options) had to be manually set as an option using the\n * Capabilties class:\n *\n *     let ffo = new firefox.Options();\n *     // Configure firefox options...\n *\n *     let caps = new Capabilities();\n *     caps.set('moz:firefoxOptions', ffo);\n *\n *     let driver = new Builder()\n *         .withCapabilities(caps)\n *         .build();\n *\n * The options are now subclasses of Capabilities and can be used directly. A\n * direct translation of the above is:\n *\n *     let ffo = new firefox.Options();\n *     // Configure firefox options...\n *\n *     let driver = new Builder()\n *         .withCapabilities(ffo)\n *         .build();\n *\n * You can also set the options for various browsers at once and let the builder\n * choose the correct set at runtime (see Builder docs above):\n *\n *     let ffo = new firefox.Options();\n *     // Configure ...\n *\n *     let co = new chrome.Options();\n *     // Configure ...\n *\n *     let driver = new Builder()\n *         .setChromeOptions(co)\n *         .setFirefoxOptions(ffo)\n *         .build();\n *\n * @param {!Capabilities} caps\n * @param {string} key\n * @param {function(new: Capabilities)} optionType\n * @param {string} setMethod\n * @throws {error.InvalidArgumentError}\n */\nfunction checkOptions(caps, key, optionType, setMethod) {\n  let val = caps.get(key);\n  if (val instanceof optionType) {\n    throw new error.InvalidArgumentError(\n        'Options class extends Capabilities and should not be set as key '\n            + `\"${key}\"; set browser-specific options with `\n            + `Builder.${setMethod}(). For more information, see the `\n            + 'documentation attached to the function that threw this error');\n  }\n}\n\n\n// PUBLIC API\n\n\nexports.Browser = capabilities.Browser;\nexports.Builder = Builder;\nexports.Button = input.Button;\nexports.By = by.By;\nexports.Capabilities = capabilities.Capabilities;\nexports.Capability = capabilities.Capability;\nexports.Condition = webdriver.Condition;\nexports.FileDetector = input.FileDetector;\nexports.Key = input.Key;\nexports.Session = session.Session;\nexports.ThenableWebDriver = ThenableWebDriver;\nexports.WebDriver = webdriver.WebDriver;\nexports.WebElement = webdriver.WebElement;\nexports.WebElementCondition = webdriver.WebElementCondition;\nexports.WebElementPromise = webdriver.WebElementPromise;\nexports.error = error;\nexports.logging = logging;\nexports.promise = promise;\nexports.until = until;\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/index.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/io/exec.js":
/*!*****************************************************!*\
  !*** ../node_modules/selenium-webdriver/io/exec.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\nconst childProcess = __webpack_require__(/*! child_process */ \"child_process\");\n\n\n/**\n * A hash with configuration options for an executed command.\n *\n * - `args` - Command line arguments.\n * - `env` - Command environment; will inherit from the current process if\n *     missing.\n * - `stdio` - IO configuration for the spawned server process. For more\n *     information, refer to the documentation of `child_process.spawn`.\n *\n * @typedef {{\n *   args: (!Array<string>|undefined),\n *   env: (!Object<string, string>|undefined),\n *   stdio: (string|!Array<string|number|!stream.Stream|null|undefined>|\n *           undefined)\n * }}\n */\nvar Options;\n\n\n/**\n * Describes a command's termination conditions.\n */\nclass Result {\n  /**\n   * @param {?number} code The exit code, or {@code null} if the command did not\n   *     exit normally.\n   * @param {?string} signal The signal used to kill the command, or\n   *     {@code null}.\n   */\n  constructor(code, signal) {\n    /** @type {?number} */\n    this.code = code;\n\n    /** @type {?string} */\n    this.signal = signal;\n  }\n\n  /** @override */\n  toString() {\n    return `Result(code=${this.code}, signal=${this.signal})`;\n  }\n}\n\n\nconst COMMAND_RESULT = /** !WeakMap<!Command, !Promise<!Result>> */new WeakMap;\nconst KILL_HOOK = /** !WeakMap<!Command, function(string)> */new WeakMap;\n\n/**\n * Represents a command running in a sub-process.\n */\nclass Command {\n  /**\n   * @param {!Promise<!Result>} result The command result.\n   * @param {function(string)} onKill The function to call when {@link #kill()}\n   *     is called.\n   */\n  constructor(result, onKill) {\n    COMMAND_RESULT.set(this, result);\n    KILL_HOOK.set(this, onKill);\n  }\n\n  /**\n   * @return {!Promise<!Result>} A promise for the result of this\n   *     command.\n   */\n  result() {\n    return /** @type {!Promise<!Result>} */(COMMAND_RESULT.get(this));\n  }\n\n  /**\n   * Sends a signal to the underlying process.\n   * @param {string=} opt_signal The signal to send; defaults to `SIGTERM`.\n   */\n  kill(opt_signal) {\n    KILL_HOOK.get(this)(opt_signal || 'SIGTERM');\n  }\n}\n\n\n// PUBLIC API\n\n\n/**\n * Spawns a child process. The returned {@link Command} may be used to wait\n * for the process result or to send signals to the process.\n *\n * @param {string} command The executable to spawn.\n * @param {Options=} opt_options The command options.\n * @return {!Command} The launched command.\n */\nmodule.exports = function exec(command, opt_options) {\n  var options = opt_options || {};\n\n  var proc = childProcess.spawn(command, options.args || [], {\n    env: options.env || process.env,\n    stdio: options.stdio || 'ignore'\n  });\n\n  // This process should not wait on the spawned child, however, we do\n  // want to ensure the child is killed when this process exits.\n  proc.unref();\n  process.once('exit', onProcessExit);\n\n  let result = new Promise(resolve => {\n    proc.once('exit', (code, signal) => {\n      proc = null;\n      process.removeListener('exit', onProcessExit);\n      resolve(new Result(code, signal));\n    });\n  });\n  return new Command(result, killCommand);\n\n  function onProcessExit() {\n    killCommand('SIGTERM');\n  }\n\n  function killCommand(signal) {\n    process.removeListener('exit', onProcessExit);\n    if (proc) {\n      proc.kill(signal);\n      proc = null;\n    }\n  }\n};\n\n// Exported to improve generated API documentation.\n\nmodule.exports.Command = Command;\n/** @typedef {!Options} */\nmodule.exports.Options = Options;\nmodule.exports.Result = Result;\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/io/exec.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/io/index.js":
/*!******************************************************!*\
  !*** ../node_modules/selenium-webdriver/io/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\nvar fs = __webpack_require__(/*! fs */ \"fs\"),\n    path = __webpack_require__(/*! path */ \"path\"),\n    rimraf = __webpack_require__(/*! rimraf */ \"../node_modules/rimraf/rimraf.js\"),\n    tmp = __webpack_require__(/*! tmp */ \"../node_modules/tmp/lib/tmp.js\");\n\n\n/**\n * @param {!Function} fn .\n * @return {!Promise<T>} .\n * @template T\n */\nfunction checkedCall(fn) {\n  return new Promise((resolve, reject) => {\n    try {\n      fn((err, value) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n\n\n// PUBLIC API\n\n\n\n/**\n * Recursively removes a directory and all of its contents. This is equivalent\n * to {@code rm -rf} on a POSIX system.\n * @param {string} dirPath Path to the directory to remove.\n * @return {!Promise} A promise to be resolved when the operation has\n *     completed.\n */\nexports.rmDir = function(dirPath) {\n  return new Promise(function(fulfill, reject) {\n    var numAttempts = 0;\n    attemptRm();\n    function attemptRm() {\n      numAttempts += 1;\n      rimraf(dirPath, function(err) {\n        if (err) {\n          if (err.code && err.code === 'ENOTEMPTY' && numAttempts < 2) {\n            attemptRm();\n            return;\n          }\n          reject(err);\n        } else {\n          fulfill();\n        }\n      });\n    }\n  });\n};\n\n\n/**\n * Copies one file to another.\n * @param {string} src The source file.\n * @param {string} dst The destination file.\n * @return {!Promise<string>} A promise for the copied file's path.\n */\nexports.copy = function(src, dst) {\n  return new Promise(function(fulfill, reject) {\n    var rs = fs.createReadStream(src);\n    rs.on('error', reject);\n    rs.on('end', () => fulfill(dst));\n\n    var ws = fs.createWriteStream(dst);\n    ws.on('error', reject);\n\n    rs.pipe(ws);\n  });\n};\n\n\n/**\n * Recursively copies the contents of one directory to another.\n * @param {string} src The source directory to copy.\n * @param {string} dst The directory to copy into.\n * @param {(RegExp|function(string): boolean)=} opt_exclude An exclusion filter\n *     as either a regex or predicate function. All files matching this filter\n *     will not be copied.\n * @return {!Promise<string>} A promise for the destination\n *     directory's path once all files have been copied.\n */\nexports.copyDir = function(src, dst, opt_exclude) {\n  var predicate = opt_exclude;\n  if (opt_exclude && typeof opt_exclude !== 'function') {\n    predicate = function(p) {\n      return !opt_exclude.test(p);\n    };\n  }\n\n  // TODO(jleyba): Make this function completely async.\n  if (!fs.existsSync(dst)) {\n    fs.mkdirSync(dst);\n  }\n\n  var files = fs.readdirSync(src);\n  files = files.map(function(file) {\n    return path.join(src, file);\n  });\n\n  if (predicate) {\n    files = files.filter(/** @type {function(string): boolean} */(predicate));\n  }\n\n  var results = [];\n  files.forEach(function(file) {\n    var stats = fs.statSync(file);\n    var target = path.join(dst, path.basename(file));\n\n    if (stats.isDirectory()) {\n      if (!fs.existsSync(target)) {\n        fs.mkdirSync(target, stats.mode);\n      }\n      results.push(exports.copyDir(file, target, predicate));\n    } else {\n      results.push(exports.copy(file, target));\n    }\n  });\n\n  return Promise.all(results).then(() => dst);\n};\n\n\n/**\n * Tests if a file path exists.\n * @param {string} aPath The path to test.\n * @return {!Promise<boolean>} A promise for whether the file exists.\n */\nexports.exists = function(aPath) {\n  return new Promise(function(fulfill, reject) {\n    let type = typeof aPath;\n    if (type !== 'string') {\n      reject(TypeError(`expected string path, but got ${type}`));\n    } else {\n      fs.exists(aPath, fulfill);\n    }\n  });\n};\n\n\n/**\n * Calls `stat(2)`.\n * @param {string} aPath The path to stat.\n * @return {!Promise<!fs.Stats>} A promise for the file stats.\n */\nexports.stat = function stat(aPath) {\n  return checkedCall(callback => fs.stat(aPath, callback));\n};\n\n\n/**\n * Deletes a name from the filesystem and possibly the file it refers to. Has\n * no effect if the file does not exist.\n * @param {string} aPath The path to remove.\n * @return {!Promise} A promise for when the file has been removed.\n */\nexports.unlink = function(aPath) {\n  return new Promise(function(fulfill, reject) {\n    fs.exists(aPath, function(exists) {\n      if (exists) {\n        fs.unlink(aPath, function(err) {\n          err && reject(err) || fulfill();\n        });\n      } else {\n        fulfill();\n      }\n    });\n  });\n};\n\n\n/**\n * @return {!Promise<string>} A promise for the path to a temporary directory.\n * @see https://www.npmjs.org/package/tmp\n */\nexports.tmpDir = function() {\n  return checkedCall(tmp.dir);\n};\n\n\n/**\n * @param {{postfix: string}=} opt_options Temporary file options.\n * @return {!Promise<string>} A promise for the path to a temporary file.\n * @see https://www.npmjs.org/package/tmp\n */\nexports.tmpFile = function(opt_options) {\n  return checkedCall(callback => {\n    // |tmp.file| checks arguments length to detect options rather than doing a\n    // truthy check, so we must only pass options if there are some to pass.\n    if (opt_options) {\n      tmp.file(opt_options, callback);\n    } else {\n      tmp.file(callback);\n    }\n  });\n};\n\n\n/**\n * Searches the {@code PATH} environment variable for the given file.\n * @param {string} file The file to locate on the PATH.\n * @param {boolean=} opt_checkCwd Whether to always start with the search with\n *     the current working directory, regardless of whether it is explicitly\n *     listed on the PATH.\n * @return {?string} Path to the located file, or {@code null} if it could\n *     not be found.\n */\nexports.findInPath = function(file, opt_checkCwd) {\n  let dirs = [];\n  if (opt_checkCwd) {\n    dirs.push(process.cwd());\n  }\n  dirs.push.apply(dirs, process.env['PATH'].split(path.delimiter));\n\n  let foundInDir = dirs.find(dir => {\n    let tmp = path.join(dir, file);\n    try {\n      let stats = fs.statSync(tmp);\n      return stats.isFile() && !stats.isDirectory();\n    } catch (ex) {\n      return false;\n    }\n  });\n\n  return foundInDir ? path.join(foundInDir, file) : null;\n};\n\n\n/**\n * Reads the contents of the given file.\n *\n * @param {string} aPath Path to the file to read.\n * @return {!Promise<!Buffer>} A promise that will resolve with a buffer of the\n *     file contents.\n */\nexports.read = function(aPath) {\n  return checkedCall(callback => fs.readFile(aPath, callback));\n};\n\n\n/**\n * Writes to a file.\n *\n * @param {string} aPath Path to the file to write to.\n * @param {(string|!Buffer)} data The data to write.\n * @return {!Promise} A promise that will resolve when the operation has\n *     completed.\n */\nexports.write = function(aPath, data) {\n  return checkedCall(callback => fs.writeFile(aPath, data, callback));\n};\n\n\n/**\n * Creates a directory.\n *\n * @param {string} aPath The directory path.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\nexports.mkdir = function(aPath) {\n  return checkedCall(callback => {\n    fs.mkdir(aPath, undefined, err => {\n      if (err && err.code !== 'EEXIST') {\n        callback(err);\n      } else {\n        callback(null, aPath);\n      }\n    });\n  });\n};\n\n\n/**\n * Recursively creates a directory and any ancestors that do not yet exist.\n *\n * @param {string} dir The directory path to create.\n * @return {!Promise<string>} A promise that will resolve with the path of the\n *     created directory.\n */\nexports.mkdirp = function mkdirp(dir) {\n  return checkedCall(callback => {\n    fs.mkdir(dir, undefined, err => {\n      if (!err) {\n        callback(null, dir);\n        return;\n      }\n\n      switch (err.code) {\n        case 'EEXIST':\n          callback(null, dir);\n          return;\n        case 'ENOENT':\n          return mkdirp(path.dirname(dir))\n              .then(() => mkdirp(dir))\n              .then(() => callback(null, dir), err => callback(err));\n        default:\n          callback(err);\n          return;\n      }\n    });\n  });\n};\n\n\n/**\n * Recursively walks a directory, returning a promise that will resolve with\n * a list of all files/directories seen.\n *\n * @param {string} rootPath the directory to walk.\n * @return {!Promise<!Array<{path: string, dir: boolean}>>} a promise that will\n *     resolve with a list of entries seen. For each entry, the recorded path\n *     will be relative to `rootPath`.\n */\nexports.walkDir = function(rootPath) {\n  let seen = [];\n  return (function walk(dir) {\n    return checkedCall(callback => fs.readdir(dir, callback))\n        .then(files => Promise.all(files.map(file => {\n          file = path.join(dir, file);\n          return checkedCall(cb => fs.stat(file, cb)).then(stats => {\n            seen.push({\n              path: path.relative(rootPath, file),\n              dir: stats.isDirectory()\n            });\n            return stats.isDirectory() && walk(file);\n          });\n        })));\n  })(rootPath).then(() => seen);\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/io/index.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/io/zip.js":
/*!****************************************************!*\
  !*** ../node_modules/selenium-webdriver/io/zip.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\nconst jszip = __webpack_require__(/*! jszip */ \"../node_modules/jszip/lib/index.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\n\nconst io = __webpack_require__(/*! ./index */ \"../node_modules/selenium-webdriver/io/index.js\");\nconst {InvalidArgumentError} = __webpack_require__(/*! ../lib/error */ \"../node_modules/selenium-webdriver/lib/error.js\");\n\n/**\n * Manages a zip archive.\n */\nclass Zip {\n  constructor() {\n    /** @private @const */\n    this.z_ = new jszip;\n\n    /** @private @const {!Set<!Promise<?>>} */\n    this.pendingAdds_ = new Set;\n  }\n\n  /**\n   * Adds a file to this zip.\n   *\n   * @param {string} filePath path to the file to add.\n   * @param {string=} zipPath path to the file in the zip archive, defaults\n   *     to the basename of `filePath`.\n   * @return {!Promise<?>} a promise that will resolve when added.\n   */\n  addFile(filePath, zipPath = path.basename(filePath)) {\n    let add = io.read(filePath)\n        .then(buffer => this.z_.file(/** @type {string} */(zipPath), buffer));\n    this.pendingAdds_.add(add);\n    return add.then(\n        () => this.pendingAdds_.delete(add),\n        (e) => {\n          this.pendingAdds_.delete(add);\n          throw e;\n        });\n  }\n\n  /**\n   * Recursively adds a directory and all of its contents to this archive.\n   *\n   * @param {string} dirPath path to the directory to add.\n   * @param {string=} zipPath path to the folder in the archive to add the\n   *     directory contents to. Defaults to the root folder.\n   * @return {!Promise<?>} returns a promise that will resolve when the\n   *     the operation is complete.\n   */\n  addDir(dirPath, zipPath = '') {\n    return io.walkDir(dirPath).then(entries => {\n      let archive = this.z_;\n      if (zipPath) {\n        archive = archive.folder(zipPath);\n      }\n\n      let files = [];\n      entries.forEach(spec => {\n        if (spec.dir) {\n          archive.folder(spec.path);\n        } else {\n          files.push(\n              this.addFile(\n                  path.join(dirPath, spec.path),\n                  path.join(zipPath, spec.path)));\n        }\n      });\n\n      return Promise.all(files);\n    });\n  }\n\n  /**\n   * @param {string} path File path to test for within the archive.\n   * @return {boolean} Whether this zip archive contains an entry with the given\n   *     path.\n   */\n  has(path) {\n    return this.z_.file(path) !== null;\n  }\n\n  /**\n   * Returns the contents of the file in this zip archive with the given `path`.\n   * The returned promise will be rejected with an {@link InvalidArgumentError}\n   * if either `path` does not exist within the archive, or if `path` refers\n   * to a directory.\n   *\n   * @param {string} path the path to the file whose contents to return.\n   * @return {!Promise<!Buffer>} a promise that will be resolved with the file's\n   *     contents as a buffer.\n   */\n  getFile(path) {\n    let file = this.z_.file(path);\n    if (!file) {\n      return Promise.reject(\n          new InvalidArgumentError(`No such file in zip archive: ${path}`));\n    }\n\n    if (file.dir) {\n      return Promise.reject(\n          new InvalidArgumentError(\n              `The requested file is a directory: ${path}`));\n    }\n\n    return Promise.resolve(file.async('nodebuffer'));\n  }\n\n  /**\n   * Returns the compressed data for this archive in a buffer. _This method will\n   * not wait for any outstanding {@link #addFile add}\n   * {@link #addDir operations} before encoding the archive._\n   *\n   * @param {string} compression The desired compression.\n   *     Must be `STORE` (the default) or `DEFLATE`.\n   * @return {!Promise<!Buffer>} a promise that will resolve with this archive\n   *     as a buffer.\n   */\n  toBuffer(compression = 'STORE') {\n    if (compression !== 'STORE' && compression !== 'DEFLATE') {\n      return Promise.reject(\n          new InvalidArgumentError(\n              `compression must be one of {STORE, DEFLATE}, got ${compression}`));\n    }\n    return Promise.resolve(\n        this.z_.generateAsync({compression, type: 'nodebuffer'}));\n  }\n}\n\n\n/**\n * Asynchronously opens a zip archive.\n *\n * @param {string} path to the zip archive to load.\n * @return {!Promise<!Zip>} a promise that will resolve with the opened\n *     archive.\n */\nfunction load(path) {\n  return io.read(path).then(data => {\n    let zip = new Zip;\n    return zip.z_.loadAsync(data).then(() => zip);\n  });\n}\n\n\n/**\n * Asynchronously unzips an archive file.\n *\n * @param {string} src path to the source file to unzip.\n * @param {string} dst path to the destination directory.\n * @return {!Promise<string>} a promise that will resolve with `dst` once the\n *     archive has been unzipped.\n */\nfunction unzip(src, dst) {\n  return load(src).then(zip => {\n    let promisedDirs = new Map;\n    let promises = [];\n\n    zip.z_.forEach((relPath, file) => {\n      let p;\n      if (file.dir) {\n        p = createDir(relPath);\n      } else {\n        let dirname = path.dirname(relPath);\n        if (dirname === '.') {\n          p = writeFile(relPath, file);\n        } else {\n          p = createDir(dirname).then(() => writeFile(relPath, file));\n        }\n      }\n      promises.push(p);\n    });\n\n    return Promise.all(promises).then(() => dst);\n\n    function createDir(dir) {\n      let p = promisedDirs.get(dir);\n      if (!p) {\n        p = io.mkdirp(path.join(dst, dir));\n        promisedDirs.set(dir, p);\n      }\n      return p;\n    }\n\n    function writeFile(relPath, file) {\n      return file.async('nodebuffer')\n          .then(buffer => io.write(path.join(dst, relPath), buffer));\n    }\n  });\n}\n\n\n// PUBLIC API\n\n\nexports.Zip = Zip;\nexports.load = load;\nexports.unzip = unzip;\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/io/zip.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/atoms/get-attribute.js":
/*!*********************************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/atoms/get-attribute.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// GENERATED CODE - DO NOT EDIT\nmodule.exports = function(){return function(){var d=this;function f(a){return\"string\"==typeof a};function h(a,b){this.code=a;this.a=l[a]||m;this.message=b||\"\";a=this.a.replace(/((?:^|\\s+)[a-z])/g,function(a){return a.toUpperCase().replace(/^[\\s\\xa0]+/g,\"\")});b=a.length-5;if(0>b||a.indexOf(\"Error\",b)!=b)a+=\"Error\";this.name=a;a=Error(this.message);a.name=this.name;this.stack=a.stack||\"\"}\n(function(){var a=Error;function b(){}b.prototype=a.prototype;h.b=a.prototype;h.prototype=new b;h.prototype.constructor=h;h.a=function(b,c,g){for(var e=Array(arguments.length-2),k=2;k<arguments.length;k++)e[k-2]=arguments[k];return a.prototype[c].apply(b,e)}})();var m=\"unknown error\",l={15:\"element not selectable\",11:\"element not visible\"};l[31]=m;l[30]=m;l[24]=\"invalid cookie domain\";l[29]=\"invalid element coordinates\";l[12]=\"invalid element state\";l[32]=\"invalid selector\";l[51]=\"invalid selector\";\nl[52]=\"invalid selector\";l[17]=\"javascript error\";l[405]=\"unsupported operation\";l[34]=\"move target out of bounds\";l[27]=\"no such alert\";l[7]=\"no such element\";l[8]=\"no such frame\";l[23]=\"no such window\";l[28]=\"script timeout\";l[33]=\"session not created\";l[10]=\"stale element reference\";l[21]=\"timeout\";l[25]=\"unable to set cookie\";l[26]=\"unexpected alert open\";l[13]=m;l[9]=\"unknown command\";h.prototype.toString=function(){return this.name+\": \"+this.message};var n;a:{var p=d.navigator;if(p){var q=p.userAgent;if(q){n=q;break a}}n=\"\"}function r(a){return-1!=n.indexOf(a)};function t(a,b){for(var e=a.length,c=f(a)?a.split(\"\"):a,g=0;g<e;g++)g in c&&b.call(void 0,c[g],g,a)};function v(){return r(\"iPhone\")&&!r(\"iPod\")&&!r(\"iPad\")};function w(){return(r(\"Chrome\")||r(\"CriOS\"))&&!r(\"Edge\")};var x=r(\"Opera\"),y=r(\"Trident\")||r(\"MSIE\"),z=r(\"Edge\"),A=r(\"Gecko\")&&!(-1!=n.toLowerCase().indexOf(\"webkit\")&&!r(\"Edge\"))&&!(r(\"Trident\")||r(\"MSIE\"))&&!r(\"Edge\"),aa=-1!=n.toLowerCase().indexOf(\"webkit\")&&!r(\"Edge\");function B(){var a=d.document;return a?a.documentMode:void 0}var C;\na:{var D=\"\",E=function(){var a=n;if(A)return/rv\\:([^\\);]+)(\\)|;)/.exec(a);if(z)return/Edge\\/([\\d\\.]+)/.exec(a);if(y)return/\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(a);if(aa)return/WebKit\\/(\\S+)/.exec(a);if(x)return/(?:Version)[ \\/]?(\\S+)/.exec(a)}();E&&(D=E?E[1]:\"\");if(y){var F=B();if(null!=F&&F>parseFloat(D)){C=String(F);break a}}C=D}var G;var H=d.document;G=H&&y?B()||(\"CSS1Compat\"==H.compatMode?parseInt(C,10):5):void 0;var ba=r(\"Firefox\"),ca=v()||r(\"iPod\"),da=r(\"iPad\"),I=r(\"Android\")&&!(w()||r(\"Firefox\")||r(\"Opera\")||r(\"Silk\")),ea=w(),J=r(\"Safari\")&&!(w()||r(\"Coast\")||r(\"Opera\")||r(\"Edge\")||r(\"Silk\")||r(\"Android\"))&&!(v()||r(\"iPad\")||r(\"iPod\"));function K(a){return(a=a.exec(n))?a[1]:\"\"}(function(){if(ba)return K(/Firefox\\/([0-9.]+)/);if(y||z||x)return C;if(ea)return v()||r(\"iPad\")||r(\"iPod\")?K(/CriOS\\/([0-9.]+)/):K(/Chrome\\/([0-9.]+)/);if(J&&!(v()||r(\"iPad\")||r(\"iPod\")))return K(/Version\\/([0-9.]+)/);if(ca||da){var a=/Version\\/(\\S+).*Mobile\\/(\\S+)/.exec(n);if(a)return a[1]+\".\"+a[2]}else if(I)return(a=K(/Android\\s+([0-9.]+)/))?a:K(/Version\\/([0-9.]+)/);return\"\"})();var L,M=function(){if(!A)return!1;var a=d.Components;if(!a)return!1;try{if(!a.classes)return!1}catch(g){return!1}var b=a.classes,a=a.interfaces,e=b[\"@mozilla.org/xpcom/version-comparator;1\"].getService(a.nsIVersionComparator),c=b[\"@mozilla.org/xre/app-info;1\"].getService(a.nsIXULAppInfo).version;L=function(a){e.compare(c,\"\"+a)};return!0}(),N=y&&!(8<=Number(G)),fa=y&&!(9<=Number(G));I&&M&&L(2.3);I&&M&&L(4);J&&M&&L(6);var ga={SCRIPT:1,STYLE:1,HEAD:1,IFRAME:1,OBJECT:1},O={IMG:\" \",BR:\"\\n\"};function P(a,b,e){if(!(a.nodeName in ga))if(3==a.nodeType)e?b.push(String(a.nodeValue).replace(/(\\r\\n|\\r|\\n)/g,\"\")):b.push(a.nodeValue);else if(a.nodeName in O)b.push(O[a.nodeName]);else for(a=a.firstChild;a;)P(a,b,e),a=a.nextSibling};function Q(a,b){b=b.toLowerCase();return\"style\"==b?ha(a.style.cssText):N&&\"value\"==b&&R(a,\"INPUT\")?a.value:fa&&!0===a[b]?String(a.getAttribute(b)):(a=a.getAttributeNode(b))&&a.specified?a.value:null}var ia=/[;]+(?=(?:(?:[^\"]*\"){2})*[^\"]*$)(?=(?:(?:[^']*'){2})*[^']*$)(?=(?:[^()]*\\([^()]*\\))*[^()]*$)/;\nfunction ha(a){var b=[];t(a.split(ia),function(a){var c=a.indexOf(\":\");0<c&&(a=[a.slice(0,c),a.slice(c+1)],2==a.length&&b.push(a[0].toLowerCase(),\":\",a[1],\";\"))});b=b.join(\"\");return b=\";\"==b.charAt(b.length-1)?b:b+\";\"}function S(a,b){N&&\"value\"==b&&R(a,\"OPTION\")&&null===Q(a,\"value\")?(b=[],P(a,b,!1),a=b.join(\"\")):a=a[b];return a}function R(a,b){b&&\"string\"!==typeof b&&(b=b.toString());return!!a&&1==a.nodeType&&(!b||a.tagName.toUpperCase()==b)}\nfunction T(a){return R(a,\"OPTION\")?!0:R(a,\"INPUT\")?(a=a.type.toLowerCase(),\"checkbox\"==a||\"radio\"==a):!1};var ja={\"class\":\"className\",readonly:\"readOnly\"},U=\"async autofocus autoplay checked compact complete controls declare defaultchecked defaultselected defer disabled draggable ended formnovalidate hidden indeterminate iscontenteditable ismap itemscope loop multiple muted nohref noresize noshade novalidate nowrap open paused pubdate readonly required reversed scoped seamless seeking selected spellcheck truespeed willvalidate\".split(\" \");function V(a,b){var e=null,c=b.toLowerCase();if(\"style\"==c)return(e=a.style)&&!f(e)&&(e=e.cssText),e;if((\"selected\"==c||\"checked\"==c)&&T(a)){if(!T(a))throw new h(15,\"Element is not selectable\");b=\"selected\";e=a.type&&a.type.toLowerCase();if(\"checkbox\"==e||\"radio\"==e)b=\"checked\";return S(a,b)?\"true\":null}var g=R(a,\"A\");if(R(a,\"IMG\")&&\"src\"==c||g&&\"href\"==c)return(e=Q(a,c))&&(e=S(a,c)),e;if(\"spellcheck\"==c){e=Q(a,c);if(null!==e){if(\"false\"==e.toLowerCase())return\"false\";if(\"true\"==e.toLowerCase())return\"true\"}return S(a,\nc)+\"\"}g=ja[b]||b;a:if(f(U))c=f(c)&&1==c.length?U.indexOf(c,0):-1;else{for(var u=0;u<U.length;u++)if(u in U&&U[u]===c){c=u;break a}c=-1}if(0<=c)return(e=null!==Q(a,b)||S(a,g))?\"true\":null;try{var k=S(a,g)}catch(ka){}(c=null==k)||(c=typeof k,c=\"object\"==c&&null!=k||\"function\"==c);c?e=Q(a,b):e=k;return null!=e?e.toString():null}var W=[\"_\"],X=d;W[0]in X||!X.execScript||X.execScript(\"var \"+W[0]);\nfor(var Y;W.length&&(Y=W.shift());){var Z;if(Z=!W.length)Z=void 0!==V;Z?X[Y]=V:X[Y]&&X[Y]!==Object.prototype[Y]?X=X[Y]:X=X[Y]={}};; return this._.apply(null,arguments);}.apply({navigator:typeof window!='undefined'?window.navigator:null,document:typeof window!='undefined'?window.document:null}, arguments);};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/atoms/get-attribute.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/atoms/is-displayed.js":
/*!********************************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/atoms/is-displayed.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// GENERATED CODE - DO NOT EDIT\nmodule.exports = function(){return function(){var k=this;function l(a){return void 0!==a}function m(a){return\"string\"==typeof a}function aa(a,b){a=a.split(\".\");var c=k;a[0]in c||!c.execScript||c.execScript(\"var \"+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&l(b)?c[d]=b:c[d]&&c[d]!==Object.prototype[d]?c=c[d]:c=c[d]={}}\nfunction ba(a){var b=typeof a;if(\"object\"==b)if(a){if(a instanceof Array)return\"array\";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if(\"[object Window]\"==c)return\"object\";if(\"[object Array]\"==c||\"number\"==typeof a.length&&\"undefined\"!=typeof a.splice&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"splice\"))return\"array\";if(\"[object Function]\"==c||\"undefined\"!=typeof a.call&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"call\"))return\"function\"}else return\"null\";\nelse if(\"function\"==b&&\"undefined\"==typeof a.call)return\"object\";return b}function ca(a,b,c){return a.call.apply(a.bind,arguments)}function da(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}\nfunction ea(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf(\"native code\")?ea=ca:ea=da;return ea.apply(null,arguments)}function fa(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}}\nfunction p(a,b){function c(){}c.prototype=b.prototype;a.L=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.K=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};function ga(a,b){this.code=a;this.a=q[a]||ha;this.message=b||\"\";a=this.a.replace(/((?:^|\\s+)[a-z])/g,function(a){return a.toUpperCase().replace(/^[\\s\\xa0]+/g,\"\")});b=a.length-5;if(0>b||a.indexOf(\"Error\",b)!=b)a+=\"Error\";this.name=a;a=Error(this.message);a.name=this.name;this.stack=a.stack||\"\"}p(ga,Error);var ha=\"unknown error\",q={15:\"element not selectable\",11:\"element not visible\"};q[31]=ha;q[30]=ha;q[24]=\"invalid cookie domain\";q[29]=\"invalid element coordinates\";q[12]=\"invalid element state\";\nq[32]=\"invalid selector\";q[51]=\"invalid selector\";q[52]=\"invalid selector\";q[17]=\"javascript error\";q[405]=\"unsupported operation\";q[34]=\"move target out of bounds\";q[27]=\"no such alert\";q[7]=\"no such element\";q[8]=\"no such frame\";q[23]=\"no such window\";q[28]=\"script timeout\";q[33]=\"session not created\";q[10]=\"stale element reference\";q[21]=\"timeout\";q[25]=\"unable to set cookie\";q[26]=\"unexpected alert open\";q[13]=ha;q[9]=\"unknown command\";ga.prototype.toString=function(){return this.name+\": \"+this.message};var ia={aliceblue:\"#f0f8ff\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",aquamarine:\"#7fffd4\",azure:\"#f0ffff\",beige:\"#f5f5dc\",bisque:\"#ffe4c4\",black:\"#000000\",blanchedalmond:\"#ffebcd\",blue:\"#0000ff\",blueviolet:\"#8a2be2\",brown:\"#a52a2a\",burlywood:\"#deb887\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",cornflowerblue:\"#6495ed\",cornsilk:\"#fff8dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",\ndarkgrey:\"#a9a9a9\",darkkhaki:\"#bdb76b\",darkmagenta:\"#8b008b\",darkolivegreen:\"#556b2f\",darkorange:\"#ff8c00\",darkorchid:\"#9932cc\",darkred:\"#8b0000\",darksalmon:\"#e9967a\",darkseagreen:\"#8fbc8f\",darkslateblue:\"#483d8b\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",darkturquoise:\"#00ced1\",darkviolet:\"#9400d3\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",dimgray:\"#696969\",dimgrey:\"#696969\",dodgerblue:\"#1e90ff\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",forestgreen:\"#228b22\",fuchsia:\"#ff00ff\",gainsboro:\"#dcdcdc\",\nghostwhite:\"#f8f8ff\",gold:\"#ffd700\",goldenrod:\"#daa520\",gray:\"#808080\",green:\"#008000\",greenyellow:\"#adff2f\",grey:\"#808080\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",ivory:\"#fffff0\",khaki:\"#f0e68c\",lavender:\"#e6e6fa\",lavenderblush:\"#fff0f5\",lawngreen:\"#7cfc00\",lemonchiffon:\"#fffacd\",lightblue:\"#add8e6\",lightcoral:\"#f08080\",lightcyan:\"#e0ffff\",lightgoldenrodyellow:\"#fafad2\",lightgray:\"#d3d3d3\",lightgreen:\"#90ee90\",lightgrey:\"#d3d3d3\",lightpink:\"#ffb6c1\",lightsalmon:\"#ffa07a\",\nlightseagreen:\"#20b2aa\",lightskyblue:\"#87cefa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",lightsteelblue:\"#b0c4de\",lightyellow:\"#ffffe0\",lime:\"#00ff00\",limegreen:\"#32cd32\",linen:\"#faf0e6\",magenta:\"#ff00ff\",maroon:\"#800000\",mediumaquamarine:\"#66cdaa\",mediumblue:\"#0000cd\",mediumorchid:\"#ba55d3\",mediumpurple:\"#9370db\",mediumseagreen:\"#3cb371\",mediumslateblue:\"#7b68ee\",mediumspringgreen:\"#00fa9a\",mediumturquoise:\"#48d1cc\",mediumvioletred:\"#c71585\",midnightblue:\"#191970\",mintcream:\"#f5fffa\",mistyrose:\"#ffe4e1\",\nmoccasin:\"#ffe4b5\",navajowhite:\"#ffdead\",navy:\"#000080\",oldlace:\"#fdf5e6\",olive:\"#808000\",olivedrab:\"#6b8e23\",orange:\"#ffa500\",orangered:\"#ff4500\",orchid:\"#da70d6\",palegoldenrod:\"#eee8aa\",palegreen:\"#98fb98\",paleturquoise:\"#afeeee\",palevioletred:\"#db7093\",papayawhip:\"#ffefd5\",peachpuff:\"#ffdab9\",peru:\"#cd853f\",pink:\"#ffc0cb\",plum:\"#dda0dd\",powderblue:\"#b0e0e6\",purple:\"#800080\",red:\"#ff0000\",rosybrown:\"#bc8f8f\",royalblue:\"#4169e1\",saddlebrown:\"#8b4513\",salmon:\"#fa8072\",sandybrown:\"#f4a460\",seagreen:\"#2e8b57\",\nseashell:\"#fff5ee\",sienna:\"#a0522d\",silver:\"#c0c0c0\",skyblue:\"#87ceeb\",slateblue:\"#6a5acd\",slategray:\"#708090\",slategrey:\"#708090\",snow:\"#fffafa\",springgreen:\"#00ff7f\",steelblue:\"#4682b4\",tan:\"#d2b48c\",teal:\"#008080\",thistle:\"#d8bfd8\",tomato:\"#ff6347\",turquoise:\"#40e0d0\",violet:\"#ee82ee\",wheat:\"#f5deb3\",white:\"#ffffff\",whitesmoke:\"#f5f5f5\",yellow:\"#ffff00\",yellowgreen:\"#9acd32\"};function ja(a,b){this.width=a;this.height=b}ja.prototype.toString=function(){return\"(\"+this.width+\" x \"+this.height+\")\"};ja.prototype.ceil=function(){this.width=Math.ceil(this.width);this.height=Math.ceil(this.height);return this};ja.prototype.floor=function(){this.width=Math.floor(this.width);this.height=Math.floor(this.height);return this};ja.prototype.round=function(){this.width=Math.round(this.width);this.height=Math.round(this.height);return this};function ka(a,b){var c=la;return Object.prototype.hasOwnProperty.call(c,a)?c[a]:c[a]=b(a)};var ma=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g,\"\")};function na(a,b){return a<b?-1:a>b?1:0}function oa(a){return String(a).replace(/\\-([a-z])/g,function(a,c){return c.toUpperCase()})};/*\n\n The MIT License\n\n Copyright (c) 2007 Cybozu Labs, Inc.\n Copyright (c) 2012 Google Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to\n deal in the Software without restriction, including without limitation the\n rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n sell copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n IN THE SOFTWARE.\n*/\nfunction pa(a,b,c){this.a=a;this.b=b||1;this.f=c||1};function qa(a){this.b=a;this.a=0}function ra(a){a=a.match(sa);for(var b=0;b<a.length;b++)ta.test(a[b])&&a.splice(b,1);return new qa(a)}var sa=/\\$?(?:(?![0-9-\\.])(?:\\*|[\\w-\\.]+):)?(?![0-9-\\.])(?:\\*|[\\w-\\.]+)|\\/\\/|\\.\\.|::|\\d+(?:\\.\\d*)?|\\.\\d+|\"[^\"]*\"|'[^']*'|[!<>]=|\\s+|./g,ta=/^\\s/;function t(a,b){return a.b[a.a+(b||0)]}function u(a){return a.b[a.a++]}function ua(a){return a.b.length<=a.a};var v;a:{var va=k.navigator;if(va){var wa=va.userAgent;if(wa){v=wa;break a}}v=\"\"}function x(a){return-1!=v.indexOf(a)};function y(a,b){this.h=a;this.c=l(b)?b:null;this.b=null;switch(a){case \"comment\":this.b=8;break;case \"text\":this.b=3;break;case \"processing-instruction\":this.b=7;break;case \"node\":break;default:throw Error(\"Unexpected argument\");}}function xa(a){return\"comment\"==a||\"text\"==a||\"processing-instruction\"==a||\"node\"==a}y.prototype.a=function(a){return null===this.b||this.b==a.nodeType};y.prototype.f=function(){return this.h};\ny.prototype.toString=function(){var a=\"Kind Test: \"+this.h;null===this.c||(a+=z(this.c));return a};function ya(a,b){this.j=a.toLowerCase();a=\"*\"==this.j?\"*\":\"http://www.w3.org/1999/xhtml\";this.c=b?b.toLowerCase():a}ya.prototype.a=function(a){var b=a.nodeType;if(1!=b&&2!=b)return!1;b=l(a.localName)?a.localName:a.nodeName;return\"*\"!=this.j&&this.j!=b.toLowerCase()?!1:\"*\"==this.c?!0:this.c==(a.namespaceURI?a.namespaceURI.toLowerCase():\"http://www.w3.org/1999/xhtml\")};ya.prototype.f=function(){return this.j};\nya.prototype.toString=function(){return\"Name Test: \"+(\"http://www.w3.org/1999/xhtml\"==this.c?\"\":this.c+\":\")+this.j};function za(a){switch(a.nodeType){case 1:return fa(Aa,a);case 9:return za(a.documentElement);case 11:case 10:case 6:case 12:return Ba;default:return a.parentNode?za(a.parentNode):Ba}}function Ba(){return null}function Aa(a,b){if(a.prefix==b)return a.namespaceURI||\"http://www.w3.org/1999/xhtml\";var c=a.getAttributeNode(\"xmlns:\"+b);return c&&c.specified?c.value||null:a.parentNode&&9!=a.parentNode.nodeType?Aa(a.parentNode,b):null};function Ca(a,b){if(m(a))return m(b)&&1==b.length?a.indexOf(b,0):-1;for(var c=0;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1}function A(a,b){for(var c=a.length,d=m(a)?a.split(\"\"):a,e=0;e<c;e++)e in d&&b.call(void 0,d[e],e,a)}function Da(a,b){for(var c=a.length,d=[],e=0,f=m(a)?a.split(\"\"):a,g=0;g<c;g++)if(g in f){var h=f[g];b.call(void 0,h,g,a)&&(d[e++]=h)}return d}function Ea(a,b,c){var d=c;A(a,function(c,f){d=b.call(void 0,d,c,f,a)});return d}\nfunction Fa(a,b){for(var c=a.length,d=m(a)?a.split(\"\"):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a))return!0;return!1}function Ga(a,b){for(var c=a.length,d=m(a)?a.split(\"\"):a,e=0;e<c;e++)if(e in d&&!b.call(void 0,d[e],e,a))return!1;return!0}function Ha(a,b){a:{for(var c=a.length,d=m(a)?a.split(\"\"):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1}return 0>b?null:m(a)?a.charAt(b):a[b]}function Ia(a){return Array.prototype.concat.apply([],arguments)}\nfunction Ja(a,b,c){return 2>=arguments.length?Array.prototype.slice.call(a,b):Array.prototype.slice.call(a,b,c)};function Ka(){return x(\"iPhone\")&&!x(\"iPod\")&&!x(\"iPad\")};var La=\"backgroundColor borderTopColor borderRightColor borderBottomColor borderLeftColor color outlineColor\".split(\" \"),Ma=/#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])/,Na=/^#(?:[0-9a-f]{3}){1,2}$/i,Oa=/^(?:rgba)?\\((\\d{1,3}),\\s?(\\d{1,3}),\\s?(\\d{1,3}),\\s?(0|1|0\\.\\d*)\\)$/i,Pa=/^(?:rgb)?\\((0|[1-9]\\d{0,2}),\\s?(0|[1-9]\\d{0,2}),\\s?(0|[1-9]\\d{0,2})\\)$/i;function Qa(){return(x(\"Chrome\")||x(\"CriOS\"))&&!x(\"Edge\")};function Ra(a,b){this.x=l(a)?a:0;this.y=l(b)?b:0}Ra.prototype.toString=function(){return\"(\"+this.x+\", \"+this.y+\")\"};Ra.prototype.ceil=function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this};Ra.prototype.floor=function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this};Ra.prototype.round=function(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this};var Sa=x(\"Opera\"),C=x(\"Trident\")||x(\"MSIE\"),Ta=x(\"Edge\"),Ua=x(\"Gecko\")&&!(-1!=v.toLowerCase().indexOf(\"webkit\")&&!x(\"Edge\"))&&!(x(\"Trident\")||x(\"MSIE\"))&&!x(\"Edge\"),Va=-1!=v.toLowerCase().indexOf(\"webkit\")&&!x(\"Edge\");function Wa(){var a=k.document;return a?a.documentMode:void 0}var Xa;\na:{var Ya=\"\",Za=function(){var a=v;if(Ua)return/rv\\:([^\\);]+)(\\)|;)/.exec(a);if(Ta)return/Edge\\/([\\d\\.]+)/.exec(a);if(C)return/\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(a);if(Va)return/WebKit\\/(\\S+)/.exec(a);if(Sa)return/(?:Version)[ \\/]?(\\S+)/.exec(a)}();Za&&(Ya=Za?Za[1]:\"\");if(C){var $a=Wa();if(null!=$a&&$a>parseFloat(Ya)){Xa=String($a);break a}}Xa=Ya}var la={};\nfunction ab(a){return ka(a,function(){for(var b=0,c=ma(String(Xa)).split(\".\"),d=ma(String(a)).split(\".\"),e=Math.max(c.length,d.length),f=0;!b&&f<e;f++){var g=c[f]||\"\",h=d[f]||\"\";do{g=/(\\d*)(\\D*)(.*)/.exec(g)||[\"\",\"\",\"\",\"\"];h=/(\\d*)(\\D*)(.*)/.exec(h)||[\"\",\"\",\"\",\"\"];if(0==g[0].length&&0==h[0].length)break;b=na(0==g[1].length?0:parseInt(g[1],10),0==h[1].length?0:parseInt(h[1],10))||na(0==g[2].length,0==h[2].length)||na(g[2],h[2]);g=g[3];h=h[3]}while(!b)}return 0<=b})}var bb;var cb=k.document;\nbb=cb&&C?Wa()||(\"CSS1Compat\"==cb.compatMode?parseInt(Xa,10):5):void 0;function db(a,b,c,d){this.c=a;this.a=b;this.b=c;this.f=d}db.prototype.toString=function(){return\"(\"+this.c+\"t, \"+this.a+\"r, \"+this.b+\"b, \"+this.f+\"l)\"};db.prototype.ceil=function(){this.c=Math.ceil(this.c);this.a=Math.ceil(this.a);this.b=Math.ceil(this.b);this.f=Math.ceil(this.f);return this};db.prototype.floor=function(){this.c=Math.floor(this.c);this.a=Math.floor(this.a);this.b=Math.floor(this.b);this.f=Math.floor(this.f);return this};\ndb.prototype.round=function(){this.c=Math.round(this.c);this.a=Math.round(this.a);this.b=Math.round(this.b);this.f=Math.round(this.f);return this};var eb=x(\"Firefox\"),fb=Ka()||x(\"iPod\"),gb=x(\"iPad\"),hb=x(\"Android\")&&!(Qa()||x(\"Firefox\")||x(\"Opera\")||x(\"Silk\")),ib=Qa(),jb=x(\"Safari\")&&!(Qa()||x(\"Coast\")||x(\"Opera\")||x(\"Edge\")||x(\"Silk\")||x(\"Android\"))&&!(Ka()||x(\"iPad\")||x(\"iPod\"));var D=C&&!(9<=Number(bb)),kb=C&&!(8<=Number(bb));function E(a,b,c,d){this.a=a;this.b=b;this.width=c;this.height=d}E.prototype.toString=function(){return\"(\"+this.a+\", \"+this.b+\" - \"+this.width+\"w x \"+this.height+\"h)\"};E.prototype.ceil=function(){this.a=Math.ceil(this.a);this.b=Math.ceil(this.b);this.width=Math.ceil(this.width);this.height=Math.ceil(this.height);return this};E.prototype.floor=function(){this.a=Math.floor(this.a);this.b=Math.floor(this.b);this.width=Math.floor(this.width);this.height=Math.floor(this.height);return this};\nE.prototype.round=function(){this.a=Math.round(this.a);this.b=Math.round(this.b);this.width=Math.round(this.width);this.height=Math.round(this.height);return this};function lb(a){return(a=a.exec(v))?a[1]:\"\"}(function(){if(eb)return lb(/Firefox\\/([0-9.]+)/);if(C||Ta||Sa)return Xa;if(ib)return Ka()||x(\"iPad\")||x(\"iPod\")?lb(/CriOS\\/([0-9.]+)/):lb(/Chrome\\/([0-9.]+)/);if(jb&&!(Ka()||x(\"iPad\")||x(\"iPod\")))return lb(/Version\\/([0-9.]+)/);if(fb||gb){var a=/Version\\/(\\S+).*Mobile\\/(\\S+)/.exec(v);if(a)return a[1]+\".\"+a[2]}else if(hb)return(a=lb(/Android\\s+([0-9.]+)/))?a:lb(/Version\\/([0-9.]+)/);return\"\"})();function mb(a,b,c,d){this.a=a;this.nodeName=c;this.nodeValue=d;this.nodeType=2;this.parentNode=this.ownerElement=b}function nb(a,b){var c=kb&&\"href\"==b.nodeName?a.getAttribute(b.nodeName,2):b.nodeValue;return new mb(b,a,b.nodeName,c)};var ob,pb=function(){if(!Ua)return!1;var a=k.Components;if(!a)return!1;try{if(!a.classes)return!1}catch(e){return!1}var b=a.classes,a=a.interfaces,c=b[\"@mozilla.org/xpcom/version-comparator;1\"].getService(a.nsIVersionComparator),d=b[\"@mozilla.org/xre/app-info;1\"].getService(a.nsIXULAppInfo).version;ob=function(a){c.compare(d,\"\"+a)};return!0}(),qb=C&&!(9<=Number(bb));hb&&pb&&ob(2.3);hb&&pb&&ob(4);jb&&pb&&ob(6);function rb(a,b){if(!a||!b)return!1;if(a.contains&&1==b.nodeType)return a==b||a.contains(b);if(\"undefined\"!=typeof a.compareDocumentPosition)return a==b||!!(a.compareDocumentPosition(b)&16);for(;b&&a!=b;)b=b.parentNode;return b==a}\nfunction sb(a,b){if(a==b)return 0;if(a.compareDocumentPosition)return a.compareDocumentPosition(b)&2?1:-1;if(C&&!(9<=Number(bb))){if(9==a.nodeType)return-1;if(9==b.nodeType)return 1}if(\"sourceIndex\"in a||a.parentNode&&\"sourceIndex\"in a.parentNode){var c=1==a.nodeType,d=1==b.nodeType;if(c&&d)return a.sourceIndex-b.sourceIndex;var e=a.parentNode,f=b.parentNode;return e==f?tb(a,b):!c&&rb(e,b)?-1*ub(a,b):!d&&rb(f,a)?ub(b,a):(c?a.sourceIndex:e.sourceIndex)-(d?b.sourceIndex:f.sourceIndex)}d=F(a);c=d.createRange();\nc.selectNode(a);c.collapse(!0);a=d.createRange();a.selectNode(b);a.collapse(!0);return c.compareBoundaryPoints(k.Range.START_TO_END,a)}function ub(a,b){var c=a.parentNode;if(c==b)return-1;for(;b.parentNode!=c;)b=b.parentNode;return tb(b,a)}function tb(a,b){for(;b=b.previousSibling;)if(b==a)return-1;return 1}function F(a){return 9==a.nodeType?a:a.ownerDocument||a.document}function vb(a,b){a&&(a=a.parentNode);for(var c=0;a;){if(b(a))return a;a=a.parentNode;c++}return null}\nfunction wb(a){this.a=a||k.document||document}wb.prototype.getElementsByTagName=function(a,b){return(b||this.a).getElementsByTagName(String(a))};function G(a){var b=null,c=a.nodeType;1==c&&(b=a.textContent,b=void 0==b||null==b?a.innerText:b,b=void 0==b||null==b?\"\":b);if(\"string\"!=typeof b)if(D&&\"title\"==a.nodeName.toLowerCase()&&1==c)b=a.text;else if(9==c||1==c){a=9==c?a.documentElement:a.firstChild;for(var c=0,d=[],b=\"\";a;){do 1!=a.nodeType&&(b+=a.nodeValue),D&&\"title\"==a.nodeName.toLowerCase()&&(b+=a.text),d[c++]=a;while(a=a.firstChild);for(;c&&!(a=d[--c].nextSibling););}}else b=a.nodeValue;return\"\"+b}\nfunction H(a,b,c){if(null===b)return!0;try{if(!a.getAttribute)return!1}catch(d){return!1}kb&&\"class\"==b&&(b=\"className\");return null==c?!!a.getAttribute(b):a.getAttribute(b,2)==c}function xb(a,b,c,d,e){return(D?yb:zb).call(null,a,b,m(c)?c:null,m(d)?d:null,e||new I)}\nfunction yb(a,b,c,d,e){if(a instanceof ya||8==a.b||c&&null===a.b){var f=b.all;if(!f)return e;var g=Ab(a);if(\"*\"!=g&&(f=b.getElementsByTagName(g),!f))return e;if(c){var h=[];for(a=0;b=f[a++];)H(b,c,d)&&h.push(b);f=h}for(a=0;b=f[a++];)\"*\"==g&&\"!\"==b.tagName||J(e,b);return e}Bb(a,b,c,d,e);return e}\nfunction zb(a,b,c,d,e){b.getElementsByName&&d&&\"name\"==c&&!C?(b=b.getElementsByName(d),A(b,function(b){a.a(b)&&J(e,b)})):b.getElementsByClassName&&d&&\"class\"==c?(b=b.getElementsByClassName(d),A(b,function(b){b.className==d&&a.a(b)&&J(e,b)})):a instanceof y?Bb(a,b,c,d,e):b.getElementsByTagName&&(b=b.getElementsByTagName(a.f()),A(b,function(a){H(a,c,d)&&J(e,a)}));return e}\nfunction Cb(a,b,c,d,e){var f;if((a instanceof ya||8==a.b||c&&null===a.b)&&(f=b.childNodes)){var g=Ab(a);if(\"*\"!=g&&(f=Da(f,function(a){return a.tagName&&a.tagName.toLowerCase()==g}),!f))return e;c&&(f=Da(f,function(a){return H(a,c,d)}));A(f,function(a){\"*\"==g&&(\"!\"==a.tagName||\"*\"==g&&1!=a.nodeType)||J(e,a)});return e}return Db(a,b,c,d,e)}function Db(a,b,c,d,e){for(b=b.firstChild;b;b=b.nextSibling)H(b,c,d)&&a.a(b)&&J(e,b);return e}\nfunction Bb(a,b,c,d,e){for(b=b.firstChild;b;b=b.nextSibling)H(b,c,d)&&a.a(b)&&J(e,b),Bb(a,b,c,d,e)}function Ab(a){if(a instanceof y){if(8==a.b)return\"!\";if(null===a.b)return\"*\"}return a.f()};function K(a,b){b&&\"string\"!==typeof b&&(b=b.toString());return!!a&&1==a.nodeType&&(!b||a.tagName.toUpperCase()==b)};function I(){this.b=this.a=null;this.l=0}function Eb(a){this.node=a;this.a=this.b=null}function Fb(a,b){if(!a.a)return b;if(!b.a)return a;var c=a.a;b=b.a;for(var d=null,e,f=0;c&&b;){e=c.node;var g=b.node;e==g||e instanceof mb&&g instanceof mb&&e.a==g.a?(e=c,c=c.a,b=b.a):0<sb(c.node,b.node)?(e=b,b=b.a):(e=c,c=c.a);(e.b=d)?d.a=e:a.a=e;d=e;f++}for(e=c||b;e;)e.b=d,d=d.a=e,f++,e=e.a;a.b=d;a.l=f;return a}function Gb(a,b){b=new Eb(b);b.a=a.a;a.b?a.a.b=b:a.a=a.b=b;a.a=b;a.l++}\nfunction J(a,b){b=new Eb(b);b.b=a.b;a.a?a.b.a=b:a.a=a.b=b;a.b=b;a.l++}function Hb(a){return(a=a.a)?a.node:null}function Ib(a){return(a=Hb(a))?G(a):\"\"}function L(a,b){return new Jb(a,!!b)}function Jb(a,b){this.f=a;this.b=(this.s=b)?a.b:a.a;this.a=null}function N(a){var b=a.b;if(b){var c=a.a=b;a.b=a.s?b.b:b.a;return c.node}return null};function O(a){this.i=a;this.b=this.g=!1;this.f=null}function z(a){return\"\\n  \"+a.toString().split(\"\\n\").join(\"\\n  \")}function Kb(a,b){a.g=b}function Lb(a,b){a.b=b}function Q(a,b){a=a.a(b);return a instanceof I?+Ib(a):+a}function R(a,b){a=a.a(b);return a instanceof I?Ib(a):\"\"+a}function Mb(a,b){a=a.a(b);return a instanceof I?!!a.l:!!a};function Nb(a,b,c){O.call(this,a.i);this.c=a;this.h=b;this.o=c;this.g=b.g||c.g;this.b=b.b||c.b;this.c==Ob&&(c.b||c.g||4==c.i||0==c.i||!b.f?b.b||b.g||4==b.i||0==b.i||!c.f||(this.f={name:c.f.name,u:b}):this.f={name:b.f.name,u:c})}p(Nb,O);\nfunction Pb(a,b,c,d,e){b=b.a(d);c=c.a(d);var f;if(b instanceof I&&c instanceof I){b=L(b);for(d=N(b);d;d=N(b))for(e=L(c),f=N(e);f;f=N(e))if(a(G(d),G(f)))return!0;return!1}if(b instanceof I||c instanceof I){b instanceof I?(e=b,d=c):(e=c,d=b);f=L(e);for(var g=typeof d,h=N(f);h;h=N(f)){switch(g){case \"number\":h=+G(h);break;case \"boolean\":h=!!G(h);break;case \"string\":h=G(h);break;default:throw Error(\"Illegal primitive type for comparison.\");}if(e==b&&a(h,d)||e==c&&a(d,h))return!0}return!1}return e?\"boolean\"==\ntypeof b||\"boolean\"==typeof c?a(!!b,!!c):\"number\"==typeof b||\"number\"==typeof c?a(+b,+c):a(b,c):a(+b,+c)}Nb.prototype.a=function(a){return this.c.m(this.h,this.o,a)};Nb.prototype.toString=function(){var a=\"Binary Expression: \"+this.c,a=a+z(this.h);return a+=z(this.o)};function Qb(a,b,c,d){this.I=a;this.D=b;this.i=c;this.m=d}Qb.prototype.toString=function(){return this.I};var Rb={};\nfunction S(a,b,c,d){if(Rb.hasOwnProperty(a))throw Error(\"Binary operator already created: \"+a);a=new Qb(a,b,c,d);return Rb[a.toString()]=a}S(\"div\",6,1,function(a,b,c){return Q(a,c)/Q(b,c)});S(\"mod\",6,1,function(a,b,c){return Q(a,c)%Q(b,c)});S(\"*\",6,1,function(a,b,c){return Q(a,c)*Q(b,c)});S(\"+\",5,1,function(a,b,c){return Q(a,c)+Q(b,c)});S(\"-\",5,1,function(a,b,c){return Q(a,c)-Q(b,c)});S(\"<\",4,2,function(a,b,c){return Pb(function(a,b){return a<b},a,b,c)});\nS(\">\",4,2,function(a,b,c){return Pb(function(a,b){return a>b},a,b,c)});S(\"<=\",4,2,function(a,b,c){return Pb(function(a,b){return a<=b},a,b,c)});S(\">=\",4,2,function(a,b,c){return Pb(function(a,b){return a>=b},a,b,c)});var Ob=S(\"=\",3,2,function(a,b,c){return Pb(function(a,b){return a==b},a,b,c,!0)});S(\"!=\",3,2,function(a,b,c){return Pb(function(a,b){return a!=b},a,b,c,!0)});S(\"and\",2,2,function(a,b,c){return Mb(a,c)&&Mb(b,c)});S(\"or\",1,2,function(a,b,c){return Mb(a,c)||Mb(b,c)});function Sb(a,b){if(b.a.length&&4!=a.i)throw Error(\"Primary expression must evaluate to nodeset if filter has predicate(s).\");O.call(this,a.i);this.c=a;this.h=b;this.g=a.g;this.b=a.b}p(Sb,O);Sb.prototype.a=function(a){a=this.c.a(a);return Tb(this.h,a)};Sb.prototype.toString=function(){var a=\"Filter:\"+z(this.c);return a+=z(this.h)};function Ub(a,b){if(b.length<a.C)throw Error(\"Function \"+a.j+\" expects at least\"+a.C+\" arguments, \"+b.length+\" given\");if(null!==a.A&&b.length>a.A)throw Error(\"Function \"+a.j+\" expects at most \"+a.A+\" arguments, \"+b.length+\" given\");a.H&&A(b,function(b,d){if(4!=b.i)throw Error(\"Argument \"+d+\" to function \"+a.j+\" is not of type Nodeset: \"+b);});O.call(this,a.i);this.v=a;this.c=b;Kb(this,a.g||Fa(b,function(a){return a.g}));Lb(this,a.G&&!b.length||a.F&&!!b.length||Fa(b,function(a){return a.b}))}\np(Ub,O);Ub.prototype.a=function(a){return this.v.m.apply(null,Ia(a,this.c))};Ub.prototype.toString=function(){var a=\"Function: \"+this.v;if(this.c.length)var b=Ea(this.c,function(a,b){return a+z(b)},\"Arguments:\"),a=a+z(b);return a};function Vb(a,b,c,d,e,f,g,h,r){this.j=a;this.i=b;this.g=c;this.G=d;this.F=e;this.m=f;this.C=g;this.A=l(h)?h:g;this.H=!!r}Vb.prototype.toString=function(){return this.j};var Wb={};\nfunction T(a,b,c,d,e,f,g,h){if(Wb.hasOwnProperty(a))throw Error(\"Function already created: \"+a+\".\");Wb[a]=new Vb(a,b,c,d,!1,e,f,g,h)}T(\"boolean\",2,!1,!1,function(a,b){return Mb(b,a)},1);T(\"ceiling\",1,!1,!1,function(a,b){return Math.ceil(Q(b,a))},1);T(\"concat\",3,!1,!1,function(a,b){return Ea(Ja(arguments,1),function(b,d){return b+R(d,a)},\"\")},2,null);T(\"contains\",2,!1,!1,function(a,b,c){b=R(b,a);a=R(c,a);return-1!=b.indexOf(a)},2);T(\"count\",1,!1,!1,function(a,b){return b.a(a).l},1,1,!0);\nT(\"false\",2,!1,!1,function(){return!1},0);T(\"floor\",1,!1,!1,function(a,b){return Math.floor(Q(b,a))},1);T(\"id\",4,!1,!1,function(a,b){function c(a){if(D){var b=e.all[a];if(b){if(b.nodeType&&a==b.id)return b;if(b.length)return Ha(b,function(b){return a==b.id})}return null}return e.getElementById(a)}var d=a.a,e=9==d.nodeType?d:d.ownerDocument;a=R(b,a).split(/\\s+/);var f=[];A(a,function(a){a=c(a);!a||0<=Ca(f,a)||f.push(a)});f.sort(sb);var g=new I;A(f,function(a){J(g,a)});return g},1);\nT(\"lang\",2,!1,!1,function(){return!1},1);T(\"last\",1,!0,!1,function(a){if(1!=arguments.length)throw Error(\"Function last expects ()\");return a.f},0);T(\"local-name\",3,!1,!0,function(a,b){return(a=b?Hb(b.a(a)):a.a)?a.localName||a.nodeName.toLowerCase():\"\"},0,1,!0);T(\"name\",3,!1,!0,function(a,b){return(a=b?Hb(b.a(a)):a.a)?a.nodeName.toLowerCase():\"\"},0,1,!0);T(\"namespace-uri\",3,!0,!1,function(){return\"\"},0,1,!0);\nT(\"normalize-space\",3,!1,!0,function(a,b){return(b?R(b,a):G(a.a)).replace(/[\\s\\xa0]+/g,\" \").replace(/^\\s+|\\s+$/g,\"\")},0,1);T(\"not\",2,!1,!1,function(a,b){return!Mb(b,a)},1);T(\"number\",1,!1,!0,function(a,b){return b?Q(b,a):+G(a.a)},0,1);T(\"position\",1,!0,!1,function(a){return a.b},0);T(\"round\",1,!1,!1,function(a,b){return Math.round(Q(b,a))},1);T(\"starts-with\",2,!1,!1,function(a,b,c){b=R(b,a);a=R(c,a);return!b.lastIndexOf(a,0)},2);T(\"string\",3,!1,!0,function(a,b){return b?R(b,a):G(a.a)},0,1);\nT(\"string-length\",1,!1,!0,function(a,b){return(b?R(b,a):G(a.a)).length},0,1);T(\"substring\",3,!1,!1,function(a,b,c,d){c=Q(c,a);if(isNaN(c)||Infinity==c||-Infinity==c)return\"\";d=d?Q(d,a):Infinity;if(isNaN(d)||-Infinity===d)return\"\";c=Math.round(c)-1;var e=Math.max(c,0);a=R(b,a);return Infinity==d?a.substring(e):a.substring(e,c+Math.round(d))},2,3);T(\"substring-after\",3,!1,!1,function(a,b,c){b=R(b,a);a=R(c,a);c=b.indexOf(a);return-1==c?\"\":b.substring(c+a.length)},2);\nT(\"substring-before\",3,!1,!1,function(a,b,c){b=R(b,a);a=R(c,a);a=b.indexOf(a);return-1==a?\"\":b.substring(0,a)},2);T(\"sum\",1,!1,!1,function(a,b){a=L(b.a(a));b=0;for(var c=N(a);c;c=N(a))b+=+G(c);return b},1,1,!0);T(\"translate\",3,!1,!1,function(a,b,c,d){b=R(b,a);c=R(c,a);var e=R(d,a);d={};for(var f=0;f<c.length;f++)a=c.charAt(f),a in d||(d[a]=e.charAt(f));c=\"\";for(f=0;f<b.length;f++)a=b.charAt(f),c+=a in d?d[a]:a;return c},3);T(\"true\",2,!1,!1,function(){return!0},0);function Xb(a){O.call(this,3);this.c=a.substring(1,a.length-1)}p(Xb,O);Xb.prototype.a=function(){return this.c};Xb.prototype.toString=function(){return\"Literal: \"+this.c};function Yb(a){O.call(this,1);this.c=a}p(Yb,O);Yb.prototype.a=function(){return this.c};Yb.prototype.toString=function(){return\"Number: \"+this.c};function Zb(a,b){O.call(this,a.i);this.h=a;this.c=b;this.g=a.g;this.b=a.b;1==this.c.length&&(a=this.c[0],a.w||a.c!=$b||(a=a.o,\"*\"!=a.f()&&(this.f={name:a.f(),u:null})))}p(Zb,O);function ac(){O.call(this,4)}p(ac,O);ac.prototype.a=function(a){var b=new I;a=a.a;9==a.nodeType?J(b,a):J(b,a.ownerDocument);return b};ac.prototype.toString=function(){return\"Root Helper Expression\"};function bc(){O.call(this,4)}p(bc,O);bc.prototype.a=function(a){var b=new I;J(b,a.a);return b};bc.prototype.toString=function(){return\"Context Helper Expression\"};\nfunction cc(a){return\"/\"==a||\"//\"==a}Zb.prototype.a=function(a){var b=this.h.a(a);if(!(b instanceof I))throw Error(\"Filter expression must evaluate to nodeset.\");a=this.c;for(var c=0,d=a.length;c<d&&b.l;c++){var e=a[c],f=L(b,e.c.s);if(e.g||e.c!=dc)if(e.g||e.c!=ec){var g=N(f);for(b=e.a(new pa(g));g=N(f);)g=e.a(new pa(g)),b=Fb(b,g)}else g=N(f),b=e.a(new pa(g));else{for(g=N(f);(b=N(f))&&(!g.contains||g.contains(b))&&b.compareDocumentPosition(g)&8;g=b);b=e.a(new pa(g))}}return b};\nZb.prototype.toString=function(){var a=\"Path Expression:\"+z(this.h);if(this.c.length){var b=Ea(this.c,function(a,b){return a+z(b)},\"Steps:\");a+=z(b)}return a};function fc(a,b){this.a=a;this.s=!!b}\nfunction Tb(a,b,c){for(c=c||0;c<a.a.length;c++)for(var d=a.a[c],e=L(b),f=b.l,g,h=0;g=N(e);h++){var r=a.s?f-h:h+1;g=d.a(new pa(g,r,f));if(\"number\"==typeof g)r=r==g;else if(\"string\"==typeof g||\"boolean\"==typeof g)r=!!g;else if(g instanceof I)r=0<g.l;else throw Error(\"Predicate.evaluate returned an unexpected type.\");if(!r){r=e;g=r.f;var w=r.a;if(!w)throw Error(\"Next must be called at least once before remove.\");var n=w.b,w=w.a;n?n.a=w:g.a=w;w?w.b=n:g.b=n;g.l--;r.a=null}}return b}\nfc.prototype.toString=function(){return Ea(this.a,function(a,b){return a+z(b)},\"Predicates:\")};function gc(a){O.call(this,1);this.c=a;this.g=a.g;this.b=a.b}p(gc,O);gc.prototype.a=function(a){return-Q(this.c,a)};gc.prototype.toString=function(){return\"Unary Expression: -\"+z(this.c)};function hc(a){O.call(this,4);this.c=a;Kb(this,Fa(this.c,function(a){return a.g}));Lb(this,Fa(this.c,function(a){return a.b}))}p(hc,O);hc.prototype.a=function(a){var b=new I;A(this.c,function(c){c=c.a(a);if(!(c instanceof I))throw Error(\"Path expression must evaluate to NodeSet.\");b=Fb(b,c)});return b};hc.prototype.toString=function(){return Ea(this.c,function(a,b){return a+z(b)},\"Union Expression:\")};function U(a,b,c,d){O.call(this,4);this.c=a;this.o=b;this.h=c||new fc([]);this.w=!!d;b=this.h;b=0<b.a.length?b.a[0].f:null;a.J&&b&&(a=b.name,a=D?a.toLowerCase():a,this.f={name:a,u:b.u});a:{a=this.h;for(b=0;b<a.a.length;b++)if(c=a.a[b],c.g||1==c.i||0==c.i){a=!0;break a}a=!1}this.g=a}p(U,O);\nU.prototype.a=function(a){var b=a.a,c=this.f,d=null,e=null,f=0;c&&(d=c.name,e=c.u?R(c.u,a):null,f=1);if(this.w)if(this.g||this.c!=ic)if(b=L((new U(jc,new y(\"node\"))).a(a)),c=N(b))for(a=this.m(c,d,e,f);c=N(b);)a=Fb(a,this.m(c,d,e,f));else a=new I;else a=xb(this.o,b,d,e),a=Tb(this.h,a,f);else a=this.m(a.a,d,e,f);return a};U.prototype.m=function(a,b,c,d){a=this.c.v(this.o,a,b,c);return a=Tb(this.h,a,d)};\nU.prototype.toString=function(){var a=\"Step:\"+z(\"Operator: \"+(this.w?\"//\":\"/\"));this.c.j&&(a+=z(\"Axis: \"+this.c));a+=z(this.o);if(this.h.a.length){var b=Ea(this.h.a,function(a,b){return a+z(b)},\"Predicates:\");a+=z(b)}return a};function kc(a,b,c,d){this.j=a;this.v=b;this.s=c;this.J=d}kc.prototype.toString=function(){return this.j};var lc={};function V(a,b,c,d){if(lc.hasOwnProperty(a))throw Error(\"Axis already created: \"+a);b=new kc(a,b,c,!!d);return lc[a]=b}\nV(\"ancestor\",function(a,b){for(var c=new I;b=b.parentNode;)a.a(b)&&Gb(c,b);return c},!0);V(\"ancestor-or-self\",function(a,b){var c=new I;do a.a(b)&&Gb(c,b);while(b=b.parentNode);return c},!0);\nvar $b=V(\"attribute\",function(a,b){var c=new I,d=a.f();if(\"style\"==d&&D&&b.style)return J(c,new mb(b.style,b,\"style\",b.style.cssText)),c;var e=b.attributes;if(e)if(a instanceof y&&null===a.b||\"*\"==d)for(d=0;a=e[d];d++)D?a.nodeValue&&J(c,nb(b,a)):J(c,a);else(a=e.getNamedItem(d))&&(D?a.nodeValue&&J(c,nb(b,a)):J(c,a));return c},!1),ic=V(\"child\",function(a,b,c,d,e){return(D?Cb:Db).call(null,a,b,m(c)?c:null,m(d)?d:null,e||new I)},!1,!0);V(\"descendant\",xb,!1,!0);\nvar jc=V(\"descendant-or-self\",function(a,b,c,d){var e=new I;H(b,c,d)&&a.a(b)&&J(e,b);return xb(a,b,c,d,e)},!1,!0),dc=V(\"following\",function(a,b,c,d){var e=new I;do for(var f=b;f=f.nextSibling;)H(f,c,d)&&a.a(f)&&J(e,f),e=xb(a,f,c,d,e);while(b=b.parentNode);return e},!1,!0);V(\"following-sibling\",function(a,b){for(var c=new I;b=b.nextSibling;)a.a(b)&&J(c,b);return c},!1);V(\"namespace\",function(){return new I},!1);\nvar mc=V(\"parent\",function(a,b){var c=new I;if(9==b.nodeType)return c;if(2==b.nodeType)return J(c,b.ownerElement),c;b=b.parentNode;a.a(b)&&J(c,b);return c},!1),ec=V(\"preceding\",function(a,b,c,d){var e=new I,f=[];do f.unshift(b);while(b=b.parentNode);for(var g=1,h=f.length;g<h;g++){var r=[];for(b=f[g];b=b.previousSibling;)r.unshift(b);for(var w=0,n=r.length;w<n;w++)b=r[w],H(b,c,d)&&a.a(b)&&J(e,b),e=xb(a,b,c,d,e)}return e},!0,!0);\nV(\"preceding-sibling\",function(a,b){for(var c=new I;b=b.previousSibling;)a.a(b)&&Gb(c,b);return c},!0);var nc=V(\"self\",function(a,b){var c=new I;a.a(b)&&J(c,b);return c},!1);function oc(a,b){this.a=a;this.b=b}function pc(a){for(var b,c=[];;){W(a,\"Missing right hand side of binary expression.\");b=qc(a);var d=u(a.a);if(!d)break;var e=(d=Rb[d]||null)&&d.D;if(!e){a.a.a--;break}for(;c.length&&e<=c[c.length-1].D;)b=new Nb(c.pop(),c.pop(),b);c.push(b,d)}for(;c.length;)b=new Nb(c.pop(),c.pop(),b);return b}function W(a,b){if(ua(a.a))throw Error(b);}function rc(a,b){a=u(a.a);if(a!=b)throw Error(\"Bad token, expected: \"+b+\" got: \"+a);}\nfunction sc(a){a=u(a.a);if(\")\"!=a)throw Error(\"Bad token: \"+a);}function tc(a){a=u(a.a);if(2>a.length)throw Error(\"Unclosed literal string\");return new Xb(a)}\nfunction uc(a){var b=[];if(cc(t(a.a))){var c=u(a.a);var d=t(a.a);if(\"/\"==c&&(ua(a.a)||\".\"!=d&&\"..\"!=d&&\"@\"!=d&&\"*\"!=d&&!/(?![0-9])[\\w]/.test(d)))return new ac;d=new ac;W(a,\"Missing next location step.\");c=vc(a,c);b.push(c)}else{a:{c=t(a.a);d=c.charAt(0);switch(d){case \"$\":throw Error(\"Variable reference not allowed in HTML XPath\");case \"(\":u(a.a);c=pc(a);W(a,'unclosed \"(\"');rc(a,\")\");break;case '\"':case \"'\":c=tc(a);break;default:if(isNaN(+c))if(!xa(c)&&/(?![0-9])[\\w]/.test(d)&&\"(\"==t(a.a,1)){c=u(a.a);\nc=Wb[c]||null;u(a.a);for(d=[];\")\"!=t(a.a);){W(a,\"Missing function argument list.\");d.push(pc(a));if(\",\"!=t(a.a))break;u(a.a)}W(a,\"Unclosed function argument list.\");sc(a);c=new Ub(c,d)}else{c=null;break a}else c=new Yb(+u(a.a))}\"[\"==t(a.a)&&(d=new fc(wc(a)),c=new Sb(c,d))}if(c)if(cc(t(a.a)))d=c;else return c;else c=vc(a,\"/\"),d=new bc,b.push(c)}for(;cc(t(a.a));)c=u(a.a),W(a,\"Missing next location step.\"),c=vc(a,c),b.push(c);return new Zb(d,b)}\nfunction vc(a,b){if(\"/\"!=b&&\"//\"!=b)throw Error('Step op should be \"/\" or \"//\"');if(\".\"==t(a.a)){var c=new U(nc,new y(\"node\"));u(a.a);return c}if(\"..\"==t(a.a))return c=new U(mc,new y(\"node\")),u(a.a),c;if(\"@\"==t(a.a)){var d=$b;u(a.a);W(a,\"Missing attribute name\")}else if(\"::\"==t(a.a,1)){if(!/(?![0-9])[\\w]/.test(t(a.a).charAt(0)))throw Error(\"Bad token: \"+u(a.a));var e=u(a.a);d=lc[e]||null;if(!d)throw Error(\"No axis with name: \"+e);u(a.a);W(a,\"Missing node name\")}else d=ic;e=t(a.a);if(/(?![0-9])[\\w\\*]/.test(e.charAt(0)))if(\"(\"==\nt(a.a,1)){if(!xa(e))throw Error(\"Invalid node type: \"+e);e=u(a.a);if(!xa(e))throw Error(\"Invalid type name: \"+e);rc(a,\"(\");W(a,\"Bad nodetype\");var f=t(a.a).charAt(0),g=null;if('\"'==f||\"'\"==f)g=tc(a);W(a,\"Bad nodetype\");sc(a);e=new y(e,g)}else if(e=u(a.a),f=e.indexOf(\":\"),-1==f)e=new ya(e);else{var g=e.substring(0,f);if(\"*\"==g)var h=\"*\";else if(h=a.b(g),!h)throw Error(\"Namespace prefix not declared: \"+g);e=e.substr(f+1);e=new ya(e,h)}else throw Error(\"Bad token: \"+u(a.a));a=new fc(wc(a),d.s);return c||\nnew U(d,e,a,\"//\"==b)}function wc(a){for(var b=[];\"[\"==t(a.a);){u(a.a);W(a,\"Missing predicate expression.\");var c=pc(a);b.push(c);W(a,\"Unclosed predicate expression.\");rc(a,\"]\")}return b}function qc(a){if(\"-\"==t(a.a))return u(a.a),new gc(qc(a));var b=uc(a);if(\"|\"!=t(a.a))a=b;else{for(b=[b];\"|\"==u(a.a);)W(a,\"Missing next union location path.\"),b.push(uc(a));a.a.a--;a=new hc(b)}return a};function xc(a,b){if(!a.length)throw Error(\"Empty XPath expression.\");a=ra(a);if(ua(a))throw Error(\"Invalid XPath expression.\");b?\"function\"==ba(b)||(b=ea(b.lookupNamespaceURI,b)):b=function(){return null};var c=pc(new oc(a,b));if(!ua(a))throw Error(\"Bad token: \"+u(a));this.evaluate=function(a,b){a=c.a(new pa(a));return new X(a,b)}}\nfunction X(a,b){if(!b)if(a instanceof I)b=4;else if(\"string\"==typeof a)b=2;else if(\"number\"==typeof a)b=1;else if(\"boolean\"==typeof a)b=3;else throw Error(\"Unexpected evaluation result.\");if(2!=b&&1!=b&&3!=b&&!(a instanceof I))throw Error(\"value could not be converted to the specified type\");this.resultType=b;switch(b){case 2:this.stringValue=a instanceof I?Ib(a):\"\"+a;break;case 1:this.numberValue=a instanceof I?+Ib(a):+a;break;case 3:this.booleanValue=a instanceof I?0<a.l:!!a;break;case 4:case 5:case 6:case 7:var c=\nL(a);var d=[];for(var e=N(c);e;e=N(c))d.push(e instanceof mb?e.a:e);this.snapshotLength=a.l;this.invalidIteratorState=!1;break;case 8:case 9:a=Hb(a);this.singleNodeValue=a instanceof mb?a.a:a;break;default:throw Error(\"Unknown XPathResult type.\");}var f=0;this.iterateNext=function(){if(4!=b&&5!=b)throw Error(\"iterateNext called with wrong result type\");return f>=d.length?null:d[f++]};this.snapshotItem=function(a){if(6!=b&&7!=b)throw Error(\"snapshotItem called with wrong result type\");return a>=d.length||\n0>a?null:d[a]}}X.ANY_TYPE=0;X.NUMBER_TYPE=1;X.STRING_TYPE=2;X.BOOLEAN_TYPE=3;X.UNORDERED_NODE_ITERATOR_TYPE=4;X.ORDERED_NODE_ITERATOR_TYPE=5;X.UNORDERED_NODE_SNAPSHOT_TYPE=6;X.ORDERED_NODE_SNAPSHOT_TYPE=7;X.ANY_UNORDERED_NODE_TYPE=8;X.FIRST_ORDERED_NODE_TYPE=9;function yc(a){this.lookupNamespaceURI=za(a)}\nfunction zc(a,b){a=a||k;var c=a.Document&&a.Document.prototype||a.document;if(!c.evaluate||b)a.XPathResult=X,c.evaluate=function(a,b,c,g){return(new xc(a,c)).evaluate(b,g)},c.createExpression=function(a,b){return new xc(a,b)},c.createNSResolver=function(a){return new yc(a)}}aa(\"wgxpath.install\",zc);var Ac=function(){var a={M:\"http://www.w3.org/2000/svg\"};return function(b){return a[b]||null}}();\nfunction Bc(a,b){var c=F(a);if(!c.documentElement)return null;(C||hb)&&zc(c?c.parentWindow||c.defaultView:window);try{var d=c.createNSResolver?c.createNSResolver(c.documentElement):Ac;if(C&&!ab(7))return c.evaluate.call(c,b,a,d,9,null);if(!C||9<=Number(bb)){for(var e={},f=c.getElementsByTagName(\"*\"),g=0;g<f.length;++g){var h=f[g],r=h.namespaceURI;if(r&&!e[r]){var w=h.lookupPrefix(r);if(!w)var n=r.match(\".*/(\\\\w+)/?$\"),w=n?n[1]:\"xhtml\";e[r]=w}}var B={},M;for(M in e)B[e[M]]=M;d=function(a){return B[a]||\nnull}}try{return c.evaluate(b,a,d,9,null)}catch(P){if(\"TypeError\"===P.name)return d=c.createNSResolver?c.createNSResolver(c.documentElement):Ac,c.evaluate(b,a,d,9,null);throw P;}}catch(P){if(!Ua||\"NS_ERROR_ILLEGAL_VALUE\"!=P.name)throw new ga(32,\"Unable to locate an element with the xpath expression \"+b+\" because of the following error:\\n\"+P);}}\nfunction Cc(a,b){var c=function(){var c=Bc(b,a);return c?c.singleNodeValue||null:b.selectSingleNode?(c=F(b),c.setProperty&&c.setProperty(\"SelectionLanguage\",\"XPath\"),b.selectSingleNode(a)):null}();if(null!==c&&(!c||1!=c.nodeType))throw new ga(32,'The result of the xpath expression \"'+a+'\" is: '+c+\". It should be an element.\");return c};var Dc=\"function\"===typeof ShadowRoot;function Ec(a){for(a=a.parentNode;a&&1!=a.nodeType&&9!=a.nodeType&&11!=a.nodeType;)a=a.parentNode;return K(a)?a:null}\nfunction Y(a,b){b=oa(b);if(\"float\"==b||\"cssFloat\"==b||\"styleFloat\"==b)b=qb?\"styleFloat\":\"cssFloat\";a:{var c=b;var d=F(a);if(d.defaultView&&d.defaultView.getComputedStyle&&(d=d.defaultView.getComputedStyle(a,null))){c=d[c]||d.getPropertyValue(c)||\"\";break a}c=\"\"}a=c||Fc(a,b);if(null===a)a=null;else if(0<=Ca(La,b)){b:{var e=a.match(Oa);if(e&&(b=Number(e[1]),c=Number(e[2]),d=Number(e[3]),e=Number(e[4]),0<=b&&255>=b&&0<=c&&255>=c&&0<=d&&255>=d&&0<=e&&1>=e)){b=[b,c,d,e];break b}b=null}if(!b)b:{if(d=a.match(Pa))if(b=\nNumber(d[1]),c=Number(d[2]),d=Number(d[3]),0<=b&&255>=b&&0<=c&&255>=c&&0<=d&&255>=d){b=[b,c,d,1];break b}b=null}if(!b)b:{b=a.toLowerCase();c=ia[b.toLowerCase()];if(!c&&(c=\"#\"==b.charAt(0)?b:\"#\"+b,4==c.length&&(c=c.replace(Ma,\"#$1$1$2$2$3$3\")),!Na.test(c))){b=null;break b}b=[parseInt(c.substr(1,2),16),parseInt(c.substr(3,2),16),parseInt(c.substr(5,2),16),1]}a=b?\"rgba(\"+b.join(\", \")+\")\":a}return a}\nfunction Fc(a,b){var c=a.currentStyle||a.style,d=c[b];!l(d)&&\"function\"==ba(c.getPropertyValue)&&(d=c.getPropertyValue(b));return\"inherit\"!=d?l(d)?d:null:(a=Ec(a))?Fc(a,b):null}\nfunction Gc(a,b,c){function d(a){var b=Hc(a);return 0<b.height&&0<b.width?!0:K(a,\"PATH\")&&(0<b.height||0<b.width)?(a=Y(a,\"stroke-width\"),!!a&&0<parseInt(a,10)):\"hidden\"!=Y(a,\"overflow\")&&Fa(a.childNodes,function(a){return 3==a.nodeType||K(a)&&d(a)})}function e(a){return Ic(a)==Z&&Ga(a.childNodes,function(a){return!K(a)||e(a)||!d(a)})}if(!K(a))throw Error(\"Argument to isShown must be of type Element\");if(K(a,\"BODY\"))return!0;if(K(a,\"OPTION\")||K(a,\"OPTGROUP\"))return a=vb(a,function(a){return K(a,\"SELECT\")}),\n!!a&&Gc(a,!0,c);var f=Jc(a);if(f)return!!f.B&&0<f.rect.width&&0<f.rect.height&&Gc(f.B,b,c);if(K(a,\"INPUT\")&&\"hidden\"==a.type.toLowerCase()||K(a,\"NOSCRIPT\"))return!1;f=Y(a,\"visibility\");return\"collapse\"!=f&&\"hidden\"!=f&&c(a)&&(b||Kc(a))&&d(a)?!e(a):!1}var Z=\"hidden\";\nfunction Ic(a){function b(a){function b(a){return a==g?!0:!Y(a,\"display\").lastIndexOf(\"inline\",0)||\"absolute\"==c&&\"static\"==Y(a,\"position\")?!1:!0}var c=Y(a,\"position\");if(\"fixed\"==c)return w=!0,a==g?null:g;for(a=Ec(a);a&&!b(a);)a=Ec(a);return a}function c(a){var b=a;if(\"visible\"==r)if(a==g&&h)b=h;else if(a==h)return{x:\"visible\",y:\"visible\"};b={x:Y(b,\"overflow-x\"),y:Y(b,\"overflow-y\")};a==g&&(b.x=\"visible\"==b.x?\"auto\":b.x,b.y=\"visible\"==b.y?\"auto\":b.y);return b}function d(a){if(a==g){var b=(new wb(f)).a;\na=b.scrollingElement?b.scrollingElement:Va||\"CSS1Compat\"!=b.compatMode?b.body||b.documentElement:b.documentElement;b=b.parentWindow||b.defaultView;a=C&&ab(\"10\")&&b.pageYOffset!=a.scrollTop?new Ra(a.scrollLeft,a.scrollTop):new Ra(b.pageXOffset||a.scrollLeft,b.pageYOffset||a.scrollTop)}else a=new Ra(a.scrollLeft,a.scrollTop);return a}var e=Lc(a);var f=F(a),g=f.documentElement,h=f.body,r=Y(g,\"overflow\"),w;for(a=b(a);a;a=b(a)){var n=c(a);if(\"visible\"!=n.x||\"visible\"!=n.y){var B=Hc(a);if(!B.width||!B.height)return Z;\nvar M=e.a<B.a,P=e.b<B.b;if(M&&\"hidden\"==n.x||P&&\"hidden\"==n.y)return Z;if(M&&\"visible\"!=n.x||P&&\"visible\"!=n.y){M=d(a);P=e.b<B.b-M.y;if(e.a<B.a-M.x&&\"visible\"!=n.x||P&&\"visible\"!=n.x)return Z;e=Ic(a);return e==Z?Z:\"scroll\"}M=e.f>=B.a+B.width;B=e.c>=B.b+B.height;if(M&&\"hidden\"==n.x||B&&\"hidden\"==n.y)return Z;if(M&&\"visible\"!=n.x||B&&\"visible\"!=n.y){if(w&&(n=d(a),e.f>=g.scrollWidth-n.x||e.a>=g.scrollHeight-n.y))return Z;e=Ic(a);return e==Z?Z:\"scroll\"}}}return\"none\"}\nfunction Hc(a){var b=Jc(a);if(b)return b.rect;if(K(a,\"HTML\"))return a=F(a),a=((a?a.parentWindow||a.defaultView:window)||window).document,a=\"CSS1Compat\"==a.compatMode?a.documentElement:a.body,a=new ja(a.clientWidth,a.clientHeight),new E(0,0,a.width,a.height);try{var c=a.getBoundingClientRect()}catch(d){return new E(0,0,0,0)}b=new E(c.left,c.top,c.right-c.left,c.bottom-c.top);C&&a.ownerDocument.body&&(a=F(a),b.a-=a.documentElement.clientLeft+a.body.clientLeft,b.b-=a.documentElement.clientTop+a.body.clientTop);\nreturn b}function Jc(a){var b=K(a,\"MAP\");if(!b&&!K(a,\"AREA\"))return null;var c=b?a:K(a.parentNode,\"MAP\")?a.parentNode:null,d=null,e=null;c&&c.name&&(d=Cc('/descendant::*[@usemap = \"#'+c.name+'\"]',F(c)))&&(e=Hc(d),b||\"default\"==a.shape.toLowerCase()||(a=Mc(a),b=Math.min(Math.max(a.a,0),e.width),c=Math.min(Math.max(a.b,0),e.height),e=new E(b+e.a,c+e.b,Math.min(a.width,e.width-b),Math.min(a.height,e.height-c))));return{B:d,rect:e||new E(0,0,0,0)}}\nfunction Mc(a){var b=a.shape.toLowerCase();a=a.coords.split(\",\");if(\"rect\"==b&&4==a.length){var b=a[0],c=a[1];return new E(b,c,a[2]-b,a[3]-c)}if(\"circle\"==b&&3==a.length)return b=a[2],new E(a[0]-b,a[1]-b,2*b,2*b);if(\"poly\"==b&&2<a.length){for(var b=a[0],c=a[1],d=b,e=c,f=2;f+1<a.length;f+=2)b=Math.min(b,a[f]),d=Math.max(d,a[f]),c=Math.min(c,a[f+1]),e=Math.max(e,a[f+1]);return new E(b,c,d-b,e-c)}return new E(0,0,0,0)}function Lc(a){a=Hc(a);return new db(a.b,a.a+a.width,a.b+a.height,a.a)}\nfunction Kc(a){if(qb){if(\"relative\"==Y(a,\"position\"))return 1;a=Y(a,\"filter\");return(a=a.match(/^alpha\\(opacity=(\\d*)\\)/)||a.match(/^progid:DXImageTransform.Microsoft.Alpha\\(Opacity=(\\d*)\\)/))?Number(a[1])/100:1}return Nc(a)}function Nc(a){var b=1,c=Y(a,\"opacity\");c&&(b=Number(c));(a=Ec(a))&&(b*=Nc(a));return b};aa(\"_\",function(a,b){var c=Dc?function(b){if(\"none\"==Y(b,\"display\"))return!1;do{var d=b.parentNode;if(b.getDestinationInsertionPoints){var f=b.getDestinationInsertionPoints();0<f.length&&(d=f[f.length-1])}if(d instanceof ShadowRoot){if(d.host.shadowRoot!=d)return!1;d=d.host}else!d||9!=d.nodeType&&11!=d.nodeType||(d=null)}while(a&&1!=a.nodeType);return!d||c(d)}:function(a){if(\"none\"==Y(a,\"display\"))return!1;a=Ec(a);return!a||c(a)};return Gc(a,!!b,c)});; return this._.apply(null,arguments);}.apply({navigator:typeof window!='undefined'?window.navigator:null,document:typeof window!='undefined'?window.document:null}, arguments);};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/atoms/is-displayed.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/by.js":
/*!****************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/by.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\n/**\n * @fileoverview Factory methods for the supported locator strategies.\n */\n\n/**\n * Short-hand expressions for the primary element locator strategies.\n * For example the following two statements are equivalent:\n *\n *     var e1 = driver.findElement(By.id('foo'));\n *     var e2 = driver.findElement({id: 'foo'});\n *\n * Care should be taken when using JavaScript minifiers (such as the\n * Closure compiler), as locator hashes will always be parsed using\n * the un-obfuscated properties listed.\n *\n * @typedef {(\n *     {className: string}|\n *     {css: string}|\n *     {id: string}|\n *     {js: string}|\n *     {linkText: string}|\n *     {name: string}|\n *     {partialLinkText: string}|\n *     {tagName: string}|\n *     {xpath: string})}\n */\nvar ByHash;\n\n\n/**\n * Error thrown if an invalid character is encountered while escaping a CSS\n * identifier.\n * @see https://drafts.csswg.org/cssom/#serialize-an-identifier\n */\nclass InvalidCharacterError extends Error {\n  constructor() {\n    super();\n    this.name = this.constructor.name;\n  }\n}\n\n\n/**\n * Escapes a CSS string.\n * @param {string} css the string to escape.\n * @return {string} the escaped string.\n * @throws {TypeError} if the input value is not a string.\n * @throws {InvalidCharacterError} if the string contains an invalid character.\n * @see https://drafts.csswg.org/cssom/#serialize-an-identifier\n */\nfunction escapeCss(css) {\n  if (typeof css !== 'string') {\n    throw new TypeError('input must be a string');\n  }\n  let ret = '';\n  const n = css.length;\n  for (let i = 0; i  < n; i++) {\n    const c = css.charCodeAt(i);\n    if (c == 0x0) {\n      throw new InvalidCharacterError();\n    }\n\n    if ((c >= 0x0001 && c <= 0x001F)\n        || c == 0x007F\n        || (i == 0 && c >= 0x0030 && c <= 0x0039)\n        || (i == 1 && c >= 0x0030 && c <= 0x0039\n            && css.charCodeAt(0) == 0x002D)) {\n      ret += '\\\\' + c.toString(16) + ' ';\n      continue;\n    }\n\n    if (i == 0 && c == 0x002D && n == 1) {\n      ret += '\\\\' + css.charAt(i);\n      continue;\n    }\n\n    if (c >= 0x0080\n        || c == 0x002D                      // -\n        || c == 0x005F                      // _\n        || (c >= 0x0030 && c <= 0x0039)     // [0-9]\n        || (c >= 0x0041 && c <= 0x005A)     // [A-Z]\n        || (c >= 0x0061 && c <= 0x007A)) {  // [a-z]\n      ret += css.charAt(i);\n      continue;\n    }\n\n    ret += '\\\\' + css.charAt(i);\n  }\n  return ret;\n}\n\n\n/**\n * Describes a mechanism for locating an element on the page.\n * @final\n */\nclass By {\n  /**\n   * @param {string} using the name of the location strategy to use.\n   * @param {string} value the value to search for.\n   */\n  constructor(using, value) {\n    /** @type {string} */\n    this.using = using;\n\n    /** @type {string} */\n    this.value = value;\n  }\n\n  /**\n   * Locates elements that have a specific class name.\n   *\n   * @param {string} name The class name to search for.\n   * @return {!By} The new locator.\n   * @see http://www.w3.org/TR/2011/WD-html5-20110525/elements.html#classes\n   * @see http://www.w3.org/TR/CSS2/selector.html#class-html\n   */\n  static className(name) {\n    let names = name.split(/\\s+/g)\n        .filter(s => s.length > 0)\n        .map(s => escapeCss(s));\n    return By.css('.' + names.join('.'));\n  }\n\n  /**\n   * Locates elements using a CSS selector.\n   *\n   * @param {string} selector The CSS selector to use.\n   * @return {!By} The new locator.\n   * @see http://www.w3.org/TR/CSS2/selector.html\n   */\n  static css(selector) {\n    return new By('css selector', selector);\n  }\n\n  /**\n   * Locates elements by the ID attribute. This locator uses the CSS selector\n   * `*[id=\"$ID\"]`, _not_ `document.getElementById`.\n   *\n   * @param {string} id The ID to search for.\n   * @return {!By} The new locator.\n   */\n  static id(id) {\n    return By.css('*[id=\"' + escapeCss(id) + '\"]');\n  }\n\n  /**\n   * Locates link elements whose\n   * {@linkplain webdriver.WebElement#getText visible text} matches the given\n   * string.\n   *\n   * @param {string} text The link text to search for.\n   * @return {!By} The new locator.\n   */\n  static linkText(text) {\n    return new By('link text', text);\n  }\n\n  /**\n   * Locates an elements by evaluating a\n   * {@linkplain webdriver.WebDriver#executeScript JavaScript expression}.\n   * The result of this expression must be an element or list of elements.\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} var_args The arguments to pass to the script.\n   * @return {function(!./webdriver.WebDriver): !Promise}\n   *     A new JavaScript-based locator function.\n   */\n  static js(script, var_args) {\n    let args = Array.prototype.slice.call(arguments, 0);\n    return function(driver) {\n      return driver.executeScript.apply(driver, args);\n    };\n  }\n\n  /**\n   * Locates elements whose `name` attribute has the given value.\n   *\n   * @param {string} name The name attribute to search for.\n   * @return {!By} The new locator.\n   */\n  static name(name) {\n    return By.css('*[name=\"' + escapeCss(name) + '\"]');\n  }\n\n  /**\n   * Locates link elements whose\n   * {@linkplain webdriver.WebElement#getText visible text} contains the given\n   * substring.\n   *\n   * @param {string} text The substring to check for in a link's visible text.\n   * @return {!By} The new locator.\n   */\n  static partialLinkText(text) {\n    return new By('partial link text', text);\n  }\n\n  /**\n   * Locates elements with a given tag name.\n   *\n   * @param {string} name The tag name to search for.\n   * @return {!By} The new locator.\n   * @deprecated Use {@link By.css() By.css(tagName)} instead.\n   */\n  static tagName(name) {\n    return By.css(name);\n  }\n\n  /**\n   * Locates elements matching a XPath selector. Care should be taken when\n   * using an XPath selector with a {@link webdriver.WebElement} as WebDriver\n   * will respect the context in the specified in the selector. For example,\n   * given the selector `//div`, WebDriver will search from the document root\n   * regardless of whether the locator was used with a WebElement.\n   *\n   * @param {string} xpath The XPath selector to use.\n   * @return {!By} The new locator.\n   * @see http://www.w3.org/TR/xpath/\n   */\n  static xpath(xpath) {\n    return new By('xpath', xpath);\n  }\n\n  /** @override */\n  toString() {\n    // The static By.name() overrides this.constructor.name.  Shame...\n    return `By(${this.using}, ${this.value})`;\n  }\n}\n\n\n/**\n * Checks if a value is a valid locator.\n * @param {!(By|Function|ByHash)} locator The value to check.\n * @return {!(By|Function)} The valid locator.\n * @throws {TypeError} If the given value does not define a valid locator\n *     strategy.\n */\nfunction check(locator) {\n  if (locator instanceof By || typeof locator === 'function') {\n    return locator;\n  }\n\n  if (locator\n      && typeof locator === 'object'\n      && typeof locator.using === 'string'\n      && typeof locator.value === 'string') {\n    return new By(locator.using, locator.value);\n  }\n\n  for (let key in locator) {\n    if (locator.hasOwnProperty(key) && By.hasOwnProperty(key)) {\n      return By[key](locator[key]);\n    }\n  }\n  throw new TypeError('Invalid locator');\n}\n\n\n\n// PUBLIC API\n\nmodule.exports = {\n  By: By,\n  checkedLocator: check,\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/by.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/capabilities.js":
/*!**************************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/capabilities.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\n/**\n * @fileoverview Defines types related to describing the capabilities of a\n * WebDriver session.\n */\n\nconst proxy = __webpack_require__(/*! ./proxy */ \"../node_modules/selenium-webdriver/lib/proxy.js\");\nconst Symbols = __webpack_require__(/*! ./symbols */ \"../node_modules/selenium-webdriver/lib/symbols.js\");\n\n\n/**\n * Recognized browser names.\n * @enum {string}\n */\nconst Browser = {\n  CHROME: 'chrome',\n  EDGE: 'MicrosoftEdge',\n  FIREFOX: 'firefox',\n  IE: 'internet explorer',\n  INTERNET_EXPLORER: 'internet explorer',\n  SAFARI: 'safari',\n};\n\n\n/**\n * Strategies for waiting for [document readiness] after a navigation\n * event.\n *\n * [document readiness]: https://html.spec.whatwg.org/#current-document-readiness\n *\n * @enum {string}\n */\nconst PageLoadStrategy = {\n  /**\n   * Indicates WebDriver should not wait on the document readiness state after a\n   * navigation event.\n   */\n  NONE: 'none',\n\n  /**\n   * Indicates WebDriver should wait for the document readiness state to\n   * become \"interactive\" after navigation.\n   */\n  EAGER: 'eager',\n\n  /**\n   * Indicates WebDriver should wait for the document readiness state to\n   * be \"complete\" after navigation. This is the default page loading strategy.\n   */\n  NORMAL: 'normal'\n};\n\n\n/**\n * Common platform names. These platforms are not explicitly defined by the\n * WebDriver spec, however, their use is encouraged for interoperability.\n *\n * @enum {string}\n * @see <https://w3c.github.io/webdriver/webdriver-spec.html>\n */\nconst Platform = {\n  LINUX: 'linux',\n  MAC: 'mac',\n  WINDOWS: 'windows'\n};\n\n\n/**\n * Record object defining the timeouts that apply to certain WebDriver actions.\n *\n * @record\n */\nfunction Timeouts() {}\n\n/**\n * Defines when, in milliseconds, to interupt a script that is being\n * {@linkplain ./webdriver.IWebDriver#executeScript evaluated}.\n * @type {number}\n */\nTimeouts.prototype.script;\n\n/**\n * The timeout, in milliseconds, to apply to navigation events along with the\n * {@link PageLoadStrategy}.\n * @type {number}\n */\nTimeouts.prototype.pageLoad;\n\n/**\n * The maximimum amount of time, in milliseconds, to spend attempting to\n * {@linkplain ./webdriver.IWebDriver#findElement locate} an element on the\n * current page.\n * @type {number}\n */\nTimeouts.prototype.implicit;\n\n\n/**\n * The possible default actions a WebDriver session can take to respond to\n * unhandled user prompts (`window.alert()`, `window.confirm()`, and\n * `window.prompt()`).\n *\n * @enum {string}\n */\nconst UserPromptHandler = {\n  /** All prompts should be silently accepted. */\n  ACCEPT: 'accept',\n  /** All prompts should be silently dismissed. */\n  DISMISS: 'dismiss',\n  /**\n   * All prompts should be automatically accepted, but an error should be\n   * returned to the next (or currently executing) WebDriver command.\n   */\n  ACCEPT_AND_NOTIFY: 'accept and notify',\n  /**\n   * All prompts should be automatically dismissed, but an error should be\n   * returned to the next (or currently executing) WebDriver command.\n   */\n  DISMISS_AND_NOTIFY: 'dismiss and notify',\n  /** All prompts should be left unhandled. */\n  IGNORE: 'ignore'\n};\n\n\n/**\n * The standard WebDriver capability keys.\n *\n * @enum {string}\n * @see <https://w3c.github.io/webdriver/webdriver-spec.html#capabilities>\n */\nconst Capability = {\n\n  /**\n   * Indicates whether a WebDriver session implicity trusts otherwise untrusted\n   * and self-signed TLS certificates during navigation.\n   */\n  ACCEPT_INSECURE_TLS_CERTS: 'acceptInsecureCerts',\n\n  /**\n   * The browser name. Common browser names are defined in the\n   * {@link ./capabilities.Browser Browser} enum.\n   */\n  BROWSER_NAME: 'browserName',\n\n  /** Identifies the browser version. */\n  BROWSER_VERSION: 'browserVersion',\n\n  /**\n   * Key for the logging driver logging preferences.\n   * The browser name. Common browser names are defined in the\n   * {@link ./capabilities.Browser Browser} enum.\n   */\n  LOGGING_PREFS: 'loggingPrefs',\n\n  /**\n   * Defines the session's\n   * {@linkplain ./capabilities.PageLoadStrategy page loading strategy}.\n   */\n  PAGE_LOAD_STRATEGY: 'pageLoadStrategy',\n\n  /**\n   * Identifies the operating system of the endpoint node. Common values\n   * recognized by the most WebDriver server implementations are predefined in\n   * the {@link ./capabilities.Platform Platform} enum.\n   */\n  PLATFORM_NAME: 'platformName',\n\n  /**\n   * Describes the proxy configuration to use for a new WebDriver session.\n   */\n  PROXY: 'proxy',\n\n  /**\n   * Indicates whether the remote end supports all of the window resizing and\n   * positioning commands:\n   *\n   * -  {@linkplain ./webdriver.Window#getRect Window.getRect()}\n   * -  {@linkplain ./webdriver.Window#setRect Window.setRect()}\n   * -  {@linkplain ./webdriver.Window#maximize Window.maximize()}\n   * -  {@linkplain ./webdriver.Window#minimize Window.minimize()}\n   * -  {@linkplain ./webdriver.Window#fullscreen Window.fullscreen()}\n   */\n  SET_WINDOW_RECT: 'setWindowRect',\n\n  /**\n   * Describes the {@linkplain ./capabilities.Timeouts timeouts} imposed on\n   * certain session operations.\n   */\n  TIMEOUTS: 'timeouts',\n\n  /**\n   * Defines how a WebDriver session should\n   * {@linkplain ./capabilities.UserPromptHandler respond} to unhandled user\n   * prompts.\n   */\n  UNHANDLED_PROMPT_BEHAVIOR: 'unhandledPromptBehavior',\n};\n\n\n/**\n * Converts a generic hash object to a map.\n * @param {!Object<string, ?>} hash The hash object.\n * @return {!Map<string, ?>} The converted map.\n */\nfunction toMap(hash) {\n  let m = new Map;\n  for (let key in hash) {\n    if (hash.hasOwnProperty(key)) {\n      m.set(key, hash[key]);\n    }\n  }\n  return m;\n}\n\n\n/**\n * Describes a set of capabilities for a WebDriver session.\n */\nclass Capabilities {\n  /**\n   * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of\n   *     capabilities to initialize this instance from.\n   */\n  constructor(other = undefined) {\n    if (other instanceof Capabilities) {\n      other = other.map_;\n    } else if (other && !(other instanceof Map)) {\n      other = toMap(other);\n    }\n    /** @private @const {!Map<string, ?>} */\n    this.map_ = new Map(other);\n  }\n\n  /**\n   * @return {!Capabilities} A basic set of capabilities for Chrome.\n   */\n  static chrome() {\n    return new Capabilities().setBrowserName(Browser.CHROME);\n  }\n\n  /**\n   * @return {!Capabilities} A basic set of capabilities for Microsoft Edge.\n   */\n  static edge() {\n    return new Capabilities().setBrowserName(Browser.EDGE);\n  }\n\n  /**\n   * @return {!Capabilities} A basic set of capabilities for Firefox.\n   */\n  static firefox() {\n    return new Capabilities().setBrowserName(Browser.FIREFOX);\n  }\n\n  /**\n   * @return {!Capabilities} A basic set of capabilities for Internet Explorer.\n   */\n  static ie() {\n    return new Capabilities().setBrowserName(Browser.INTERNET_EXPLORER);\n  }\n\n  /**\n   * @return {!Capabilities} A basic set of capabilities for Safari.\n   */\n  static safari() {\n    return new Capabilities().setBrowserName(Browser.SAFARI);\n  }\n\n  /**\n   * @return {!Object<string, ?>} The JSON representation of this instance.\n   *     Note, the returned object may contain nested promised values.\n   * @suppress {checkTypes} Suppress [] access on a struct (state inherited from\n   *     Map).\n   */\n  [Symbols.serialize]() {\n    return serialize(this);\n  }\n\n  /**\n   * @param {string} key the parameter key to get.\n   * @return {T} the stored parameter value.\n   * @template T\n   */\n  get(key) {\n    return this.map_.get(key);\n  }\n\n  /**\n   * @param {string} key the key to test.\n   * @return {boolean} whether this capability set has the specified key.\n   */\n  has(key) {\n    return this.map_.has(key);\n  }\n\n  /**\n   * @return {!Iterator<string>} an iterator of the keys set.\n   */\n  keys() {\n    return this.map_.keys();\n  }\n\n  /** @return {number} The number of capabilities set. */\n  get size() {\n    return this.map_.size;\n  }\n\n  /**\n   * Merges another set of capabilities into this instance.\n   * @param {!(Capabilities|Map<String, ?>|Object<string, ?>)} other The other\n   *     set of capabilities to merge.\n   * @return {!Capabilities} A self reference.\n   */\n  merge(other) {\n    if (!other) {\n      throw new TypeError('no capabilities provided for merge');\n    }\n\n    let map;\n    if (other instanceof Capabilities) {\n      map = other.map_;\n    } else if (other instanceof Map) {\n      map = other;\n    } else {\n      other = toMap(other);\n    }\n\n    for (let key of other.keys()) {\n      this.set(key, other.get(key));\n    }\n\n    return this;\n  }\n\n  /**\n   * Deletes an entry from this set of capabilities.\n   *\n   * @param {string} key the capability key to delete.\n   */\n  delete(key) {\n    this.map_.delete(key);\n  }\n\n  /**\n   * @param {string} key The capability key.\n   * @param {*} value The capability value.\n   * @return {!Capabilities} A self reference.\n   * @throws {TypeError} If the `key` is not a string.\n   */\n  set(key, value) {\n    if (typeof key !== 'string') {\n      throw new TypeError('Capability keys must be strings: ' + typeof key);\n    }\n    this.map_.set(key, value);\n    return this;\n  }\n\n  /**\n   * Sets whether a WebDriver session should implicitly accept self-signed, or\n   * other untrusted TLS certificates on navigation.\n   *\n   * @param {boolean} accept whether to accept insecure certs.\n   * @return {!Capabilities} a self reference.\n   */\n  setAcceptInsecureCerts(accept) {\n    return this.set(Capability.ACCEPT_INSECURE_TLS_CERTS, accept);\n  }\n\n  /**\n   * @return {boolean} whether the session is configured to accept insecure\n   *     TLS certificates.\n   */\n  getAcceptInsecureCerts() {\n    return this.get(Capability.ACCEPT_INSECURE_TLS_CERTS);\n  }\n\n  /**\n   * Sets the name of the target browser.\n   *\n   * @param {(Browser|string)} name the browser name.\n   * @return {!Capabilities} a self reference.\n   */\n  setBrowserName(name) {\n    return this.set(Capability.BROWSER_NAME, name);\n  }\n\n  /**\n   * @return {(string|undefined)} the configured browser name, or undefined if\n   *     not set.\n   */\n  getBrowserName() {\n    return this.get(Capability.BROWSER_NAME);\n  }\n\n  /**\n   * Sets the desired version of the target browser.\n   *\n   * @param {string} version the desired version.\n   * @return {!Capabilities} a self reference.\n   */\n  setBrowserVersion(version) {\n    return this.set(Capability.BROWSER_VERSION, version);\n  }\n\n  /**\n   * @return {(string|undefined)} the configured browser version, or undefined\n   *     if not set.\n   */\n  getBrowserVersion() {\n    return this.get(Capability.BROWSER_VERSION);\n  }\n\n  /**\n   * Sets the desired page loading strategy for a new WebDriver session.\n   *\n   * @param {PageLoadStrategy} strategy the desired strategy.\n   * @return {!Capabilities} a self reference.\n   */\n  setPageLoadStrategy(strategy) {\n    return this.set(Capability.PAGE_LOAD_STRATEGY, strategy);\n  }\n\n  /**\n   * Returns the configured page load strategy.\n   *\n   * @return {(string|undefined)} the page load strategy.\n   */\n  getPageLoadStrategy() {\n    return this.get(Capability.PAGE_LOAD_STRATEGY);\n  }\n\n  /**\n   * Sets the target platform.\n   *\n   * @param {(Platform|string)} platform the target platform.\n   * @return {!Capabilities} a self reference.\n   */\n  setPlatform(platform) {\n    return this.set(Capability.PLATFORM_NAME, platform);\n  }\n\n  /**\n   * @return {(string|undefined)} the configured platform or undefined if not\n   *     set.\n   */\n  getPlatform() {\n    return this.get(Capability.PLATFORM_NAME);\n  }\n\n  /**\n   * Sets the logging preferences. Preferences may be specified as a\n   * {@link ./logging.Preferences} instance, or as a map of log-type to\n   * log-level.\n   * @param {!(./logging.Preferences|Object<string>)} prefs The logging\n   *     preferences.\n   * @return {!Capabilities} A self reference.\n   */\n  setLoggingPrefs(prefs) {\n    return this.set(Capability.LOGGING_PREFS, prefs);\n  }\n\n  /**\n   * Sets the proxy configuration for this instance.\n   * @param {proxy.Config} proxy The desired proxy configuration.\n   * @return {!Capabilities} A self reference.\n   */\n  setProxy(proxy) {\n    return this.set(Capability.PROXY, proxy);\n  }\n\n  /**\n   * @return {(proxy.Config|undefined)} the configured proxy settings, or\n   *     undefined if not set.\n   */\n  getProxy() {\n    return this.get(Capability.PROXY);\n  }\n\n  /**\n   * Sets the default action to take with an unexpected alert before returning\n   * an error. If unspecified, WebDriver will default to\n   * {@link UserPromptHandler.DISMISS_AND_NOTIFY}.\n   *\n   * @param {?UserPromptHandler} behavior The way WebDriver should respond to\n   *     unhandled user prompts.\n   * @return {!Capabilities} A self reference.\n   */\n  setAlertBehavior(behavior) {\n    return this.set(Capability.UNHANDLED_PROMPT_BEHAVIOR, behavior);\n  }\n\n  /**\n   * @return {(UserPromptHandler|undefined)} the behavior pattern for responding\n   *     to unhandled user prompts, or undefined if not set.\n   */\n  getAlertBehavior() {\n    return this.get(Capability.UNHANDLED_PROMPT_BEHAVIOR);\n  }\n}\n\n\n/**\n * Serializes a capabilities object. This is defined as a standalone function\n * so it may be type checked (where Capabilities[Symbols.serialize] has type\n * checking disabled since it is defined with [] access on a struct).\n *\n * @param {!Capabilities} caps The capabilities to serialize.\n * @return {!Object<string, ?>} The JSON representation of this instance.\n *     Note, the returned object may contain nested promised values.\n */\nfunction serialize(caps) {\n  let ret = {};\n  for (let key of caps.keys()) {\n    let cap = caps.get(key);\n    if (cap !== undefined && cap !== null) {\n      ret[key] = cap;\n    }\n  }\n  return ret;\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  Browser,\n  Capabilities,\n  Capability,\n  PageLoadStrategy,\n  Platform,\n  Timeouts,\n  UserPromptHandler,\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/capabilities.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/command.js":
/*!*********************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/command.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Contains several classes for handling commands.\n */\n\n\n\n/**\n * Describes a command to execute.\n * @final\n */\nclass Command {\n  /** @param {string} name The name of this command. */\n  constructor(name) {\n    /** @private {string} */\n    this.name_ = name;\n\n    /** @private {!Object<*>} */\n    this.parameters_ = {};\n  }\n\n  /** @return {string} This command's name. */\n  getName() {\n    return this.name_;\n  }\n\n  /**\n   * Sets a parameter to send with this command.\n   * @param {string} name The parameter name.\n   * @param {*} value The parameter value.\n   * @return {!Command} A self reference.\n   */\n  setParameter(name, value) {\n    this.parameters_[name] = value;\n    return this;\n  }\n\n  /**\n   * Sets the parameters for this command.\n   * @param {!Object<*>} parameters The command parameters.\n   * @return {!Command} A self reference.\n   */\n  setParameters(parameters) {\n    this.parameters_ = parameters;\n    return this;\n  }\n\n  /**\n   * Returns a named command parameter.\n   * @param {string} key The parameter key to look up.\n   * @return {*} The parameter value, or undefined if it has not been set.\n   */\n  getParameter(key) {\n    return this.parameters_[key];\n  }\n\n  /**\n   * @return {!Object<*>} The parameters to send with this command.\n   */\n  getParameters() {\n    return this.parameters_;\n  }\n}\n\n\n/**\n * Enumeration of predefined names command names that all command processors\n * will support.\n * @enum {string}\n */\n// TODO: Delete obsolete command names.\nconst Name = {\n  GET_SERVER_STATUS: 'getStatus',\n\n  NEW_SESSION: 'newSession',\n  GET_SESSIONS: 'getSessions',\n\n  CLOSE: 'close',\n  QUIT: 'quit',\n\n  GET_CURRENT_URL: 'getCurrentUrl',\n  GET: 'get',\n  GO_BACK: 'goBack',\n  GO_FORWARD: 'goForward',\n  REFRESH: 'refresh',\n\n  ADD_COOKIE: 'addCookie',\n  GET_COOKIE: 'getCookie',\n  GET_ALL_COOKIES: 'getCookies',\n  DELETE_COOKIE: 'deleteCookie',\n  DELETE_ALL_COOKIES: 'deleteAllCookies',\n\n  GET_ACTIVE_ELEMENT: 'getActiveElement',\n  FIND_ELEMENT: 'findElement',\n  FIND_ELEMENTS: 'findElements',\n  FIND_CHILD_ELEMENT: 'findChildElement',\n  FIND_CHILD_ELEMENTS: 'findChildElements',\n\n  CLEAR_ELEMENT: 'clearElement',\n  CLICK_ELEMENT: 'clickElement',\n  SEND_KEYS_TO_ELEMENT: 'sendKeysToElement',\n  SUBMIT_ELEMENT: 'submitElement',\n\n  GET_CURRENT_WINDOW_HANDLE: 'getCurrentWindowHandle',\n  GET_WINDOW_HANDLES: 'getWindowHandles',\n  GET_WINDOW_POSITION: 'getWindowPosition',\n  SET_WINDOW_POSITION: 'setWindowPosition',\n  GET_WINDOW_SIZE: 'getWindowSize',\n  SET_WINDOW_SIZE: 'setWindowSize',\n  GET_WINDOW_RECT: 'getWindowRect',\n  SET_WINDOW_RECT: 'setWindowRect',\n  MAXIMIZE_WINDOW: 'maximizeWindow',\n  MINIMIZE_WINDOW: 'minimizeWindow',\n  FULLSCREEN_WINDOW: 'fullscreenWindow',\n\n  SWITCH_TO_WINDOW: 'switchToWindow',\n  SWITCH_TO_FRAME: 'switchToFrame',\n  SWITCH_TO_FRAME_PARENT: 'switchToFrameParent',\n  GET_PAGE_SOURCE: 'getPageSource',\n  GET_TITLE: 'getTitle',\n\n  EXECUTE_SCRIPT: 'executeScript',\n  EXECUTE_ASYNC_SCRIPT: 'executeAsyncScript',\n\n  GET_ELEMENT_TEXT: 'getElementText',\n  GET_ELEMENT_TAG_NAME: 'getElementTagName',\n  IS_ELEMENT_SELECTED: 'isElementSelected',\n  IS_ELEMENT_ENABLED: 'isElementEnabled',\n  IS_ELEMENT_DISPLAYED: 'isElementDisplayed',\n  GET_ELEMENT_LOCATION: 'getElementLocation',\n  GET_ELEMENT_LOCATION_IN_VIEW: 'getElementLocationOnceScrolledIntoView',\n  GET_ELEMENT_RECT: 'getElementRect',\n  GET_ELEMENT_SIZE: 'getElementSize',\n  GET_ELEMENT_ATTRIBUTE: 'getElementAttribute',\n  GET_ELEMENT_VALUE_OF_CSS_PROPERTY: 'getElementValueOfCssProperty',\n\n  SCREENSHOT: 'screenshot',\n  TAKE_ELEMENT_SCREENSHOT: 'takeElementScreenshot',\n  IMPLICITLY_WAIT: 'implicitlyWait',\n  SET_SCRIPT_TIMEOUT: 'setScriptTimeout',\n\n  GET_TIMEOUT: 'getTimeout',\n  SET_TIMEOUT: 'setTimeout',\n\n  ACCEPT_ALERT: 'acceptAlert',\n  DISMISS_ALERT: 'dismissAlert',\n  GET_ALERT_TEXT: 'getAlertText',\n  SET_ALERT_TEXT: 'setAlertValue',\n\n  GET_AVAILABLE_LOG_TYPES: 'getAvailableLogTypes',\n  GET_LOG: 'getLog',\n  GET_SESSION_LOGS: 'getSessionLogs',\n\n  // Non-standard commands used by the standalone Selenium server.\n  UPLOAD_FILE: 'uploadFile',\n\n  ACTIONS: 'actions',\n  CLEAR_ACTIONS: 'clearActions',\n\n  LEGACY_ACTION_CLICK: 'legacyAction:click',\n  LEGACY_ACTION_DOUBLE_CLICK: 'legacyAction:doubleclick',\n  LEGACY_ACTION_MOUSE_DOWN: 'legacyAction:mouseDown',\n  LEGACY_ACTION_MOUSE_UP: 'legacyAction:mouseUp',\n  LEGACY_ACTION_MOUSE_MOVE: 'legacyAction:mouseMove',\n  LEGACY_ACTION_SEND_KEYS: 'legacyAction:sendKeys',\n  LEGACY_ACTION_TOUCH_DOWN: 'legacyAction:touchDown',\n  LEGACY_ACTION_TOUCH_UP: 'legacyAction:touchUp',\n  LEGACY_ACTION_TOUCH_MOVE: 'legacyAction:touchMove',\n  LEGACY_ACTION_TOUCH_SCROLL: 'legacyAction:touchScroll',\n  LEGACY_ACTION_TOUCH_LONG_PRESS: 'legacyAction:touchLongPress',\n  LEGACY_ACTION_TOUCH_FLICK: 'legacyAction:touchFlick',\n  LEGACY_ACTION_TOUCH_SINGLE_TAP: 'legacyAction:singleTap',\n  LEGACY_ACTION_TOUCH_DOUBLE_TAP: 'legacyAction:doubleTap',\n};\n\n\n\n/**\n * Handles the execution of WebDriver {@link Command commands}.\n * @record\n */\nclass Executor {\n  /**\n   * Executes the given {@code command}. If there is an error executing the\n   * command, the provided callback will be invoked with the offending error.\n   * Otherwise, the callback will be invoked with a null Error and non-null\n   * response object.\n   *\n   * @param {!Command} command The command to execute.\n   * @return {!Promise<?>} A promise that will be fulfilled with the command\n   *     result.\n   */\n  execute(command) {}\n}\n\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  Command: Command,\n  Name: Name,\n  Executor: Executor\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/command.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/error.js":
/*!*******************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/error.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\n/**\n * The base WebDriver error type. This error type is only used directly when a\n * more appropriate category is not defined for the offending error.\n */\nclass WebDriverError extends Error {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n\n    /** @override */\n    this.name = this.constructor.name;\n\n    /**\n     * A stacktrace reported by the remote webdriver endpoint that initially\n     * reported this error. This property will be an empty string if the remote\n     * end did not provide a stacktrace.\n     * @type {string}\n     */\n    this.remoteStacktrace = '';\n  }\n}\n\n\n/**\n * Indicates a {@linkplain ./webdriver.WebElement#click click command} could not\n * completed because the click target is obscured by other elements on the\n * page.\n */\nclass ElementClickInterceptedError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * An attempt was made to select an element that cannot be selected.\n */\nclass ElementNotSelectableError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * Indicates a command could not be completed because the target element is\n * not pointer or keyboard interactable. This will often occur if an element\n * is present in the DOM, but not rendered (i.e. its CSS style has\n * \"display: none\").\n */\nclass ElementNotInteractableError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * Indicates a navigation event caused the browser to generate a certificate\n * warning. This is usually caused by an expired or invalid TLS certificate.\n */\nclass InsecureCertificateError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * The arguments passed to a command are either invalid or malformed.\n */\nclass InvalidArgumentError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * An illegal attempt was made to set a cookie under a different domain than\n * the current page.\n */\nclass InvalidCookieDomainError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * The coordinates provided to an interactions operation are invalid.\n */\nclass InvalidCoordinatesError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * An element command could not be completed because the element is in an\n * invalid state, e.g. attempting to click an element that is no longer attached\n * to the document.\n */\nclass InvalidElementStateError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * Argument was an invalid selector.\n */\nclass InvalidSelectorError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * Occurs when a command is directed to a session that does not exist.\n */\nclass NoSuchSessionError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * An error occurred while executing JavaScript supplied by the user.\n */\nclass JavascriptError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * The target for mouse interaction is not in the browserâ€™s viewport and cannot\n * be brought into that viewport.\n */\nclass MoveTargetOutOfBoundsError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * An attempt was made to operate on a modal dialog when one was not open.\n */\nclass NoSuchAlertError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * Indicates a named cookie could not be found in the cookie jar for the\n * currently selected document.\n */\nclass NoSuchCookieError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * An element could not be located on the page using the given search\n * parameters.\n */\nclass NoSuchElementError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * A request to switch to a frame could not be satisfied because the frame\n * could not be found.\n */\nclass NoSuchFrameError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * A request to switch to a window could not be satisfied because the window\n * could not be found.\n */\nclass NoSuchWindowError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * A script did not complete before its timeout expired.\n */\nclass ScriptTimeoutError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * A new session could not be created.\n */\nclass SessionNotCreatedError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n\n/**\n * An element command failed because the referenced element is no longer\n * attached to the DOM.\n */\nclass StaleElementReferenceError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * An operation did not complete before its timeout expired.\n */\nclass TimeoutError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * A request to set a cookieâ€™s value could not be satisfied.\n */\nclass UnableToSetCookieError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * A screen capture operation was not possible.\n */\nclass UnableToCaptureScreenError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * A modal dialog was open, blocking this operation.\n */\nclass UnexpectedAlertOpenError extends WebDriverError {\n  /**\n   * @param {string=} opt_error the error message, if any.\n   * @param {string=} opt_text the text of the open dialog, if available.\n   */\n  constructor(opt_error, opt_text) {\n    super(opt_error);\n\n    /** @private {(string|undefined)} */\n    this.text_ = opt_text;\n  }\n\n  /**\n   * @return {(string|undefined)} The text displayed with the unhandled alert,\n   *     if available.\n   */\n  getAlertText() {\n    return this.text_;\n  }\n}\n\n\n/**\n * A command could not be executed because the remote end is not aware of it.\n */\nclass UnknownCommandError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * The requested command matched a known URL but did not match an method for\n * that URL.\n */\nclass UnknownMethodError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n\n/**\n * Reports an unsupported operation.\n */\nclass UnsupportedOperationError extends WebDriverError {\n  /** @param {string=} opt_error the error message, if any. */\n  constructor(opt_error) {\n    super(opt_error);\n  }\n}\n\n// TODO(jleyba): Define UnknownError as an alias of WebDriverError?\n\n\n/**\n * Enum of legacy error codes.\n * TODO: remove this when all code paths have been switched to the new error\n * types.\n * @deprecated\n * @enum {number}\n */\nconst ErrorCode = {\n  SUCCESS: 0,\n  NO_SUCH_SESSION: 6,\n  NO_SUCH_ELEMENT: 7,\n  NO_SUCH_FRAME: 8,\n  UNKNOWN_COMMAND: 9,\n  UNSUPPORTED_OPERATION: 9,\n  STALE_ELEMENT_REFERENCE: 10,\n  ELEMENT_NOT_VISIBLE: 11,\n  INVALID_ELEMENT_STATE: 12,\n  UNKNOWN_ERROR: 13,\n  ELEMENT_NOT_SELECTABLE: 15,\n  JAVASCRIPT_ERROR: 17,\n  XPATH_LOOKUP_ERROR: 19,\n  TIMEOUT: 21,\n  NO_SUCH_WINDOW: 23,\n  INVALID_COOKIE_DOMAIN: 24,\n  UNABLE_TO_SET_COOKIE: 25,\n  UNEXPECTED_ALERT_OPEN: 26,\n  NO_SUCH_ALERT: 27,\n  SCRIPT_TIMEOUT: 28,\n  INVALID_ELEMENT_COORDINATES: 29,\n  IME_NOT_AVAILABLE: 30,\n  IME_ENGINE_ACTIVATION_FAILED: 31,\n  INVALID_SELECTOR_ERROR: 32,\n  SESSION_NOT_CREATED: 33,\n  MOVE_TARGET_OUT_OF_BOUNDS: 34,\n  SQL_DATABASE_ERROR: 35,\n  INVALID_XPATH_SELECTOR: 51,\n  INVALID_XPATH_SELECTOR_RETURN_TYPE: 52,\n  ELEMENT_NOT_INTERACTABLE: 60,\n  INVALID_ARGUMENT: 61,\n  NO_SUCH_COOKIE: 62,\n  UNABLE_TO_CAPTURE_SCREEN: 63,\n  ELEMENT_CLICK_INTERCEPTED: 64,\n  METHOD_NOT_ALLOWED: 405\n};\n\n\nconst LEGACY_ERROR_CODE_TO_TYPE = new Map([\n    [ErrorCode.NO_SUCH_SESSION, NoSuchSessionError],\n    [ErrorCode.NO_SUCH_ELEMENT, NoSuchElementError],\n    [ErrorCode.NO_SUCH_FRAME, NoSuchFrameError],\n    [ErrorCode.UNSUPPORTED_OPERATION, UnsupportedOperationError],\n    [ErrorCode.STALE_ELEMENT_REFERENCE, StaleElementReferenceError],\n    [ErrorCode.INVALID_ELEMENT_STATE, InvalidElementStateError],\n    [ErrorCode.UNKNOWN_ERROR, WebDriverError],\n    [ErrorCode.ELEMENT_NOT_SELECTABLE, ElementNotSelectableError],\n    [ErrorCode.JAVASCRIPT_ERROR, JavascriptError],\n    [ErrorCode.XPATH_LOOKUP_ERROR, InvalidSelectorError],\n    [ErrorCode.TIMEOUT, TimeoutError],\n    [ErrorCode.NO_SUCH_WINDOW, NoSuchWindowError],\n    [ErrorCode.INVALID_COOKIE_DOMAIN, InvalidCookieDomainError],\n    [ErrorCode.UNABLE_TO_SET_COOKIE, UnableToSetCookieError],\n    [ErrorCode.UNEXPECTED_ALERT_OPEN, UnexpectedAlertOpenError],\n    [ErrorCode.NO_SUCH_ALERT, NoSuchAlertError],\n    [ErrorCode.SCRIPT_TIMEOUT, ScriptTimeoutError],\n    [ErrorCode.INVALID_ELEMENT_COORDINATES, InvalidCoordinatesError],\n    [ErrorCode.INVALID_SELECTOR_ERROR, InvalidSelectorError],\n    [ErrorCode.SESSION_NOT_CREATED, SessionNotCreatedError],\n    [ErrorCode.MOVE_TARGET_OUT_OF_BOUNDS, MoveTargetOutOfBoundsError],\n    [ErrorCode.INVALID_XPATH_SELECTOR, InvalidSelectorError],\n    [ErrorCode.INVALID_XPATH_SELECTOR_RETURN_TYPE, InvalidSelectorError],\n    [ErrorCode.ELEMENT_NOT_INTERACTABLE, ElementNotInteractableError],\n    [ErrorCode.INVALID_ARGUMENT, InvalidArgumentError],\n    [ErrorCode.NO_SUCH_COOKIE, NoSuchCookieError],\n    [ErrorCode.UNABLE_TO_CAPTURE_SCREEN, UnableToCaptureScreenError],\n    [ErrorCode.ELEMENT_CLICK_INTERCEPTED, ElementClickInterceptedError],\n    [ErrorCode.METHOD_NOT_ALLOWED, UnsupportedOperationError]]);\n\n\nconst ERROR_CODE_TO_TYPE = new Map([\n    ['unknown error', WebDriverError],\n    ['element click intercepted', ElementClickInterceptedError],\n    ['element not interactable', ElementNotInteractableError],\n    ['element not selectable', ElementNotSelectableError],\n    ['insecure certificate', InsecureCertificateError],\n    ['invalid argument', InvalidArgumentError],\n    ['invalid cookie domain', InvalidCookieDomainError],\n    ['invalid coordinates', InvalidCoordinatesError],\n    ['invalid element state', InvalidElementStateError],\n    ['invalid selector', InvalidSelectorError],\n    ['invalid session id', NoSuchSessionError],\n    ['javascript error', JavascriptError],\n    ['move target out of bounds', MoveTargetOutOfBoundsError],\n    ['no such alert', NoSuchAlertError],\n    ['no such cookie', NoSuchCookieError],\n    ['no such element', NoSuchElementError],\n    ['no such frame', NoSuchFrameError],\n    ['no such window', NoSuchWindowError],\n    ['script timeout', ScriptTimeoutError],\n    ['session not created', SessionNotCreatedError],\n    ['stale element reference', StaleElementReferenceError],\n    ['timeout', TimeoutError],\n    ['unable to set cookie', UnableToSetCookieError],\n    ['unable to capture screen', UnableToCaptureScreenError],\n    ['unexpected alert open', UnexpectedAlertOpenError],\n    ['unknown command', UnknownCommandError],\n    ['unknown method', UnknownMethodError],\n    ['unsupported operation', UnsupportedOperationError]]);\n\n\nconst TYPE_TO_ERROR_CODE = new Map;\nERROR_CODE_TO_TYPE.forEach((value, key) => {\n  TYPE_TO_ERROR_CODE.set(value, key);\n});\n\n\n\n/**\n * @param {*} err The error to encode.\n * @return {{error: string, message: string}} the encoded error.\n */\nfunction encodeError(err) {\n  let type = WebDriverError;\n  if (err instanceof WebDriverError\n      && TYPE_TO_ERROR_CODE.has(err.constructor)) {\n    type = err.constructor;\n  }\n\n  let message = err instanceof Error\n      ? err.message\n      : err + '';\n\n  let code = /** @type {string} */(TYPE_TO_ERROR_CODE.get(type));\n  return {'error': code, 'message': message};\n}\n\n\n/**\n * Checks a response object from a server that adheres to the W3C WebDriver\n * protocol.\n * @param {*} data The response data to check.\n * @return {*} The response data if it was not an encoded error.\n * @throws {WebDriverError} the decoded error, if present in the data object.\n * @deprecated Use {@link #throwDecodedError(data)} instead.\n * @see https://w3c.github.io/webdriver/webdriver-spec.html#protocol\n */\nfunction checkResponse(data) {\n  if (data && typeof data.error === 'string') {\n    let ctor = ERROR_CODE_TO_TYPE.get(data.error) || WebDriverError;\n    throw new ctor(data.message);\n  }\n  return data;\n}\n\n/**\n * Tests if the given value is a valid error response object according to the\n * W3C WebDriver spec.\n *\n * @param {?} data The value to test.\n * @return {boolean} Whether the given value data object is a valid error\n *     response.\n * @see https://w3c.github.io/webdriver/webdriver-spec.html#protocol\n */\nfunction isErrorResponse(data) {\n  return data && typeof data === 'object' && typeof data.error === 'string';\n}\n\n/**\n * Throws an error coded from the W3C protocol. A generic error will be thrown\n * if the provided `data` is not a valid encoded error.\n *\n * @param {{error: string, message: string}} data The error data to decode.\n * @throws {WebDriverError} the decoded error.\n * @see https://w3c.github.io/webdriver/webdriver-spec.html#protocol\n */\nfunction throwDecodedError(data) {\n  if (isErrorResponse(data)) {\n    let ctor = ERROR_CODE_TO_TYPE.get(data.error) || WebDriverError;\n    let err = new ctor(data.message);\n    // TODO(jleyba): remove whichever case is excluded from the final W3C spec.\n    if (typeof data.stacktrace === 'string') {\n      err.remoteStacktrace = data.stacktrace;\n    } else if (typeof data.stackTrace === 'string') {\n      err.remoteStacktrace = data.stackTrace;\n    }\n    throw err;\n  }\n  throw new WebDriverError('Unknown error: ' + JSON.stringify(data));\n}\n\n\n/**\n * Checks a legacy response from the Selenium 2.0 wire protocol for an error.\n * @param {*} responseObj the response object to check.\n * @return {*} responseObj the original response if it does not define an error.\n * @throws {WebDriverError} if the response object defines an error.\n */\nfunction checkLegacyResponse(responseObj) {\n  // Handle the legacy Selenium error response format.\n  if (responseObj\n      && typeof responseObj === 'object'\n      && typeof responseObj['status'] === 'number'\n      && responseObj['status'] !== 0) {\n    let status = responseObj['status'];\n    let ctor = LEGACY_ERROR_CODE_TO_TYPE.get(status) || WebDriverError;\n\n    let value = responseObj['value'];\n\n    if (!value || typeof value !== 'object') {\n      throw new ctor(value + '');\n    } else {\n      let message = value['message'] + '';\n      if (ctor !== UnexpectedAlertOpenError) {\n        throw new ctor(message);\n      }\n\n      let text = '';\n      if (value['alert'] && typeof value['alert']['text'] === 'string') {\n        text = value['alert']['text'];\n      }\n      throw new UnexpectedAlertOpenError(message, text);\n    }\n  }\n  return responseObj;\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  ErrorCode,\n\n  WebDriverError,\n  ElementClickInterceptedError,\n  ElementNotInteractableError,\n  ElementNotSelectableError,\n  InsecureCertificateError,\n  InvalidArgumentError,\n  InvalidCookieDomainError,\n  InvalidCoordinatesError,\n  InvalidElementStateError,\n  InvalidSelectorError,\n  JavascriptError,\n  MoveTargetOutOfBoundsError,\n  NoSuchAlertError,\n  NoSuchCookieError,\n  NoSuchElementError,\n  NoSuchFrameError,\n  NoSuchSessionError,\n  NoSuchWindowError,\n  ScriptTimeoutError,\n  SessionNotCreatedError,\n  StaleElementReferenceError,\n  TimeoutError,\n  UnableToSetCookieError,\n  UnableToCaptureScreenError,\n  UnexpectedAlertOpenError,\n  UnknownCommandError,\n  UnknownMethodError,\n  UnsupportedOperationError,\n\n  checkResponse,\n  checkLegacyResponse,\n  encodeError,\n  isErrorResponse,\n  throwDecodedError,\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/error.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/http.js":
/*!******************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/http.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines an environment agnostic {@linkplain cmd.Executor\n * command executor} that communicates with a remote end using JSON over HTTP.\n *\n * Clients should implement the {@link Client} interface, which is used by\n * the {@link Executor} to send commands to the remote end.\n */\n\n\n\nconst cmd = __webpack_require__(/*! ./command */ \"../node_modules/selenium-webdriver/lib/command.js\");\nconst error = __webpack_require__(/*! ./error */ \"../node_modules/selenium-webdriver/lib/error.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"../node_modules/selenium-webdriver/lib/logging.js\");\nconst promise = __webpack_require__(/*! ./promise */ \"../node_modules/selenium-webdriver/lib/promise.js\");\nconst {Session} = __webpack_require__(/*! ./session */ \"../node_modules/selenium-webdriver/lib/session.js\");\nconst {WebElement} = __webpack_require__(/*! ./webdriver */ \"../node_modules/selenium-webdriver/lib/webdriver.js\");\n\nconst {getAttribute, isDisplayed} = /** @suppress {undefinedVars|uselessCode} */(function() {\n  try {\n    return {\n      getAttribute: __webpack_require__(/*! ./atoms/get-attribute.js */ \"../node_modules/selenium-webdriver/lib/atoms/get-attribute.js\"),\n      isDisplayed: __webpack_require__(/*! ./atoms/is-displayed.js */ \"../node_modules/selenium-webdriver/lib/atoms/is-displayed.js\")\n    };\n  } catch (ex) {\n    throw Error(\n        'Failed to import atoms modules. If running in devmode, you need to run'\n            + ' `./go node:atoms` from the project root: ' + ex);\n  }\n})();\n\n\n/**\n * Converts a headers map to a HTTP header block string.\n * @param {!Map<string, string>} headers The map to convert.\n * @return {string} The headers as a string.\n */\nfunction headersToString(headers) {\n  let ret = [];\n  headers.forEach(function(value, name) {\n    ret.push(`${name.toLowerCase()}: ${value}`);\n  });\n  return ret.join('\\n');\n}\n\n\n/**\n * Represents a HTTP request message. This class is a \"partial\" request and only\n * defines the path on the server to send a request to. It is each client's\n * responsibility to build the full URL for the final request.\n * @final\n */\nclass Request {\n  /**\n   * @param {string} method The HTTP method to use for the request.\n   * @param {string} path The path on the server to send the request to.\n   * @param {Object=} opt_data This request's non-serialized JSON payload data.\n   */\n  constructor(method, path, opt_data) {\n    this.method = /** string */method;\n    this.path = /** string */path;\n    this.data = /** Object */opt_data;\n    this.headers = /** !Map<string, string> */new Map(\n        [['Accept', 'application/json; charset=utf-8']]);\n  }\n\n  /** @override */\n  toString() {\n    let ret = `${this.method} ${this.path} HTTP/1.1\\n`;\n    ret += headersToString(this.headers) + '\\n\\n';\n    if (this.data) {\n      ret += JSON.stringify(this.data);\n    }\n    return ret;\n  }\n}\n\n\n/**\n * Represents a HTTP response message.\n * @final\n */\nclass Response {\n  /**\n   * @param {number} status The response code.\n   * @param {!Object<string>} headers The response headers. All header names\n   *     will be converted to lowercase strings for consistent lookups.\n   * @param {string} body The response body.\n   */\n  constructor(status, headers, body) {\n    this.status = /** number */status;\n    this.body = /** string */body;\n    this.headers = /** !Map<string, string>*/new Map;\n    for (let header in headers) {\n      this.headers.set(header.toLowerCase(), headers[header]);\n    }\n  }\n\n  /** @override */\n  toString() {\n    let ret = `HTTP/1.1 ${this.status}\\n${headersToString(this.headers)}\\n\\n`;\n    if (this.body) {\n      ret += this.body;\n    }\n    return ret;\n  }\n}\n\n\nconst DEV_ROOT = '../../../../buck-out/gen/javascript/';\n\n/** @enum {!Function} */\nconst Atom = {\n  GET_ATTRIBUTE: getAttribute,\n  IS_DISPLAYED: isDisplayed\n};\n\n\nconst LOG = logging.getLogger('webdriver.http');\n\n\nfunction post(path) { return resource('POST', path); }\nfunction del(path)  { return resource('DELETE', path); }\nfunction get(path)  { return resource('GET', path); }\nfunction resource(method, path) { return {method: method, path: path}; }\n\n\n/** @typedef {{method: string, path: string}} */\nvar CommandSpec;\n\n\n/** @typedef {function(!cmd.Command): !cmd.Command} */\nvar CommandTransformer;\n\n\nclass InternalTypeError extends TypeError {}\n\n\n/**\n * @param {!cmd.Command} command The initial command.\n * @param {Atom} atom The name of the atom to execute.\n * @return {!cmd.Command} The transformed command to execute.\n */\nfunction toExecuteAtomCommand(command, atom, ...params) {\n  if (typeof atom !== 'function') {\n    throw new InternalTypeError('atom is not a function: ' + typeof atom);\n  }\n\n  return new cmd.Command(cmd.Name.EXECUTE_SCRIPT)\n      .setParameter('sessionId', command.getParameter('sessionId'))\n      .setParameter('script', `return (${atom}).apply(null, arguments)`)\n      .setParameter('args', params.map(param => command.getParameter(param)));\n}\n\n\n\n/** @const {!Map<string, CommandSpec>} */\nconst COMMAND_MAP = new Map([\n    [cmd.Name.GET_SERVER_STATUS, get('/status')],\n    [cmd.Name.NEW_SESSION, post('/session')],\n    [cmd.Name.GET_SESSIONS, get('/sessions')],\n    [cmd.Name.QUIT, del('/session/:sessionId')],\n    [cmd.Name.CLOSE, del('/session/:sessionId/window')],\n    [cmd.Name.GET_CURRENT_WINDOW_HANDLE, get('/session/:sessionId/window_handle')],\n    [cmd.Name.GET_WINDOW_HANDLES, get('/session/:sessionId/window_handles')],\n    [cmd.Name.GET_CURRENT_URL, get('/session/:sessionId/url')],\n    [cmd.Name.GET, post('/session/:sessionId/url')],\n    [cmd.Name.GO_BACK, post('/session/:sessionId/back')],\n    [cmd.Name.GO_FORWARD, post('/session/:sessionId/forward')],\n    [cmd.Name.REFRESH, post('/session/:sessionId/refresh')],\n    [cmd.Name.ADD_COOKIE, post('/session/:sessionId/cookie')],\n    [cmd.Name.GET_ALL_COOKIES, get('/session/:sessionId/cookie')],\n    [cmd.Name.DELETE_ALL_COOKIES, del('/session/:sessionId/cookie')],\n    [cmd.Name.DELETE_COOKIE, del('/session/:sessionId/cookie/:name')],\n    [cmd.Name.FIND_ELEMENT, post('/session/:sessionId/element')],\n    [cmd.Name.FIND_ELEMENTS, post('/session/:sessionId/elements')],\n    [cmd.Name.GET_ACTIVE_ELEMENT, post('/session/:sessionId/element/active')],\n    [cmd.Name.FIND_CHILD_ELEMENT, post('/session/:sessionId/element/:id/element')],\n    [cmd.Name.FIND_CHILD_ELEMENTS, post('/session/:sessionId/element/:id/elements')],\n    [cmd.Name.CLEAR_ELEMENT, post('/session/:sessionId/element/:id/clear')],\n    [cmd.Name.CLICK_ELEMENT, post('/session/:sessionId/element/:id/click')],\n    [cmd.Name.SEND_KEYS_TO_ELEMENT, post('/session/:sessionId/element/:id/value')],\n    [cmd.Name.SUBMIT_ELEMENT, post('/session/:sessionId/element/:id/submit')],\n    [cmd.Name.GET_ELEMENT_TEXT, get('/session/:sessionId/element/:id/text')],\n    [cmd.Name.GET_ELEMENT_TAG_NAME, get('/session/:sessionId/element/:id/name')],\n    [cmd.Name.IS_ELEMENT_SELECTED, get('/session/:sessionId/element/:id/selected')],\n    [cmd.Name.IS_ELEMENT_ENABLED, get('/session/:sessionId/element/:id/enabled')],\n    [cmd.Name.IS_ELEMENT_DISPLAYED, get('/session/:sessionId/element/:id/displayed')],\n    [cmd.Name.GET_ELEMENT_LOCATION, get('/session/:sessionId/element/:id/location')],\n    [cmd.Name.GET_ELEMENT_SIZE, get('/session/:sessionId/element/:id/size')],\n    [cmd.Name.GET_ELEMENT_ATTRIBUTE, get('/session/:sessionId/element/:id/attribute/:name')],\n    [cmd.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY, get('/session/:sessionId/element/:id/css/:propertyName')],\n    [cmd.Name.TAKE_ELEMENT_SCREENSHOT, get('/session/:sessionId/element/:id/screenshot')],\n    [cmd.Name.SWITCH_TO_WINDOW, post('/session/:sessionId/window')],\n    [cmd.Name.MAXIMIZE_WINDOW, post('/session/:sessionId/window/current/maximize')],\n    [cmd.Name.GET_WINDOW_POSITION, get('/session/:sessionId/window/current/position')],\n    [cmd.Name.SET_WINDOW_POSITION, post('/session/:sessionId/window/current/position')],\n    [cmd.Name.GET_WINDOW_SIZE, get('/session/:sessionId/window/current/size')],\n    [cmd.Name.SET_WINDOW_SIZE, post('/session/:sessionId/window/current/size')],\n    [cmd.Name.SWITCH_TO_FRAME, post('/session/:sessionId/frame')],\n    [cmd.Name.GET_PAGE_SOURCE, get('/session/:sessionId/source')],\n    [cmd.Name.GET_TITLE, get('/session/:sessionId/title')],\n    [cmd.Name.EXECUTE_SCRIPT, post('/session/:sessionId/execute')],\n    [cmd.Name.EXECUTE_ASYNC_SCRIPT, post('/session/:sessionId/execute_async')],\n    [cmd.Name.SCREENSHOT, get('/session/:sessionId/screenshot')],\n    [cmd.Name.GET_TIMEOUT, get('/session/:sessionId/timeouts')],\n    [cmd.Name.SET_TIMEOUT, post('/session/:sessionId/timeouts')],\n    [cmd.Name.ACCEPT_ALERT, post('/session/:sessionId/accept_alert')],\n    [cmd.Name.DISMISS_ALERT, post('/session/:sessionId/dismiss_alert')],\n    [cmd.Name.GET_ALERT_TEXT, get('/session/:sessionId/alert_text')],\n    [cmd.Name.SET_ALERT_TEXT, post('/session/:sessionId/alert_text')],\n    [cmd.Name.GET_LOG, post('/session/:sessionId/log')],\n    [cmd.Name.GET_AVAILABLE_LOG_TYPES, get('/session/:sessionId/log/types')],\n    [cmd.Name.GET_SESSION_LOGS, post('/logs')],\n    [cmd.Name.UPLOAD_FILE, post('/session/:sessionId/file')],\n    [cmd.Name.LEGACY_ACTION_CLICK, post('/session/:sessionId/click')],\n    [cmd.Name.LEGACY_ACTION_DOUBLE_CLICK, post('/session/:sessionId/doubleclick')],\n    [cmd.Name.LEGACY_ACTION_MOUSE_DOWN, post('/session/:sessionId/buttondown')],\n    [cmd.Name.LEGACY_ACTION_MOUSE_UP, post('/session/:sessionId/buttonup')],\n    [cmd.Name.LEGACY_ACTION_MOUSE_MOVE, post('/session/:sessionId/moveto')],\n    [cmd.Name.LEGACY_ACTION_SEND_KEYS, post('/session/:sessionId/keys')],\n    [cmd.Name.LEGACY_ACTION_TOUCH_DOWN, post('/session/:sessionId/touch/down')],\n    [cmd.Name.LEGACY_ACTION_TOUCH_UP, post('/session/:sessionId/touch/up')],\n    [cmd.Name.LEGACY_ACTION_TOUCH_MOVE, post('/session/:sessionId/touch/move')],\n    [cmd.Name.LEGACY_ACTION_TOUCH_SCROLL, post('/session/:sessionId/touch/scroll')],\n    [cmd.Name.LEGACY_ACTION_TOUCH_LONG_PRESS, post('/session/:sessionId/touch/longclick')],\n    [cmd.Name.LEGACY_ACTION_TOUCH_FLICK, post('/session/:sessionId/touch/flick')],\n    [cmd.Name.LEGACY_ACTION_TOUCH_SINGLE_TAP, post('/session/:sessionId/touch/click')],\n    [cmd.Name.LEGACY_ACTION_TOUCH_DOUBLE_TAP, post('/session/:sessionId/touch/doubleclick')],\n]);\n\n\n/** @const {!Map<string, (CommandSpec|CommandTransformer)>} */\nconst W3C_COMMAND_MAP = new Map([\n  // Server status.\n  [cmd.Name.GET_SERVER_STATUS, get('/status')],\n  // Session management.\n  [cmd.Name.NEW_SESSION, post('/session')],\n  [cmd.Name.QUIT, del('/session/:sessionId')],\n  [cmd.Name.GET_TIMEOUT, get('/session/:sessionId/timeouts')],\n  [cmd.Name.SET_TIMEOUT, post('/session/:sessionId/timeouts')],\n  // Navigation.\n  [cmd.Name.GET_CURRENT_URL, get('/session/:sessionId/url')],\n  [cmd.Name.GET, post('/session/:sessionId/url')],\n  [cmd.Name.GO_BACK, post('/session/:sessionId/back')],\n  [cmd.Name.GO_FORWARD, post('/session/:sessionId/forward')],\n  [cmd.Name.REFRESH, post('/session/:sessionId/refresh')],\n  // Page inspection.\n  [cmd.Name.GET_PAGE_SOURCE, get('/session/:sessionId/source')],\n  [cmd.Name.GET_TITLE, get('/session/:sessionId/title')],\n  // Script execution.\n  [cmd.Name.EXECUTE_SCRIPT, post('/session/:sessionId/execute/sync')],\n  [cmd.Name.EXECUTE_ASYNC_SCRIPT, post('/session/:sessionId/execute/async')],\n  // Frame selection.\n  [cmd.Name.SWITCH_TO_FRAME, post('/session/:sessionId/frame')],\n  [cmd.Name.SWITCH_TO_FRAME_PARENT, post('/session/:sessionId/frame/parent')],\n  // Window management.\n  [cmd.Name.GET_CURRENT_WINDOW_HANDLE, get('/session/:sessionId/window')],\n  [cmd.Name.CLOSE, del('/session/:sessionId/window')],\n  [cmd.Name.SWITCH_TO_WINDOW, post('/session/:sessionId/window')],\n  [cmd.Name.GET_WINDOW_HANDLES, get('/session/:sessionId/window/handles')],\n  [cmd.Name.GET_WINDOW_RECT, get('/session/:sessionId/window/rect')],\n  [cmd.Name.SET_WINDOW_RECT, post('/session/:sessionId/window/rect')],\n  [cmd.Name.MAXIMIZE_WINDOW, post('/session/:sessionId/window/maximize')],\n  [cmd.Name.MINIMIZE_WINDOW, post('/session/:sessionId/window/minimize')],\n  [cmd.Name.FULLSCREEN_WINDOW, post('/session/:sessionId/window/fullscreen')],\n  // Actions.\n  [cmd.Name.ACTIONS, post('/session/:sessionId/actions')],\n  [cmd.Name.CLEAR_ACTIONS, del('/session/:sessionId/actions')],\n  // Locating elements.\n  [cmd.Name.GET_ACTIVE_ELEMENT, get('/session/:sessionId/element/active')],\n  [cmd.Name.FIND_ELEMENT, post('/session/:sessionId/element')],\n  [cmd.Name.FIND_ELEMENTS, post('/session/:sessionId/elements')],\n  [cmd.Name.FIND_CHILD_ELEMENT, post('/session/:sessionId/element/:id/element')],\n  [cmd.Name.FIND_CHILD_ELEMENTS, post('/session/:sessionId/element/:id/elements')],\n  // Element interaction.\n  [cmd.Name.GET_ELEMENT_TAG_NAME, get('/session/:sessionId/element/:id/name')],\n  [cmd.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY, get('/session/:sessionId/element/:id/css/:propertyName')],\n  [cmd.Name.GET_ELEMENT_RECT, get('/session/:sessionId/element/:id/rect')],\n  [cmd.Name.CLEAR_ELEMENT, post('/session/:sessionId/element/:id/clear')],\n  [cmd.Name.CLICK_ELEMENT, post('/session/:sessionId/element/:id/click')],\n  [cmd.Name.SEND_KEYS_TO_ELEMENT, post('/session/:sessionId/element/:id/value')],\n  [cmd.Name.GET_ELEMENT_TEXT, get('/session/:sessionId/element/:id/text')],\n  [cmd.Name.IS_ELEMENT_ENABLED, get('/session/:sessionId/element/:id/enabled')],\n  [cmd.Name.GET_ELEMENT_ATTRIBUTE, (cmd) => {\n    return toExecuteAtomCommand(cmd, Atom.GET_ATTRIBUTE, 'id', 'name');\n  }],\n  [cmd.Name.IS_ELEMENT_DISPLAYED, (cmd) => {\n    return toExecuteAtomCommand(cmd, Atom.IS_DISPLAYED, 'id');\n  }],\n  // Cookie management.\n  [cmd.Name.GET_ALL_COOKIES, get('/session/:sessionId/cookie')],\n  [cmd.Name.ADD_COOKIE, post('/session/:sessionId/cookie')],\n  [cmd.Name.DELETE_ALL_COOKIES, del('/session/:sessionId/cookie')],\n  [cmd.Name.GET_COOKIE, get('/session/:sessionId/cookie/:name')],\n  [cmd.Name.DELETE_COOKIE, del('/session/:sessionId/cookie/:name')],\n  // Alert management.\n  [cmd.Name.ACCEPT_ALERT, post('/session/:sessionId/alert/accept')],\n  [cmd.Name.DISMISS_ALERT, post('/session/:sessionId/alert/dismiss')],\n  [cmd.Name.GET_ALERT_TEXT, get('/session/:sessionId/alert/text')],\n  [cmd.Name.SET_ALERT_TEXT, post('/session/:sessionId/alert/text')],\n  // Screenshots.\n  [cmd.Name.SCREENSHOT, get('/session/:sessionId/screenshot')],\n  [cmd.Name.TAKE_ELEMENT_SCREENSHOT, get('/session/:sessionId/element/:id/screenshot')],\n]);\n\n\n/**\n * Handles sending HTTP messages to a remote end.\n *\n * @interface\n */\nclass Client {\n\n  /**\n   * Sends a request to the server. The client will automatically follow any\n   * redirects returned by the server, fulfilling the returned promise with the\n   * final response.\n   *\n   * @param {!Request} httpRequest The request to send.\n   * @return {!Promise<Response>} A promise that will be fulfilled with the\n   *     server's response.\n   */\n  send(httpRequest) {}\n}\n\n\n\n/**\n * @param {Map<string, CommandSpec>} customCommands\n *     A map of custom command definitions.\n * @param {boolean} w3c Whether to use W3C command mappings.\n * @param {!cmd.Command} command The command to resolve.\n * @return {!Request} A promise that will resolve with the\n *     command to execute.\n */\nfunction buildRequest(customCommands, w3c, command) {\n  LOG.finest(() => `Translating command: ${command.getName()}`);\n  let spec = customCommands && customCommands.get(command.getName());\n  if (spec) {\n    return toHttpRequest(spec);\n  }\n\n  if (w3c) {\n    spec = W3C_COMMAND_MAP.get(command.getName());\n    if (typeof spec === 'function') {\n      LOG.finest(() => `Transforming command for W3C: ${command.getName()}`);\n      let newCommand = spec(command);\n      return buildRequest(customCommands, w3c, newCommand);\n    } else if (spec) {\n      return toHttpRequest(spec);\n    }\n  }\n\n  spec = COMMAND_MAP.get(command.getName());\n  if (spec) {\n    return toHttpRequest(spec);\n  }\n  throw new error.UnknownCommandError(\n      'Unrecognized command: ' + command.getName());\n\n  /**\n   * @param {CommandSpec} resource\n   * @return {!Request}\n   */\n  function toHttpRequest(resource) {\n    LOG.finest(() => `Building HTTP request: ${JSON.stringify(resource)}`);\n    let parameters = command.getParameters();\n    let path = buildPath(resource.path, parameters);\n    return new Request(resource.method, path, parameters);\n  }\n}\n\n\nconst CLIENTS =\n    /** !WeakMap<!Executor, !(Client|IThenable<!Client>)> */new WeakMap;\n\n\n/**\n * A command executor that communicates with the server using JSON over HTTP.\n *\n * By default, each instance of this class will use the legacy wire protocol\n * from [Selenium project][json]. The executor will automatically switch to the\n * [W3C wire protocol][w3c] if the remote end returns a compliant response to\n * a new session command.\n *\n * [json]: https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol\n * [w3c]: https://w3c.github.io/webdriver/webdriver-spec.html\n *\n * @implements {cmd.Executor}\n */\nclass Executor {\n  /**\n   * @param {!(Client|IThenable<!Client>)} client The client to use for sending\n   *     requests to the server, or a promise-like object that will resolve to\n   *     to the client.\n   */\n  constructor(client) {\n    CLIENTS.set(this, client);\n\n    /**\n     * Whether this executor should use the W3C wire protocol. The executor\n     * will automatically switch if the remote end sends a compliant response\n     * to a new session command, however, this property may be directly set to\n     * `true` to force the executor into W3C mode.\n     * @type {boolean}\n     */\n    this.w3c = false;\n\n    /** @private {Map<string, CommandSpec>} */\n    this.customCommands_ = null;\n\n    /** @private {!logging.Logger} */\n    this.log_ = logging.getLogger('webdriver.http.Executor');\n  }\n\n  /**\n   * Defines a new command for use with this executor. When a command is sent,\n   * the {@code path} will be preprocessed using the command's parameters; any\n   * path segments prefixed with \":\" will be replaced by the parameter of the\n   * same name. For example, given \"/person/:name\" and the parameters\n   * \"{name: 'Bob'}\", the final command path will be \"/person/Bob\".\n   *\n   * @param {string} name The command name.\n   * @param {string} method The HTTP method to use when sending this command.\n   * @param {string} path The path to send the command to, relative to\n   *     the WebDriver server's command root and of the form\n   *     \"/path/:variable/segment\".\n   */\n  defineCommand(name, method, path) {\n    if (!this.customCommands_) {\n      this.customCommands_ = new Map;\n    }\n    this.customCommands_.set(name, {method, path});\n  }\n\n  /** @override */\n  async execute(command) {\n    let request = buildRequest(this.customCommands_, this.w3c, command);\n    this.log_.finer(() => `>>> ${request.method} ${request.path}`);\n\n    let client = CLIENTS.get(this);\n    if (promise.isPromise(client)) {\n      client = await client;\n      CLIENTS.set(this, client);\n    }\n\n    let response = await client.send(request);\n    this.log_.finer(() => `>>>\\n${request}\\n<<<\\n${response}`);\n\n    let httpResponse = /** @type {!Response} */(response);\n    let {isW3C, value} = parseHttpResponse(command, httpResponse);\n\n    if (command.getName() === cmd.Name.NEW_SESSION) {\n      if (!value || !value.sessionId) {\n        throw new error.WebDriverError(\n            `Unable to parse new session response: ${response.body}`);\n      }\n\n      // The remote end is a W3C compliant server if there is no `status`\n      // field in the response.\n      if (command.getName() === cmd.Name.NEW_SESSION) {\n        this.w3c = this.w3c || isW3C;\n      }\n\n      // No implementations use the `capabilities` key yet...\n      let capabilities = value.capabilities || value.value;\n      return new Session(\n          /** @type {{sessionId: string}} */(value).sessionId, capabilities);\n    }\n\n    return typeof value === 'undefined' ? null : value;\n  }\n}\n\n\n/**\n * @param {string} str .\n * @return {?} .\n */\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (ignored) {\n    // Do nothing.\n  }\n}\n\n\n/**\n * Callback used to parse {@link Response} objects from a\n * {@link HttpClient}.\n *\n * @param {!cmd.Command} command The command the response is for.\n * @param {!Response} httpResponse The HTTP response to parse.\n * @return {{isW3C: boolean, value: ?}} An object describing the parsed\n *     response. This object will have two fields: `isW3C` indicates whether\n *     the response looks like it came from a remote end that conforms with the\n *     W3C WebDriver spec, and `value`, the actual response value.\n * @throws {WebDriverError} If the HTTP response is an error.\n */\nfunction parseHttpResponse(command, httpResponse) {\n  if (httpResponse.status < 200) {\n    // This should never happen, but throw the raw response so users report it.\n    throw new error.WebDriverError(\n        `Unexpected HTTP response:\\n${httpResponse}`);\n  }\n\n  let parsed = tryParse(httpResponse.body);\n  if (parsed && typeof parsed === 'object') {\n    let value = parsed.value;\n    let isW3C =\n        value !== null && typeof value === 'object'\n            && typeof parsed.status === 'undefined';\n\n    if (!isW3C) {\n      error.checkLegacyResponse(parsed);\n\n      // Adjust legacy new session responses to look like W3C to simplify\n      // later processing.\n      if (command.getName() === cmd.Name.NEW_SESSION) {\n        value = parsed;\n      }\n\n    } else if (httpResponse.status > 399) {\n      error.throwDecodedError(value);\n    }\n\n    return {isW3C, value};\n  }\n\n  if (parsed !== undefined) {\n    return {isW3C: false, value: parsed};\n  }\n\n  let value = httpResponse.body.replace(/\\r\\n/g, '\\n');\n\n  // 404 represents an unknown command; anything else > 399 is a generic unknown\n  // error.\n  if (httpResponse.status == 404) {\n    throw new error.UnsupportedOperationError(value);\n  } else if (httpResponse.status >= 400) {\n    throw new error.WebDriverError(value);\n  }\n\n  return {isW3C: false, value: value || null};\n}\n\n\n/**\n * Builds a fully qualified path using the given set of command parameters. Each\n * path segment prefixed with ':' will be replaced by the value of the\n * corresponding parameter. All parameters spliced into the path will be\n * removed from the parameter map.\n * @param {string} path The original resource path.\n * @param {!Object<*>} parameters The parameters object to splice into the path.\n * @return {string} The modified path.\n */\nfunction buildPath(path, parameters) {\n  let pathParameters = path.match(/\\/:(\\w+)\\b/g);\n  if (pathParameters) {\n    for (let i = 0; i < pathParameters.length; ++i) {\n      let key = pathParameters[i].substring(2);  // Trim the /:\n      if (key in parameters) {\n        let value = parameters[key];\n        if (WebElement.isId(value)) {\n          // When inserting a WebElement into the URL, only use its ID value,\n          // not the full JSON.\n          value = WebElement.extractId(value);\n        }\n        path = path.replace(pathParameters[i], '/' + value);\n        delete parameters[key];\n      } else {\n        throw new error.InvalidArgumentError(\n            'Missing required parameter: ' + key);\n      }\n    }\n  }\n  return path;\n}\n\n\n// PUBLIC API\n\nexports.Executor = Executor;\nexports.Client = Client;\nexports.Request = Request;\nexports.Response = Response;\nexports.buildPath = buildPath;  // Exported for testing.\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/http.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/input.js":
/*!*******************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/input.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\n/**\n * @fileoverview Defines types related to user input with the WebDriver API.\n */\n\nconst promise = __webpack_require__(/*! ./promise */ \"../node_modules/selenium-webdriver/lib/promise.js\");\nconst {Command, Executor, Name} = __webpack_require__(/*! ./command */ \"../node_modules/selenium-webdriver/lib/command.js\");\nconst {\n  InvalidArgumentError,\n  UnknownCommandError,\n  UnsupportedOperationError\n} = __webpack_require__(/*! ./error */ \"../node_modules/selenium-webdriver/lib/error.js\");\n\n/**\n * Enumeration of the buttons used in the advanced interactions API.\n * @enum {number}\n */\nconst Button = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2\n};\n\n\n\n/**\n * Representations of pressable keys that aren't text.  These are stored in\n * the Unicode PUA (Private Use Area) code points, 0xE000-0xF8FF.  Refer to\n * http://www.google.com.au/search?&q=unicode+pua&btnK=Search\n *\n * @enum {string}\n * @see <https://www.w3.org/TR/webdriver/#keyboard-actions>\n */\nconst Key = {\n  NULL:         '\\uE000',\n  CANCEL:       '\\uE001',  // ^break\n  HELP:         '\\uE002',\n  BACK_SPACE:   '\\uE003',\n  TAB:          '\\uE004',\n  CLEAR:        '\\uE005',\n  RETURN:       '\\uE006',\n  ENTER:        '\\uE007',\n  SHIFT:        '\\uE008',\n  CONTROL:      '\\uE009',\n  ALT:          '\\uE00A',\n  PAUSE:        '\\uE00B',\n  ESCAPE:       '\\uE00C',\n  SPACE:        '\\uE00D',\n  PAGE_UP:      '\\uE00E',\n  PAGE_DOWN:    '\\uE00F',\n  END:          '\\uE010',\n  HOME:         '\\uE011',\n  ARROW_LEFT:   '\\uE012',\n  LEFT:         '\\uE012',\n  ARROW_UP:     '\\uE013',\n  UP:           '\\uE013',\n  ARROW_RIGHT:  '\\uE014',\n  RIGHT:        '\\uE014',\n  ARROW_DOWN:   '\\uE015',\n  DOWN:         '\\uE015',\n  INSERT:       '\\uE016',\n  DELETE:       '\\uE017',\n  SEMICOLON:    '\\uE018',\n  EQUALS:       '\\uE019',\n\n  NUMPAD0:      '\\uE01A',  // number pad keys\n  NUMPAD1:      '\\uE01B',\n  NUMPAD2:      '\\uE01C',\n  NUMPAD3:      '\\uE01D',\n  NUMPAD4:      '\\uE01E',\n  NUMPAD5:      '\\uE01F',\n  NUMPAD6:      '\\uE020',\n  NUMPAD7:      '\\uE021',\n  NUMPAD8:      '\\uE022',\n  NUMPAD9:      '\\uE023',\n  MULTIPLY:     '\\uE024',\n  ADD:          '\\uE025',\n  SEPARATOR:    '\\uE026',\n  SUBTRACT:     '\\uE027',\n  DECIMAL:      '\\uE028',\n  DIVIDE:       '\\uE029',\n\n  F1:           '\\uE031',  // function keys\n  F2:           '\\uE032',\n  F3:           '\\uE033',\n  F4:           '\\uE034',\n  F5:           '\\uE035',\n  F6:           '\\uE036',\n  F7:           '\\uE037',\n  F8:           '\\uE038',\n  F9:           '\\uE039',\n  F10:          '\\uE03A',\n  F11:          '\\uE03B',\n  F12:          '\\uE03C',\n\n  COMMAND:      '\\uE03D',  // Apple command key\n  META:         '\\uE03D',  // alias for Windows key\n\n  /**\n   * Japanese modifier key for switching between full- and half-width\n   * characters.\n   * @see <https://en.wikipedia.org/wiki/Language_input_keys>\n   */\n  ZENKAKU_HANKAKU: '\\uE040',\n};\n\n\n/**\n * Simulate pressing many keys at once in a \"chord\". Takes a sequence of\n * {@linkplain Key keys} or strings, appends each of the values to a string,\n * adds the chord termination key ({@link Key.NULL}) and returns the resulting\n * string.\n *\n * Note: when the low-level webdriver key handlers see Keys.NULL, active\n * modifier keys (CTRL/ALT/SHIFT/etc) release via a keyup event.\n *\n * @param {...string} keys The key sequence to concatenate.\n * @return {string} The null-terminated key sequence.\n */\nKey.chord = function(...keys) {\n  return keys.join('') + Key.NULL;\n};\n\n\n/**\n * Used with {@link ./webelement.WebElement#sendKeys WebElement#sendKeys} on\n * file input elements (`<input type=\"file\">`) to detect when the entered key\n * sequence defines the path to a file.\n *\n * By default, {@linkplain ./webelement.WebElement WebElement's} will enter all\n * key sequences exactly as entered. You may set a\n * {@linkplain ./webdriver.WebDriver#setFileDetector file detector} on the\n * parent WebDriver instance to define custom behavior for handling file\n * elements. Of particular note is the\n * {@link selenium-webdriver/remote.FileDetector}, which should be used when\n * running against a remote\n * [Selenium Server](http://docs.seleniumhq.org/download/).\n */\nclass FileDetector {\n\n  /**\n   * Handles the file specified by the given path, preparing it for use with\n   * the current browser. If the path does not refer to a valid file, it will\n   * be returned unchanged, otherwise a path suitable for use with the current\n   * browser will be returned.\n   *\n   * This default implementation is a no-op. Subtypes may override this function\n   * for custom tailored file handling.\n   *\n   * @param {!./webdriver.WebDriver} driver The driver for the current browser.\n   * @param {string} path The path to process.\n   * @return {!Promise<string>} A promise for the processed file path.\n   * @package\n   */\n  handleFile(driver, path) {\n    return Promise.resolve(path);\n  }\n}\n\n\n/**\n * Generic description of a single action to send to the remote end.\n *\n * @record\n * @package\n */\nclass Action {\n  constructor() {\n    /** @type {!Action.Type} */\n    this.type;\n    /** @type {(number|undefined)} */\n    this.duration;\n    /** @type {(string|undefined)} */\n    this.value;\n    /** @type {(Button|undefined)} */\n    this.button;\n    /** @type {(number|undefined)} */\n    this.x;\n    /** @type {(number|undefined)} */\n    this.y;\n  }\n}\n\n\n/**\n * @enum {string}\n * @package\n * @see <https://w3c.github.io/webdriver/webdriver-spec.html#terminology-0>\n */\nAction.Type = {\n  KEY_DOWN: 'keyDown',\n  KEY_UP: 'keyUp',\n  PAUSE: 'pause',\n  POINTER_DOWN: 'pointerDown',\n  POINTER_UP: 'pointerUp',\n  POINTER_MOVE: 'pointerMove',\n  POINTER_CANCEL: 'pointerCancel'\n};\n\n\n/**\n * Represents a user input device.\n *\n * @abstract\n */\nclass Device {\n  /**\n   * @param {Device.Type} type the input type.\n   * @param {string} id a unique ID for this device.\n   */\n  constructor(type, id) {\n    /** @private @const */ this.type_ = type;\n    /** @private @const */ this.id_ = id;\n  }\n\n  /** @return {!Object} the JSON encoding for this device. */\n  toJSON() {\n    return {'type': this.type_, 'id': this.id_};\n  }\n}\n\n\n/**\n * Device types supported by the WebDriver protocol.\n *\n * @enum {string}\n * @see <https://w3c.github.io/webdriver/webdriver-spec.html#input-source-state>\n */\nDevice.Type = {\n  KEY: 'key',\n  NONE: 'none',\n  POINTER: 'pointer'\n};\n\n\n/**\n * @param {(string|Key|number)} key\n * @return {string}\n * @throws {!(InvalidArgumentError|RangeError)}\n */\nfunction checkCodePoint(key) {\n  if (typeof key === 'number') {\n    return String.fromCodePoint(key);\n  }\n\n  if (typeof key !== 'string') {\n    throw new InvalidArgumentError(`key is not a string: ${key}`);\n  }\n\n  key = key.normalize();\n  if (Array.from(key).length != 1) {\n    throw new InvalidArgumentError(\n        `key input is not a single code point: ${key}`);\n  }\n  return key;\n}\n\n\n/**\n * Keyboard input device.\n *\n * @final\n * @see <https://www.w3.org/TR/webdriver/#dfn-key-input-source>\n */\nclass Keyboard extends Device {\n  /** @param {string} id the device ID. */\n  constructor(id) {\n    super(Device.Type.KEY, id);\n  }\n\n  /**\n   * Generates a key down action.\n   *\n   * @param {(Key|string|number)} key the key to press. This key may be\n   *     specified as a {@link Key} value, a specific unicode code point,\n   *     or a string containing a single unicode code point.\n   * @return {!Action} a new key down action.\n   * @package\n   */\n  keyDown(key) {\n    return {type: Action.Type.KEY_DOWN, value: checkCodePoint(key)};\n  }\n\n  /**\n   * Generates a key up action.\n   *\n   * @param {(Key|string|number)} key the key to press. This key may be\n   *     specified as a {@link Key} value, a specific unicode code point,\n   *     or a string containing a single unicode code point.\n   * @return {!Action} a new key up action.\n   * @package\n   */\n  keyUp(key) {\n    return {type: Action.Type.KEY_UP, value: checkCodePoint(key)};\n  }\n}\n\n\n/**\n * Defines the reference point from which to compute offsets for\n * {@linkplain ./input.Pointer#move pointer move} actions.\n *\n * @enum {string}\n */\nconst Origin = {\n  /** Compute offsets relative to the pointer's current position. */\n  POINTER: 'pointer',\n  /** Compute offsets relative to the viewport. */\n  VIEWPORT: 'viewport'\n};\n\n\n/**\n * Pointer input device.\n *\n * @final\n * @see <https://www.w3.org/TR/webdriver/#dfn-pointer-input-source>\n */\nclass Pointer extends Device {\n  /**\n   * @param {string} id the device ID.\n   * @param {Pointer.Type} type the pointer type.\n   */\n  constructor(id, type) {\n    super(Device.Type.POINTER, id);\n    /** @private @const */ this.pointerType_ = type;\n  }\n\n  /** @override */\n  toJSON() {\n    return Object.assign(\n        {'parameters': {'pointerType': this.pointerType_}},\n        super.toJSON());\n  }\n\n  /**\n   * @return {!Action} An action that cancels this pointer's current input.\n   * @package\n   */\n  cancel() {\n    return {type: Action.Type.POINTER_CANCEL};\n  }\n\n  /**\n   * @param {!Button=} button The button to press.\n   * @return {!Action} An action to press the specified button with this device.\n   * @package\n   */\n  press(button = Button.LEFT) {\n    return {type: Action.Type.POINTER_DOWN, button};\n  }\n\n  /**\n   * @param {!Button=} button The button to release.\n   * @return {!Action} An action to release the specified button with this\n   *     device.\n   * @package\n   */\n  release(button = Button.LEFT) {\n    return {type: Action.Type.POINTER_UP, button};\n  }\n\n  /**\n   * Creates an action for moving the pointer `x` and `y` pixels from the\n   * specified `origin`. The `origin` may be defined as the pointer's\n   * {@linkplain Origin.POINTER current position}, the\n   * {@linkplain Origin.VIEWPORT viewport}, or the center of a specific\n   * {@linkplain ./webdriver.WebElement WebElement}.\n   *\n   * @param {{\n   *   x: (number|undefined),\n   *   y: (number|undefined),\n   *   duration: (number|undefined),\n   *   origin: (!Origin|!./webdriver.WebElement|undefined),\n   * }=} options the move options.\n   * @return {!Action} The new action.\n   * @package\n   */\n  move({x = 0, y = 0, duration = 100, origin = Origin.VIEWPORT}) {\n    return {type: Action.Type.POINTER_MOVE, origin, duration, x, y};\n  }\n}\n\n\n/**\n * The supported types of pointers.\n * @enum {string}\n */\nPointer.Type = {\n  MOUSE: 'mouse',\n  PEN: 'pen',\n  TOUCH: 'touch'\n};\n\n\n/**\n * User facing API for generating complex user gestures. This class should not\n * be instantiated directly. Instead, users should create new instances by\n * calling {@link ./webdriver.WebDriver#actions WebDriver.actions()}.\n *\n * ### Action Ticks\n *\n * Action sequences are divided into a series of \"ticks\". At each tick, the\n * WebDriver remote end will perform a single action for each device included\n * in the action sequence. At tick 0, the driver will perform the first action\n * defined for each device, at tick 1 the second action for each device, and\n * so on until all actions have been executed. If an individual device does\n * not have an action defined at a particular tick, it will automatically\n * pause.\n *\n * By default, action sequences will be synchronized so only one device has a\n * define action in each tick. Consider the following code sample:\n *\n *     const actions = driver.actions();\n *\n *     await actions\n *         .keyDown(SHIFT)\n *         .move({origin: el})\n *         .press()\n *         .release()\n *         .keyUp(SHIFT)\n *         .perform();\n *\n * This sample produces the following sequence of ticks:\n *\n * | Device   | Tick 1         | Tick 2             | Tick 3  | Tick 4    | Tick 5       |\n * | -------- | -------------- | ------------------ | ------- | --------- | ------------ |\n * | Keyboard | keyDown(SHIFT) | pause()            | pause() | pause()   | keyUp(SHIFT) |\n * | Mouse    | pause()        | move({origin: el}) | press() | release() | pause()      |\n *\n * If you'd like the remote end to execute actions with multiple devices\n * simultaneously, you may pass `{async: true}` when creating the actions\n * builder. With synchronization disabled (`{async: true}`), the ticks from our\n * previous example become:\n *\n * | Device   | Tick 1             | Tick 2       | Tick 3    |\n * | -------- | ------------------ | ------------ | --------- |\n * | Keyboard | keyDown(SHIFT)     | keyUp(SHIFT) |           |\n * | Mouse    | move({origin: el}) | press()      | release() |\n *\n * When synchronization is disabled, it is your responsibility to insert\n * {@linkplain #pause() pauses} for each device, as needed:\n *\n *     const actions = driver.actions({async: true});\n *     const kb = actions.keyboard();\n *     const mouse = actions.mouse();\n *\n *     actions.keyDown(SHIFT).pause(kb).pause(kb).key(SHIFT);\n *     actions.pause(mouse).move({origin: el}).press().release();\n *     actions.perform();\n *\n * With pauses insert for individual devices, we're back to:\n *\n * | Device   | Tick 1         | Tick 2             | Tick 3  | Tick 4       |\n * | -------- | -------------- | ------------------ | ------- | ------------ |\n * | Keyboard | keyDown(SHIFT) | pause()            | pause() | keyUp(SHIFT) |\n * | Mouse    | pause()        | move({origin: el}) | press() | release()    |\n *\n * #### Tick Durations\n *\n * The length of each action tick is however long it takes the remote end to\n * execute the actions for every device in that tick. Most actions are\n * \"instaneous\", however, {@linkplain #pause pause} and\n * {@linkplain #move pointer move} actions allow you to specify a duration for\n * how long that action should take. The remote end will always wait for all\n * actions within a tick to finish before starting the next tick, so a device\n * may implicitly pause while waiting for other devices to finish.\n *\n * | Device    | Tick 1                | Tick 2  |\n * | --------- | --------------------- | ------- |\n * | Pointer 1 | move({duration: 200}) | press() |\n * | Pointer 2 | move({duration: 300}) | press() |\n *\n * In table above, the move for Pointer 1 should only take 200 ms, but the\n * remote end will wait for the move for Pointer 2 to finish\n * (an additional 100 ms) before proceeding to Tick 2.\n *\n * This implicit waiting also applies to pauses. In the table below, even though\n * the keyboard only defines a pause of 100 ms, the remote end will wait an\n * additional 200 ms for the mouse mmove to finish before moving to Tick 2.\n *\n * | Device   | Tick 1                | Tick 2         |\n * | -------- | --------------------- | -------------- |\n * | Keyboard | pause(100)            | keyDown(SHIFT) |\n * | Mouse    | move({duration: 300}) |                |\n *\n *\n * #### Bridge Mode\n *\n * As of January 2018, only Firefox natively supports this API. For other\n * browsers, you may either use the\n * {@link ./actions.LegacyActionSequence LegacyActionSequence} class, _or_ you\n * can put the Actions class into bridge mode by passing `{bridge: true}` on\n * creation:\n *\n *     const actions = driver.actions({bridge: true});\n *     await actions.click(element).sendKeys('abc').perform();\n *\n * In bridge mode, {@link #perform perform()} will first attempt to execute the\n * configured action sequence using the W3C action protocol. If this is rejected\n * by the remote end, the sequence will be translated to and executed against\n * the legacy protocol.\n *\n * Bridge mode __is not enabled by default__ as there are several notable\n * differences between W3C-specified and legacy protocols. Care must be\n * taken to configure your action sequences to account for these differences:\n *\n * 1.  For W3C actions, the entire action sequence is executed in a single\n *     call to the remote end. For legacy sequences, multiple calls must be\n *     made for each step in the sequence. This introduces additional latency\n *     which may impact how the browser responds to the emulated user actions.\n *\n * 2.  For the legacy actions, {@linkplain #pause pauses} are handled _locally_.\n *\n * 3.  For legacy actions, a {@linkplain #keyDown keyDown()} for a\n *     _non-modifier key_ **must** be followed by a {@linkplain #keyUP keyUp()}\n *     for the same key. This will be handled for you if you use the\n *     {@linkplain #sendKeys sendKeys()} method.\n *\n * 4.  Mouse movements may not be specified relative to\n *     {@linkplain ./input.Origin.VIEWPORT Origin.VIEWPORT}.\n *     All movements must be relative to an element or the mouse's current\n *     position ({@linkplain ./input.Origin.POINTER Origin.POINTER}).\n *     The {@linkplain #move move()} method defaults to viewport relative\n *     offsets, so you must always specify an appropriate origin in bridge mode:\n *\n *         driver.actions({bridge: true})\n *             .move({x: 0, y: 0, origin: Origin.POINTER})\n *             .perform();\n *         driver.actions({bridge: true})\n *             .move({x: 0, y: 0, origin: someWebElement})\n *             .perform();\n *\n * 5.  The legacy protocol does not support specifying the duration of a\n *     {@linkplain #move mouse movement}; any specified duration _is ignored_\n *     when translating actions to the legacy protocol.\n *\n * 6.  For W3C actions, move offsets relative to a\n *     {@linkplain ./webdriver.WebElement WebElement} are interpretted relative\n *     to the center of an element's _first_ [client rect] in the viewport. For\n *     legacy actions, element offsets are relative to the top-left corner of\n *     the element's [bounding client rect]. When translating actions to the\n *     legacy protocol in bridge mode, an extra command must be inserted to\n *     translate move offsets from one frame of reference to the other. This\n *     extra command conributes to the overall latency issue outlined in\n *     point 1.\n *\n * [client rect]: https://developer.mozilla.org/en-US/docs/Web/API/Element/getClientRects\n * [bounding client rect]: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n *\n * @final\n * @see <https://www.w3.org/TR/webdriver/#actions>\n */\nclass Actions {\n  /**\n   * @param {!Executor} executor The object to execute the configured\n   *     actions with.\n   * @param {{async: (boolean|undefined),\n   *          bridge: (boolean|undefined)}} options Options for this action\n   *     sequence (see class description for details).\n   */\n  constructor(executor, {async = false, bridge = false} = {}) {\n    if (async && bridge) {\n      throw new InvalidArgumentError(\n          'Async sequences not supported with bridge mode');\n    }\n\n    /** @private @const */\n    this.executor_ = executor;\n\n    /** @private @const */\n    this.sync_ = !async;\n\n    /** @private @const */\n    this.bridge_ = !!bridge;\n\n    /** @private @const */\n    this.keyboard_ = new Keyboard('default keyboard');\n\n    /** @private @const */\n    this.mouse_ = new Pointer('default mouse', Pointer.Type.MOUSE);\n\n    /** @private @const {!Map<!Device, !Array<!Action>>} */\n    this.sequences_ = new Map([\n      [this.keyboard_, []],\n      [this.mouse_, []],\n    ]);\n  }\n\n\n  /** @return {!Keyboard} the keyboard device handle. */\n  keyboard() {\n    return this.keyboard_;\n  }\n\n  /** @return {!Pointer} the mouse pointer device handle. */\n  mouse() {\n    return this.mouse_;\n  }\n\n  /**\n   * @param {!Device} device\n   * @return {!Array<!Action>}\n   * @private\n   */\n  sequence_(device) {\n    let sequence = this.sequences_.get(device);\n    if (!sequence) {\n      sequence = [];\n      this.sequences_.set(device, sequence);\n    }\n    return sequence;\n  }\n\n  /**\n   * Appends `actions` to the end of the current sequence for the given\n   * `device`. If device synchronization is enabled, after inserting the\n   * actions, pauses will be inserted for all other devices to ensure all action\n   * sequences are the same length.\n   *\n   * @param {!Device} device the device to update.\n   * @param {...!Action} actions the actions to insert.\n   * @return {!Actions} a self reference.\n   */\n  insert(device, ...actions) {\n    this.sequence_(device).push(...actions);\n    return this.sync_ ? this.synchronize() : this;\n  }\n\n  /**\n   * Ensures the action sequence for every device referenced in this action\n   * sequence is the same length. For devices whose sequence is too short,\n   * this will insert {@linkplain #pause pauses} so that every device has an\n   * explicit action defined at each tick.\n   *\n   * @param {...!Device} devices The specific devices to synchronize.\n   *     If unspecified, the action sequences for every device will be\n   *     synchronized.\n   * @return {!Actions} a self reference.\n   */\n  synchronize(...devices) {\n    let sequences;\n    let max = 0;\n    if (devices.length === 0) {\n      for (const s of this.sequences_.values()) {\n        max = Math.max(max, s.length);\n      }\n      sequences = this.sequences_.values();\n    } else {\n      sequences = [];\n      for (const device of devices) {\n        const seq = this.sequence_(device);\n        max = Math.max(max, seq.length);\n        sequences.push(seq);\n      }\n    }\n\n    const pause = {type: Action.Type.PAUSE, duration: 0};\n    for (const seq of sequences) {\n      while (seq.length < max) {\n        seq.push(pause);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Inserts a pause action for the specified devices, ensuring each device is\n   * idle for a tick. The length of the pause (in milliseconds) may be specified\n   * as the first parameter to this method (defaults to 0). Otherwise, you may\n   * just specify the individual devices that should pause.\n   *\n   * If no devices are specified, a pause action will be created (using the same\n   * duration) for every device.\n   *\n   * When device synchroniation is enabled (the default for new {@link Actions}\n   * objects), there is no need to specify devices as pausing one automatically\n   * pauses the others for the same duration. In other words, the following are\n   * all equivalent:\n   *\n   *     let a1 = driver.actions();\n   *     a1.pause(100).perform();\n   *\n   *     let a2 = driver.actions();\n   *     a2.pause(100, a2.keyboard()).perform();\n   *     // Synchronization ensures a2.mouse() is automatically paused too.\n   *\n   *     let a3 = driver.actions();\n   *     a3.pause(100, a3.keyboard(), a3.mouse()).perform();\n   *\n   * When device synchronization is _disabled_, you can cause individual devices\n   * to pause during a tick. For example, to hold the SHIFT key down while\n   * moving the mouse:\n   *\n   *     let actions = driver.actions({async: true});\n   *\n   *     actions.keyDown(Key.SHIFT);\n   *     actions.pause(actions.mouse())  // Pause for shift down\n   *         .press(Button.LEFT)\n   *         .move({x: 10, y: 10})\n   *         .release(Button.LEFT);\n   *     actions\n   *         .pause(\n   *             actions.keyboard(),  // Pause for press left\n   *             actions.keyboard(),  // Pause for move\n   *             actions.keyboard())  // Pause for release left\n   *        .keyUp(Key.SHIFT);\n   *     await actions.perform();\n   *\n   * @param {(number|!Device)=} duration The length of the pause to insert, in\n   *     milliseconds. Alternatively, the duration may be omitted (yielding a\n   *     default 0 ms pause), and the first device to pause may be specified.\n   * @param {...!Device} devices The devices to insert the pause for. If no\n   *     devices are specified, the pause will be inserted for _all_ devices.\n   * @return {!Actions} a self reference.\n   */\n  pause(duration, ...devices) {\n    if (duration instanceof Device) {\n      devices.push(duration);\n      duration = 0;\n    } else if (!duration) {\n      duration = 0;\n    }\n\n    const action = {type: Action.Type.PAUSE, duration};\n\n    // NB: need a properly typed variable for type checking.\n    /** @type {!Iterable<!Device>} */\n    const iterable = devices.length === 0 ? this.sequences_.keys() : devices;\n    for (const device of iterable) {\n      this.sequence_(device).push(action);\n    }\n    return this.sync_ ? this.synchronize() : this;\n  }\n\n  /**\n   * Inserts an action to press a single key.\n   *\n   * @param {(Key|string|number)} key the key to press. This key may be\n   *     specified as a {@link Key} value, a specific unicode code point,\n   *     or a string containing a single unicode code point.\n   * @return {!Actions} a self reference.\n   */\n  keyDown(key) {\n    return this.insert(this.keyboard_, this.keyboard_.keyDown(key));\n  }\n\n  /**\n   * Inserts an action to release a single key.\n   *\n   * @param {(Key|string|number)} key the key to release. This key may be\n   *     specified as a {@link Key} value, a specific unicode code point,\n   *     or a string containing a single unicode code point.\n   * @return {!Actions} a self reference.\n   */\n  keyUp(key) {\n    return this.insert(this.keyboard_, this.keyboard_.keyUp(key));\n  }\n\n  /**\n   * Inserts a sequence of actions to type the provided key sequence.\n   * For each key, this will record a pair of {@linkplain #keyDown keyDown}\n   * and {@linkplain #keyUp keyUp} actions. An implication of this pairing\n   * is that modifier keys (e.g. {@link ./input.Key.SHIFT Key.SHIFT}) will\n   * always be immediately released. In other words, `sendKeys(Key.SHIFT, 'a')`\n   * is the same as typing `sendKeys('a')`, _not_ `sendKeys('A')`.\n   *\n   * @param {...(Key|string|number)} keys the keys to type.\n   * @return {!Actions} a self reference.\n   */\n  sendKeys(...keys) {\n    const actions = [];\n    for (const key of keys) {\n      if (typeof key === 'string') {\n        for (const symbol of key) {\n          actions.push(\n              this.keyboard_.keyDown(symbol),\n              this.keyboard_.keyUp(symbol));\n        }\n      } else {\n        actions.push(\n            this.keyboard_.keyDown(key),\n            this.keyboard_.keyUp(key));\n      }\n    }\n    return this.insert(this.keyboard_, ...actions);\n  }\n\n  /**\n   * Inserts an action to press a mouse button at the mouse's current location.\n   *\n   * @param {!Button=} button The button to press; defaults to `LEFT`.\n   * @return {!Actions} a self reference.\n   */\n  press(button = Button.LEFT) {\n    return this.insert(this.mouse_, this.mouse_.press(button));\n  }\n\n  /**\n   * Inserts an action to release a mouse button at the mouse's current\n   * location.\n   *\n   * @param {!Button=} button The button to release; defaults to `LEFT`.\n   * @return {!Actions} a self reference.\n   */\n  release(button = Button.LEFT) {\n    return this.insert(this.mouse_, this.mouse_.release(button));\n  }\n\n  /**\n   * Inserts an action for moving the mouse `x` and `y` pixels relative to the\n   * specified `origin`. The `origin` may be defined as the mouse's\n   * {@linkplain ./input.Origin.POINTER current position}, the\n   * {@linkplain ./input.Origin.VIEWPORT viewport}, or the center of a specific\n   * {@linkplain ./webdriver.WebElement WebElement}.\n   *\n   * You may adjust how long the remote end should take, in milliseconds, to\n   * perform the move using the `duration` parameter (defaults to 100 ms).\n   * The number of incremental move events generated over this duration is an\n   * implementation detail for the remote end.\n   *\n   * @param {{\n   *   x: (number|undefined),\n   *   y: (number|undefined),\n   *   duration: (number|undefined),\n   *   origin: (!Origin|!./webdriver.WebElement|undefined),\n   * }=} options The move options. Defaults to moving the mouse to the top-left\n   *     corner of the viewport over 100ms.\n   * @return {!Actions} a self reference.\n   */\n  move({x = 0, y = 0, duration = 100, origin = Origin.VIEWPORT} = {}) {\n    return this.insert(\n        this.mouse_, this.mouse_.move({x, y, duration, origin}));\n  }\n\n  /**\n   * Short-hand for performing a simple left-click (down/up) with the mouse.\n   *\n   * @param {./webdriver.WebElement=} element If specified, the mouse will\n   *     first be moved to the center of the element before performing the\n   *     click.\n   * @return {!Actions} a self reference.\n   */\n  click(element) {\n    if (element) {\n      this.move({origin: element});\n    }\n    return this.press().release();\n  }\n\n  /**\n   * Short-hand for performing a simple right-click (down/up) with the mouse.\n   *\n   * @param {./webdriver.WebElement=} element If specified, the mouse will\n   *     first be moved to the center of the element before performing the\n   *     click.\n   * @return {!Actions} a self reference.\n   */\n  contextClick(element) {\n    if (element) {\n      this.move({origin: element});\n    }\n    return this.press(Button.RIGHT).release(Button.RIGHT);\n  }\n\n  /**\n   * Short-hand for performing a double left-click with the mouse.\n   *\n   * @param {./webdriver.WebElement=} element If specified, the mouse will\n   *     first be moved to the center of the element before performing the\n   *     click.\n   * @return {!Actions} a self reference.\n   */\n  doubleClick(element) {\n    return this.click(element).press().release();\n  }\n\n  /**\n   * Configures a drag-and-drop action consisting of the following steps:\n   *\n   * 1.  Move to the center of the `from` element (element to be dragged).\n   * 2.  Press the left mouse button.\n   * 3.  If the `to` target is a {@linkplain ./webdriver.WebElement WebElement},\n   *     move the mouse to its center. Otherwise, move the mouse by the\n   *     specified offset.\n   * 4.  Releae the left mouse button.\n   *\n   * @param {!./webdriver.WebElement} from The element to press the left mouse\n   *     button on to start the drag.\n   * @param {(!./webdriver.WebElement|{x: number, y: number})} to Either another\n   *     element to drag to (will drag to the center of the element), or an\n   *     object specifying the offset to drag by, in pixels.\n   * @return {!Actions} a self reference.\n   */\n  dragAndDrop(from, to) {\n    // Do not require up top to avoid a cycle that breaks static analysis.\n    const {WebElement} = __webpack_require__(/*! ./webdriver */ \"../node_modules/selenium-webdriver/lib/webdriver.js\");\n    if (!(to instanceof WebElement)\n        && (!to || typeof to.x !== 'number' || typeof to.y !== 'number')) {\n      throw new InvalidArgumentError(\n          'Invalid drag target; must specify a WebElement or {x, y} offset');\n    }\n\n    this.move({origin: from}).press();\n    if (to instanceof WebElement) {\n      this.move({origin: to});\n    } else {\n      this.move({x: to.x, y: to.y, origin: Origin.POINTER});\n    }\n    return this.release();\n  }\n\n  /**\n   * Releases all keys, pointers, and clears internal state.\n   *\n   * @return {!Promise<void>} a promise that will resolve when finished\n   *     clearing all action state.\n   */\n  clear() {\n    for (const s of this.sequences_.values()) {\n      s.length = 0;\n    }\n    return this.executor_.execute(new Command(Name.CLEAR_ACTIONS));\n  }\n\n  /**\n   * Performs the configured action sequence.\n   *\n   * @return {!Promise<void>} a promise that will resolve when all actions have\n   *     been completed.\n   */\n  async perform() {\n    const _actions = [];\n    this.sequences_.forEach((actions, device) => {\n      if (!isIdle(actions)) {\n        actions = actions.concat();  // Defensive copy.\n        _actions.push(Object.assign({actions}, device.toJSON()));\n      }\n    });\n\n    if (_actions.length === 0) {\n      return Promise.resolve();\n    }\n\n    try {\n      await this.executor_.execute(\n          new Command(Name.ACTIONS).setParameter('actions', _actions));\n    } catch (ex) {\n      if (this.bridge_\n          && (ex instanceof UnknownCommandError\n              || ex instanceof UnsupportedOperationError)) {\n        return executeLegacy(this.executor_, this.sequences_);\n      }\n      throw ex;\n    }\n  }\n}\n\n\n/**\n * @param {!Array<!Action>} actions\n * @return {boolean}\n */\nfunction isIdle(actions) {\n  return actions.length === 0\n      || actions.every(a => a.type === Action.Type.PAUSE && !a.duration);\n}\n\n\nconst MODIFIER_KEYS = new Set([Key.ALT, Key.CONTROL, Key.SHIFT, Key.COMMAND]);\n\n\n/**\n * @param {!Executor} executor\n * @param {!Map<!Device, !Array<!Action>>} sequences\n * @return {!Promise<void>}\n * @suppress {deprecated} Ignore warnings about using LegacyActionSequence.\n */\nasync function executeLegacy(executor, sequences) {\n  let maxLength = 0;\n  sequences.forEach(seq => maxLength = Math.max(maxLength, seq.length));\n\n  const actions = [];\n  for (let i = 0; i < maxLength; i++) {\n    let next;\n    for (const device of sequences.keys()) {\n      const seq = sequences.get(device);\n\n      if (device instanceof Pointer\n          && device.pointerType_ !== Pointer.Type.MOUSE) {\n        throw new UnsupportedOperationError(\n            `${device.pointerType_} pointer not supported in bridge mode`);\n      }\n\n      const action = seq[i];\n      if (!action || (action.type === Action.Type.PAUSE && !action.duration)) {\n        continue;\n      }\n\n      // -  If we've already found an action for this tick:\n      //    -  If we have two pauses, use the one with a longer duration\n      //    -  If one is a pause and the other isn't, use the non-pause\n      //    -  Otherwise, two non-pauses is an error.\n      // - Otherwise, we haven't selected an action yet.\n      if (next) {\n        if (next.type === Action.Type.PAUSE) {\n          if (action.type === Action.Type.PAUSE) {\n            next = next.duration > action.duration ? next : action;\n          } else {\n            next = action;\n          }\n        } else if (action.type !== Action.Type.PAUSE) {\n          throw new UnsupportedOperationError(\n              'parallel actions not supported in bridge mode');\n        }\n      } else {\n        next = action;\n      }\n\n      if (action.type === Action.Type.KEY_DOWN) {\n        // If this action is a keydown for a non-modifier key, the next action\n        // must be a keyup for the same key, otherwise it cannot be translated\n        // to the legacy action API.\n        if (!MODIFIER_KEYS.has(action.value)) {\n          const nextAction = seq[i + 1];\n          if (!nextAction\n              || nextAction.type !== Action.Type.KEY_UP\n              || nextAction.value !== action.value) {\n            throw new UnsupportedOperationError(\n                `in bridge mode, keydown for <${action.value}> must be followed`\n                    + ' by a keyup for the same key');\n          }\n        }\n      } else if (action.type === Action.Type.KEY_UP\n          && !MODIFIER_KEYS.has(action.value)) {\n        next = null;\n      }\n    }\n\n    if (next) {\n      actions.push(next);\n    }\n  }\n\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i];\n    switch (action.type) {\n      case Action.Type.PAUSE:\n        await promise.delayed(action.duration || 0);\n        break;\n      case Action.Type.KEY_DOWN:\n        const keys = [action.value];\n        if (!MODIFIER_KEYS.has(action.value)) {\n          function nextIsKeyDown() {\n            const next = actions[i + 1];\n            return !!next\n                && next.type === Action.Type.KEY_DOWN\n                && !MODIFIER_KEYS.has(next.value);\n          }\n          for (; nextIsKeyDown(); i++) {\n            keys.push(actions[i + 1].value);\n          }\n        }\n        await executor.execute(\n            new Command(Name.LEGACY_ACTION_SEND_KEYS)\n                .setParameter('value', keys));\n        break;\n      case Action.Type.KEY_UP:\n        await executor.execute(\n            new Command(Name.LEGACY_ACTION_SEND_KEYS)\n                .setParameter('value', [action.value]));\n        break;\n      case Action.Type.POINTER_DOWN: {\n        function isClick(startAt) {\n          const first = actions[startAt];\n          const second = actions[startAt + 1];\n          return !!first && !!second\n              && first.type === Action.Type.POINTER_DOWN\n              && second.type === Action.Type.POINTER_UP\n              && first.button === second.button;\n        }\n\n        function isDoubleClick(startAt) {\n          return isClick(startAt)\n              && isClick(startAt + 2)\n              && actions[startAt].button === actions[startAt = 2].button;\n        }\n\n        let cmd;\n        if (isDoubleClick(i)) {\n          i += 3;  // Consume the pointer up/down/up.\n          cmd = Name.LEGACY_ACTION_DOUBLE_CLICK;\n        } else  if (isClick(i)) {\n          i++;  // Consume the pointer-up.\n          cmd = Name.LEGACY_ACTION_CLICK;\n        } else {\n          cmd = Name.LEGACY_ACTION_MOUSE_DOWN;\n        }\n        await executor.execute(\n            new Command(cmd).setParameter('button', action.button));\n        break;\n      }\n      case Action.Type.POINTER_UP:\n        await executor.execute(\n            new Command(Name.LEGACY_ACTION_MOUSE_UP)\n                .setParameter('button', action.button));\n        break;\n      case Action.Type.POINTER_MOVE:\n        if (action.origin === Origin.VIEWPORT) {\n          throw new UnsupportedOperationError(\n              `pointer movements relative to ${Origin.VIEWPORT} are not`\n                  + ' supported in bridge mode');\n\n        }\n\n        let x = action.x;\n        let y = action.y;\n        const cmd = new Command(Name.LEGACY_ACTION_MOUSE_MOVE);\n        if (action.origin && action.origin !== Origin.POINTER) {\n          const el = /** @type {!./webdriver.WebElement} */(action.origin);\n\n          // Need to translate frame of reference from center of element's first\n          // client rect to the top-left of its bounding client rect. See:\n          // https://w3c.github.io/webdriver/webdriver-spec.html#dfn-center-point\n          let diff = await executor.execute(\n              new Command(Name.EXECUTE_SCRIPT)\n                  .setParameter('script', INTERNAL_COMPUTE_OFFSET_SCRIPT)\n                  .setParameter('args', [el]));\n          x += diff[0];\n          y += diff[1];\n\n          const id = await el.getId();\n          cmd.setParameter('element', id);\n        }\n        cmd.setParameter('xoffset', x).setParameter('yoffset', y);\n        await executor.execute(cmd);\n        break;\n      default:\n        throw new UnsupportedOperationError(\n            `${action.type} actions not supported in bridge mode`);\n    }\n  }\n}\n\n\n/**\n * Script used to compute the offset from the center of a DOM element's first\n * client rect from the top-left corner of the element's bounding client rect.\n * The element's center point is computed using the algorithm defined here:\n * <https://w3c.github.io/webdriver/webdriver-spec.html#dfn-center-point>.\n *\n * __This is only exported for use in internal unit tests. DO NOT USE.__\n *\n * @package\n */\nconst INTERNAL_COMPUTE_OFFSET_SCRIPT = `\nfunction computeOffset(el) {\n  var rect = el.getClientRects()[0];\n  var left = Math.max(0, Math.min(rect.x, rect.x + rect.width));\n  var right =\n      Math.min(window.innerWidth, Math.max(rect.x, rect.x + rect.width));\n  var top = Math.max(0, Math.min(rect.y, rect.y + rect.height));\n  var bot =\n      Math.min(window.innerHeight, Math.max(rect.y, rect.y + rect.height));\n  var x = Math.floor(0.5 * (left + right));\n  var y = Math.floor(0.5 * (top + bot));\n\n  var bbox = el.getBoundingClientRect();\n  return [x - bbox.left, y - bbox.top];\n}\nreturn computeOffset(arguments[0]);`;\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  Action,       // For documentation only.\n  Actions,\n  Button,\n  Device,\n  Key,\n  Keyboard,\n  FileDetector,\n  Origin,\n  Pointer,\n  INTERNAL_COMPUTE_OFFSET_SCRIPT,\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/input.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/logging.js":
/*!*********************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/logging.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\n/**\n * @fileoverview Defines WebDriver's logging system. The logging system is\n * broken into major components: local and remote logging.\n *\n * The local logging API, which is anchored by the {@linkplain Logger} class is\n * similar to Java's logging API. Loggers, retrieved by\n * {@linkplain #getLogger getLogger(name)}, use hierarchical, dot-delimited\n * namespaces (e.g. \"\" > \"webdriver\" > \"webdriver.logging\"). Recorded log\n * messages are represented by the {@linkplain Entry} class. You can capture log\n * records by {@linkplain Logger#addHandler attaching} a handler function to the\n * desired logger. For convenience, you can quickly enable logging to the\n * console by simply calling {@linkplain #installConsoleHandler\n * installConsoleHandler}.\n *\n * The [remote logging API](https://github.com/SeleniumHQ/selenium/wiki/Logging)\n * allows you to retrieve logs from a remote WebDriver server. This API uses the\n * {@link Preferences} class to define desired log levels prior to creating\n * a WebDriver session:\n *\n *     var prefs = new logging.Preferences();\n *     prefs.setLevel(logging.Type.BROWSER, logging.Level.DEBUG);\n *\n *     var caps = Capabilities.chrome();\n *     caps.setLoggingPrefs(prefs);\n *     // ...\n *\n * Remote log entries, also represented by the {@link Entry} class, may be\n * retrieved via {@link webdriver.WebDriver.Logs}:\n *\n *     driver.manage().logs().get(logging.Type.BROWSER)\n *         .then(function(entries) {\n *            entries.forEach(function(entry) {\n *              console.log('[%s] %s', entry.level.name, entry.message);\n *            });\n *         });\n *\n * **NOTE:** Only a few browsers support the remote logging API (notably\n * Firefox and Chrome). Firefox supports basic logging functionality, while\n * Chrome exposes robust\n * [performance logging](https://sites.google.com/a/chromium.org/chromedriver/logging)\n * options. Remote logging is still considered a non-standard feature, and the\n * APIs exposed by this module for it are non-frozen. This module will be\n * updated, possibly breaking backwards-compatibility, once logging is\n * officially defined by the\n * [W3C WebDriver spec](http://www.w3.org/TR/webdriver/).\n */\n\n/**\n * Defines a message level that may be used to control logging output.\n *\n * @final\n */\nclass Level {\n  /**\n   * @param {string} name the level's name.\n   * @param {number} level the level's numeric value.\n   */\n  constructor(name, level) {\n    if (level < 0) {\n      throw new TypeError('Level must be >= 0');\n    }\n\n    /** @private {string} */\n    this.name_ = name;\n\n    /** @private {number} */\n    this.value_ = level;\n  }\n\n  /** This logger's name. */\n  get name() {\n    return this.name_;\n  }\n\n  /** The numeric log level. */\n  get value() {\n    return this.value_;\n  }\n\n  /** @override */\n  toString() {\n    return this.name;\n  }\n}\n\n/**\n * Indicates no log messages should be recorded.\n * @const\n */\nLevel.OFF = new Level('OFF', Infinity);\n\n\n/**\n * Log messages with a level of `1000` or higher.\n * @const\n */\nLevel.SEVERE = new Level('SEVERE', 1000);\n\n\n/**\n * Log messages with a level of `900` or higher.\n * @const\n */\nLevel.WARNING = new Level('WARNING', 900);\n\n\n/**\n * Log messages with a level of `800` or higher.\n * @const\n */\nLevel.INFO = new Level('INFO', 800);\n\n\n/**\n * Log messages with a level of `700` or higher.\n * @const\n */\nLevel.DEBUG = new Level('DEBUG', 700);\n\n\n/**\n * Log messages with a level of `500` or higher.\n * @const\n */\nLevel.FINE = new Level('FINE', 500);\n\n\n/**\n * Log messages with a level of `400` or higher.\n * @const\n */\nLevel.FINER = new Level('FINER', 400);\n\n\n/**\n * Log messages with a level of `300` or higher.\n * @const\n */\nLevel.FINEST = new Level('FINEST', 300);\n\n\n/**\n * Indicates all log messages should be recorded.\n * @const\n */\nLevel.ALL = new Level('ALL', 0);\n\n\nconst ALL_LEVELS = /** !Set<Level> */new Set([\n  Level.OFF,\n  Level.SEVERE,\n  Level.WARNING,\n  Level.INFO,\n  Level.DEBUG,\n  Level.FINE,\n  Level.FINER,\n  Level.FINEST,\n  Level.ALL\n]);\n\n\nconst LEVELS_BY_NAME = /** !Map<string, !Level> */ new Map([\n  [Level.OFF.name, Level.OFF],\n  [Level.SEVERE.name, Level.SEVERE],\n  [Level.WARNING.name, Level.WARNING],\n  [Level.INFO.name, Level.INFO],\n  [Level.DEBUG.name, Level.DEBUG],\n  [Level.FINE.name, Level.FINE],\n  [Level.FINER.name, Level.FINER],\n  [Level.FINEST.name, Level.FINEST],\n  [Level.ALL.name, Level.ALL]\n]);\n\n\n/**\n * Converts a level name or value to a {@link Level} value. If the name/value\n * is not recognized, {@link Level.ALL} will be returned.\n *\n * @param {(number|string)} nameOrValue The log level name, or value, to\n *     convert.\n * @return {!Level} The converted level.\n */\nfunction getLevel(nameOrValue) {\n  if (typeof nameOrValue === 'string') {\n    return LEVELS_BY_NAME.get(nameOrValue) || Level.ALL;\n  }\n  if (typeof nameOrValue !== 'number') {\n    throw new TypeError('not a string or number');\n  }\n  for (let level of ALL_LEVELS) {\n    if (nameOrValue >= level.value) {\n      return level;\n    }\n  }\n  return Level.ALL;\n}\n\n\n/**\n * Describes a single log entry.\n *\n * @final\n */\nclass Entry {\n  /**\n   * @param {(!Level|string|number)} level The entry level.\n   * @param {string} message The log message.\n   * @param {number=} opt_timestamp The time this entry was generated, in\n   *     milliseconds since 0:00:00, January 1, 1970 UTC. If omitted, the\n   *     current time will be used.\n   * @param {string=} opt_type The log type, if known.\n   */\n  constructor(level, message, opt_timestamp, opt_type) {\n    this.level = level instanceof Level ? level : getLevel(level);\n    this.message = message;\n    this.timestamp =\n        typeof opt_timestamp === 'number' ? opt_timestamp : Date.now();\n    this.type = opt_type || '';\n  }\n\n  /**\n   * @return {{level: string, message: string, timestamp: number,\n   *           type: string}} The JSON representation of this entry.\n   */\n  toJSON() {\n    return {\n      'level': this.level.name,\n      'message': this.message,\n      'timestamp': this.timestamp,\n      'type': this.type\n    };\n  }\n}\n\n\n/** @typedef {(string|function(): string)} */\nlet Loggable;\n\n\n/**\n * An object used to log debugging messages. Loggers use a hierarchical,\n * dot-separated naming scheme. For instance, \"foo\" is considered the parent of\n * the \"foo.bar\" and an ancestor of \"foo.bar.baz\".\n *\n * Each logger may be assigned a {@linkplain #setLevel log level}, which\n * controls which level of messages will be reported to the\n * {@linkplain #addHandler handlers} attached to this instance. If a log level\n * is not explicitly set on a logger, it will inherit its parent.\n *\n * This class should never be directly instantiated. Instead, users should\n * obtain logger references using the {@linkplain ./logging.getLogger()\n * getLogger()} function.\n *\n * @final\n */\nclass Logger {\n  /**\n   * @param {string} name the name of this logger.\n   * @param {Level=} opt_level the initial level for this logger.\n   */\n  constructor(name, opt_level) {\n    /** @private {string} */\n    this.name_ = name;\n\n    /** @private {Level} */\n    this.level_ = opt_level || null;\n\n    /** @private {Logger} */\n    this.parent_ = null;\n\n    /** @private {Set<function(!Entry)>} */\n    this.handlers_ = null;\n  }\n\n  /** @return {string} the name of this logger. */\n  getName() {\n    return this.name_;\n  }\n\n  /**\n   * @param {Level} level the new level for this logger, or `null` if the logger\n   *     should inherit its level from its parent logger.\n   */\n  setLevel(level) {\n    this.level_ = level;\n  }\n\n  /** @return {Level} the log level for this logger. */\n  getLevel() {\n    return this.level_;\n  }\n\n  /**\n   * @return {!Level} the effective level for this logger.\n   */\n  getEffectiveLevel() {\n    let logger = this;\n    let level;\n    do {\n      level = logger.level_;\n      logger = logger.parent_;\n    } while (logger && !level);\n    return level || Level.OFF;\n  }\n\n  /**\n   * @param {!Level} level the level to check.\n   * @return {boolean} whether messages recorded at the given level are loggable\n   *     by this instance.\n   */\n  isLoggable(level) {\n    return level.value !== Level.OFF.value\n        && level.value >= this.getEffectiveLevel().value;\n  }\n\n  /**\n   * Adds a handler to this logger. The handler will be invoked for each message\n   * logged with this instance, or any of its descendants.\n   *\n   * @param {function(!Entry)} handler the handler to add.\n   */\n  addHandler(handler) {\n    if (!this.handlers_) {\n      this.handlers_ = new Set;\n    }\n    this.handlers_.add(handler);\n  }\n\n  /**\n   * Removes a handler from this logger.\n   *\n   * @param {function(!Entry)} handler the handler to remove.\n   * @return {boolean} whether a handler was successfully removed.\n   */\n  removeHandler(handler) {\n    if (!this.handlers_) {\n      return false;\n    }\n    return this.handlers_.delete(handler);\n  }\n\n  /**\n   * Logs a message at the given level. The message may be defined as a string\n   * or as a function that will return the message. If a function is provided,\n   * it will only be invoked if this logger's\n   * {@linkplain #getEffectiveLevel() effective log level} includes the given\n   * `level`.\n   *\n   * @param {!Level} level the level at which to log the message.\n   * @param {(string|function(): string)} loggable the message to log, or a\n   *     function that will return the message.\n   */\n  log(level, loggable) {\n    if (!this.isLoggable(level)) {\n      return;\n    }\n    let message = '[' + this.name_ + '] '\n        + (typeof loggable === 'function' ? loggable() : loggable);\n    let entry = new Entry(level, message, Date.now());\n    for (let logger = this; !!logger; logger = logger.parent_) {\n      if (logger.handlers_) {\n        for (let handler of logger.handlers_) {\n          handler(entry);\n        }\n      }\n    }\n  }\n\n  /**\n   * Logs a message at the {@link Level.SEVERE} log level.\n   * @param {(string|function(): string)} loggable the message to log, or a\n   *     function that will return the message.\n   */\n  severe(loggable) {\n    this.log(Level.SEVERE, loggable);\n  }\n\n  /**\n   * Logs a message at the {@link Level.WARNING} log level.\n   * @param {(string|function(): string)} loggable the message to log, or a\n   *     function that will return the message.\n   */\n  warning(loggable) {\n    this.log(Level.WARNING, loggable);\n  }\n\n  /**\n   * Logs a message at the {@link Level.INFO} log level.\n   * @param {(string|function(): string)} loggable the message to log, or a\n   *     function that will return the message.\n   */\n  info(loggable) {\n    this.log(Level.INFO, loggable);\n  }\n\n  /**\n   * Logs a message at the {@link Level.DEBUG} log level.\n   * @param {(string|function(): string)} loggable the message to log, or a\n   *     function that will return the message.\n   */\n  debug(loggable) {\n    this.log(Level.DEBUG, loggable);\n  }\n\n  /**\n   * Logs a message at the {@link Level.FINE} log level.\n   * @param {(string|function(): string)} loggable the message to log, or a\n   *     function that will return the message.\n   */\n  fine(loggable) {\n    this.log(Level.FINE, loggable);\n  }\n\n  /**\n   * Logs a message at the {@link Level.FINER} log level.\n   * @param {(string|function(): string)} loggable the message to log, or a\n   *     function that will return the message.\n   */\n  finer(loggable) {\n    this.log(Level.FINER, loggable);\n  }\n\n  /**\n   * Logs a message at the {@link Level.FINEST} log level.\n   * @param {(string|function(): string)} loggable the message to log, or a\n   *     function that will return the message.\n   */\n  finest(loggable) {\n    this.log(Level.FINEST, loggable);\n  }\n}\n\n\n/**\n * Maintains a collection of loggers.\n *\n * @final\n */\nclass LogManager {\n  constructor() {\n    /** @private {!Map<string, !Logger>} */\n    this.loggers_ = new Map;\n    this.root_ = new Logger('', Level.OFF);\n  }\n\n  /**\n   * Retrieves a named logger, creating it in the process. This function will\n   * implicitly create the requested logger, and any of its parents, if they\n   * do not yet exist.\n   *\n   * @param {string} name the logger's name.\n   * @return {!Logger} the requested logger.\n   */\n  getLogger(name) {\n    if (!name) {\n      return this.root_;\n    }\n    let parent = this.root_;\n    for (let i = name.indexOf('.'); i != -1; i = name.indexOf('.', i + 1)) {\n      let parentName = name.substr(0, i);\n      parent = this.createLogger_(parentName, parent);\n    }\n    return this.createLogger_(name, parent);\n  }\n\n  /**\n   * Creates a new logger.\n   *\n   * @param {string} name the logger's name.\n   * @param {!Logger} parent the logger's parent.\n   * @return {!Logger} the new logger.\n   * @private\n   */\n  createLogger_(name, parent) {\n    if (this.loggers_.has(name)) {\n      return /** @type {!Logger} */(this.loggers_.get(name));\n    }\n    let logger = new Logger(name, null);\n    logger.parent_ = parent;\n    this.loggers_.set(name, logger);\n    return logger;\n  }\n}\n\n\nconst logManager = new LogManager;\n\n\n/**\n * Retrieves a named logger, creating it in the process. This function will\n * implicitly create the requested logger, and any of its parents, if they\n * do not yet exist.\n *\n * The log level will be unspecified for newly created loggers. Use\n * {@link Logger#setLevel(level)} to explicitly set a level.\n *\n * @param {string} name the logger's name.\n * @return {!Logger} the requested logger.\n */\nfunction getLogger(name) {\n  return logManager.getLogger(name);\n}\n\n\n/**\n * Pads a number to ensure it has a minimum of two digits.\n * \n * @param {number} n the number to be padded.\n * @return {string} the padded number.\n */\nfunction pad(n) {\n  if (n >= 10) {\n    return '' + n;\n  } else {\n    return '0' + n;\n  }\n}\n\n\n/**\n * Logs all messages to the Console API.\n * @param {!Entry} entry the entry to log.\n */\nfunction consoleHandler(entry) {\n  if (typeof console === 'undefined' || !console) {\n    return;\n  }\n\n  var timestamp = new Date(entry.timestamp);\n  var msg =\n      '[' + timestamp.getUTCFullYear() + '-' +\n      pad(timestamp.getUTCMonth() + 1) + '-' +\n      pad(timestamp.getUTCDate()) + 'T' +\n      pad(timestamp.getUTCHours()) + ':' +\n      pad(timestamp.getUTCMinutes()) + ':' +\n      pad(timestamp.getUTCSeconds()) + 'Z] ' +\n      '[' + entry.level.name + '] ' +\n      entry.message;\n\n  var level = entry.level.value;\n  if (level >= Level.SEVERE.value) {\n    console.error(msg);\n  } else if (level >= Level.WARNING.value) {\n    console.warn(msg);\n  } else {\n    console.log(msg);\n  }\n}\n\n\n/**\n * Adds the console handler to the given logger. The console handler will log\n * all messages using the JavaScript Console API.\n *\n * @param {Logger=} opt_logger The logger to add the handler to; defaults\n *     to the root logger.\n */\nfunction addConsoleHandler(opt_logger) {\n  let logger = opt_logger || logManager.root_;\n  logger.addHandler(consoleHandler);\n}\n\n\n/**\n * Removes the console log handler from the given logger.\n *\n * @param {Logger=} opt_logger The logger to remove the handler from; defaults\n *     to the root logger.\n * @see exports.addConsoleHandler\n */\nfunction removeConsoleHandler(opt_logger) {\n  let logger = opt_logger || logManager.root_;\n  logger.removeHandler(consoleHandler);\n}\n\n\n/**\n * Installs the console log handler on the root logger.\n */\nfunction installConsoleHandler() {\n  addConsoleHandler(logManager.root_);\n}\n\n\n/**\n * Common log types.\n * @enum {string}\n */\nconst Type = {\n  /** Logs originating from the browser. */\n  BROWSER: 'browser',\n  /** Logs from a WebDriver client. */\n  CLIENT: 'client',\n  /** Logs from a WebDriver implementation. */\n  DRIVER: 'driver',\n  /** Logs related to performance. */\n  PERFORMANCE: 'performance',\n  /** Logs from the remote server. */\n  SERVER: 'server'\n};\n\n\n/**\n * Describes the log preferences for a WebDriver session.\n *\n * @final\n */\nclass Preferences {\n  constructor() {\n    /** @private {!Map<string, !Level>} */\n    this.prefs_ = new Map;\n  }\n\n  /**\n   * Sets the desired logging level for a particular log type.\n   * @param {(string|Type)} type The log type.\n   * @param {(!Level|string|number)} level The desired log level.\n   * @throws {TypeError} if `type` is not a `string`.\n   */\n  setLevel(type, level) {\n    if (typeof type !== 'string') {\n      throw TypeError('specified log type is not a string: ' + typeof type);\n    }\n    this.prefs_.set(type, level instanceof Level ? level : getLevel(level));\n  }\n\n  /**\n   * Converts this instance to its JSON representation.\n   * @return {!Object<string, string>} The JSON representation of this set of\n   *     preferences.\n   */\n  toJSON() {\n    let json = {};\n    for (let key of this.prefs_.keys()) {\n      json[key] = this.prefs_.get(key).name;\n    }\n    return json;\n  }\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  Entry: Entry,\n  Level: Level,\n  LogManager: LogManager,\n  Logger: Logger,\n  Preferences: Preferences,\n  Type: Type,\n  addConsoleHandler: addConsoleHandler,\n  getLevel: getLevel,\n  getLogger: getLogger,\n  installConsoleHandler: installConsoleHandler,\n  removeConsoleHandler: removeConsoleHandler\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/logging.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/promise.js":
/*!*********************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/promise.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a handful of utility functions to simplify working\n * with promises.\n */\n\n\n\n\n\n/**\n * Determines whether a {@code value} should be treated as a promise.\n * Any object whose \"then\" property is a function will be considered a promise.\n *\n * @param {?} value The value to test.\n * @return {boolean} Whether the value is a promise.\n */\nfunction isPromise(value) {\n  try {\n    // Use array notation so the Closure compiler does not obfuscate away our\n    // contract.\n    return value\n        && (typeof value === 'object' || typeof value === 'function')\n        && typeof value['then'] === 'function';\n  } catch (ex) {\n    return false;\n  }\n}\n\n\n/**\n * Creates a promise that will be resolved at a set time in the future.\n * @param {number} ms The amount of time, in milliseconds, to wait before\n *     resolving the promise.\n * @return {!Promise<void>} The promise.\n */\nfunction delayed(ms) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(), ms);\n  });\n}\n\n\n/**\n * Wraps a function that expects a node-style callback as its final\n * argument. This callback expects two arguments: an error value (which will be\n * null if the call succeeded), and the success value as the second argument.\n * The callback will the resolve or reject the returned promise, based on its\n * arguments.\n * @param {!Function} fn The function to wrap.\n * @param {...?} args The arguments to apply to the function, excluding the\n *     final callback.\n * @return {!Thenable} A promise that will be resolved with the\n *     result of the provided function's callback.\n */\nfunction checkedNodeCall(fn, ...args) {\n  return new Promise(function(fulfill, reject) {\n    try {\n      fn(...args, function(error, value) {\n        error ? reject(error) : fulfill(value);\n      });\n    } catch (ex) {\n      reject(ex);\n    }\n  });\n}\n\n/**\n * Registers a listener to invoke when a promise is resolved, regardless\n * of whether the promise's value was successfully computed. This function\n * is synonymous with the {@code finally} clause in a synchronous API:\n *\n *     // Synchronous API:\n *     try {\n *       doSynchronousWork();\n *     } finally {\n *       cleanUp();\n *     }\n *\n *     // Asynchronous promise API:\n *     doAsynchronousWork().finally(cleanUp);\n *\n * __Note:__ similar to the {@code finally} clause, if the registered\n * callback returns a rejected promise or throws an error, it will silently\n * replace the rejection error (if any) from this promise:\n *\n *     try {\n *       throw Error('one');\n *     } finally {\n *       throw Error('two');  // Hides Error: one\n *     }\n *\n *     let p = Promise.reject(Error('one'));\n *     promise.finally(p, function() {\n *       throw Error('two');  // Hides Error: one\n *     });\n *\n * @param {!IThenable<?>} promise The promise to add the listener to.\n * @param {function(): (R|IThenable<R>)} callback The function to call when\n *     the promise is resolved.\n * @return {!Promise<R>} A promise that will be resolved with the callback\n *     result.\n * @template R\n */\nasync function thenFinally(promise, callback) {\n  try {\n    await Promise.resolve(promise);\n    return callback();\n  } catch (e) {\n    await callback();\n    throw e;\n  }\n}\n\n\n/**\n * Calls a function for each element in an array and inserts the result into a\n * new array, which is used as the fulfillment value of the promise returned\n * by this function.\n *\n * If the return value of the mapping function is a promise, this function\n * will wait for it to be fulfilled before inserting it into the new array.\n *\n * If the mapping function throws or returns a rejected promise, the\n * promise returned by this function will be rejected with the same reason.\n * Only the first failure will be reported; all subsequent errors will be\n * silently ignored.\n *\n * @param {!(Array<TYPE>|IThenable<!Array<TYPE>>)} array The array to iterate\n *     over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The\n *     function to call for each element in the array. This function should\n *     expect three arguments (the element, the index, and the array itself.\n * @param {SELF=} self The object to be used as the value of 'this' within `fn`.\n * @template TYPE, SELF\n */\nasync function map(array, fn, self = undefined) {\n  const v = await Promise.resolve(array);\n  if (!Array.isArray(v)) {\n    throw TypeError('not an array');\n  }\n\n  const arr = /** @type {!Array} */(v);\n  const n = arr.length;\n  const values = new Array(n);\n\n  for (let i = 0; i < n; i++) {\n    if (i in arr) {\n      values[i] = await Promise.resolve(fn.call(self, arr[i], i, arr));\n    }\n  }\n  return values;\n}\n\n\n/**\n * Calls a function for each element in an array, and if the function returns\n * true adds the element to a new array.\n *\n * If the return value of the filter function is a promise, this function\n * will wait for it to be fulfilled before determining whether to insert the\n * element into the new array.\n *\n * If the filter function throws or returns a rejected promise, the promise\n * returned by this function will be rejected with the same reason. Only the\n * first failure will be reported; all subsequent errors will be silently\n * ignored.\n *\n * @param {!(Array<TYPE>|IThenable<!Array<TYPE>>)} array The array to iterate\n *     over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (\n *             boolean|IThenable<boolean>)} fn The function\n *     to call for each element in the array.\n * @param {SELF=} self The object to be used as the value of 'this' within `fn`.\n * @template TYPE, SELF\n */\nasync function filter(array, fn, self = undefined) {\n  const v = await Promise.resolve(array);\n  if (!Array.isArray(v)) {\n    throw TypeError('not an array');\n  }\n\n  const arr = /** @type {!Array} */(v);\n  const n = arr.length;\n  const values = [];\n  let valuesLength = 0;\n\n  for (let i = 0; i < n; i++) {\n    if (i in arr) {\n      let value = arr[i];\n      let include = await fn.call(self, value, i, arr);\n      if (include) {\n        values[valuesLength++] = value;\n      }\n    }\n  }\n  return values;\n}\n\n\n/**\n * Returns a promise that will be resolved with the input value in a\n * fully-resolved state. If the value is an array, each element will be fully\n * resolved. Likewise, if the value is an object, all keys will be fully\n * resolved. In both cases, all nested arrays and objects will also be\n * fully resolved.  All fields are resolved in place; the returned promise will\n * resolve on {@code value} and not a copy.\n *\n * Warning: This function makes no checks against objects that contain\n * cyclical references:\n *\n *     var value = {};\n *     value['self'] = value;\n *     promise.fullyResolved(value);  // Stack overflow.\n *\n * @param {*} value The value to fully resolve.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\nasync function fullyResolved(value) {\n  value = await Promise.resolve(value);\n  if (Array.isArray(value)) {\n    return fullyResolveKeys(/** @type {!Array} */ (value));\n  }\n\n  if (value && typeof value === 'object') {\n    return fullyResolveKeys(/** @type {!Object} */ (value));\n  }\n\n  if (typeof value === 'function') {\n    return fullyResolveKeys(/** @type {!Object} */ (value));\n  }\n\n  return value;\n}\n\n\n/**\n * @param {!(Array|Object)} obj the object to resolve.\n * @return {!Thenable} A promise that will be resolved with the\n *     input object once all of its values have been fully resolved.\n */\nasync function fullyResolveKeys(obj) {\n  const isArray = Array.isArray(obj);\n  const numKeys = isArray ? obj.length : Object.keys(obj).length;\n\n  if (!numKeys) {\n    return obj;\n  }\n\n  async function forEachProperty(obj, fn) {\n    for (let key in obj) {\n      await fn(obj[key], key);\n    }\n  }\n\n  async function forEachElement(arr, fn) {\n    for (let i = 0; i < arr.length; i++) {\n      await fn(arr[i], i);\n    }\n  }\n\n  const forEachKey = isArray ? forEachElement : forEachProperty;\n  await forEachKey(obj, async function(partialValue, key) {\n    if (!Array.isArray(partialValue)\n        && (!partialValue || typeof partialValue !== 'object')) {\n      return;\n    }\n    let resolvedValue = await fullyResolved(partialValue);\n    obj[key] = resolvedValue;\n  });\n  return obj;\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  checkedNodeCall,\n  delayed,\n  filter,\n  finally: thenFinally,\n  fullyResolved,\n  isPromise,\n  map\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/promise.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/proxy.js":
/*!*******************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/proxy.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines functions for configuring a webdriver proxy:\n *\n *     const proxy = require('selenium-webdriver/proxy');\n *     const {Capabilities} = require('selenium-webdriver');\n *\n *     let capabilities = new Capabilities();\n *     capabilities.setProxy(proxy.manual({http: 'host:1234'});\n */\n\n\n\n/**\n * Supported {@linkplain Config proxy configuration} types.\n *\n * @enum {string}\n */\nconst Type = {\n  AUTODETECT: 'autodetect',\n  DIRECT: 'direct',\n  MANUAL: 'manual',\n  PAC: 'pac',\n  SYSTEM: 'system',\n};\n\n\n/**\n * Describes how a proxy should be configured for a WebDriver session.\n * @record\n */\nfunction Config() {}\n\n/**\n * The proxy type.\n * @type {Type}\n */\nConfig.prototype.proxyType;\n\n\n/**\n * Describes how to configure a PAC proxy.\n * @record\n * @extends {Config}\n */\nfunction PacConfig() {}\n\n/**\n * URL for the PAC file to use.\n *\n * @type {string}\n */\nPacConfig.prototype.proxyAutoconfigUrl;\n\n\n/**\n * Record object that defines a manual proxy configuration. Manual\n * configurations can be easily created using either the\n * {@link ./proxy.manual proxy.manual()} or {@link ./proxy.socks proxy.socks()}\n * factory method.\n *\n * @record\n * @extends {Config}\n */\nfunction ManualConfig() {}\n\n/**\n * The proxy host for FTP requests.\n *\n * @type {(string|undefined)}\n */\nManualConfig.prototype.ftpProxy;\n\n/**\n * The proxy host for HTTP requests.\n *\n * @type {(string|undefined)}\n */\nManualConfig.prototype.httpProxy;\n\n/**\n * An array of hosts which should bypass all proxies.\n *\n * @type {(Array<string>|undefined)}\n */\nManualConfig.prototype.noProxy;\n\n/**\n * The proxy host for HTTPS requests.\n *\n * @type {(string|undefined)}\n */\nManualConfig.prototype.sslProxy;\n\n/**\n * Defines the host and port for the SOCKS proxy to use.\n *\n * @type {(number|undefined)}\n */\nManualConfig.prototype.socksProxy;\n\n/**\n * Defines the SOCKS proxy version. Must be a number in the range [0, 255].\n *\n * @type {(number|undefined)}\n */\nManualConfig.prototype.socksVersion;\n\n\n// PUBLIC API\n\n\n/** @const */ exports.Config = Config;\n/** @const */ exports.ManualConfig = ManualConfig;\n/** @const */ exports.PacConfig = PacConfig;\n/** @const */ exports.Type = Type;\n\n\n/**\n * Configures WebDriver to bypass all browser proxies.\n * @return {!Config} A new proxy configuration object.\n */\nexports.direct = function() {\n  return {proxyType: Type.DIRECT};\n};\n\n\n/**\n * Manually configures the browser proxy.  The following options are\n * supported:\n *\n * - `ftp`: Proxy host to use for FTP requests\n * - `http`: Proxy host to use for HTTP requests\n * - `https`: Proxy host to use for HTTPS requests\n * - `bypass`: A list of hosts requests should directly connect to,\n *     bypassing any other proxies for that request. May be specified as a\n *     comma separated string, or a list of strings.\n *\n * Behavior is undefined for FTP, HTTP, and HTTPS requests if the\n * corresponding key is omitted from the configuration options.\n *\n * @param {{ftp: (string|undefined),\n *          http: (string|undefined),\n *          https: (string|undefined),\n *          bypass: (Array<string>|undefined)}} options Proxy\n *     configuration options.\n * @return {!ManualConfig} A new proxy configuration object.\n */\nexports.manual = function({ftp, http, https, bypass}) {\n  return {\n    proxyType: Type.MANUAL,\n    ftpProxy: ftp,\n    httpProxy: http,\n    sslProxy: https,\n    noProxy: bypass,\n  };\n};\n\n\n/**\n * Creates a proxy configuration for a socks proxy.\n *\n * __Example:__\n *\n *     const {Capabilities} = require('selenium-webdriver');\n *     const proxy = require('selenium-webdriver/lib/proxy');\n *\n *     let capabilities = new Capabilities();\n *     capabilities.setProxy(proxy.socks('localhost:1234'));\n *\n *     // Or, to include authentication.\n *     capabilities.setProxy(proxy.socks('bob:password@localhost:1234'));\n *\n *\n * @param {string} socksProxy The proxy host, in the form `hostname:port`.\n * @param {number=} socksVersion The SOCKS proxy version.\n * @return {!ManualConfig} A new proxy configuration object.\n * @see https://en.wikipedia.org/wiki/SOCKS\n */\nexports.socks = function(socksProxy, socksVersion = undefined) {\n  return /** @type {!Config} */({\n    proxyType: Type.MANUAL,\n    socksProxy,\n    socksVersion\n  });\n};\n\n\n/**\n * Configures WebDriver to configure the browser proxy using the PAC file at\n * the given URL.\n * @param {string} proxyAutoconfigUrl URL for the PAC proxy to use.\n * @return {!PacConfig} A new proxy configuration object.\n */\nexports.pac = function(proxyAutoconfigUrl) {\n  return {proxyType: Type.PAC, proxyAutoconfigUrl};\n};\n\n\n/**\n * Configures WebDriver to use the current system's proxy.\n * @return {!Config} A new proxy configuration object.\n */\nexports.system = function() {\n  return {proxyType: Type.SYSTEM};\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/proxy.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/session.js":
/*!*********************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/session.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\nconst {Capabilities} = __webpack_require__(/*! ./capabilities */ \"../node_modules/selenium-webdriver/lib/capabilities.js\");\n\n\n/**\n * Contains information about a single WebDriver session.\n */\nclass Session {\n\n  /**\n   * @param {string} id The session ID.\n   * @param {!(Object|Capabilities)} capabilities The session\n   *     capabilities.\n   */\n  constructor(id, capabilities) {\n    /** @private {string} */\n    this.id_ = id;\n\n    /** @private {!Capabilities} */\n    this.caps_ = capabilities instanceof Capabilities\n        ? /** @type {!Capabilities} */(capabilities)\n        : new Capabilities(capabilities);\n  }\n\n  /**\n   * @return {string} This session's ID.\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {!Capabilities} This session's capabilities.\n   */\n  getCapabilities() {\n    return this.caps_;\n  }\n\n  /**\n   * Retrieves the value of a specific capability.\n   * @param {string} key The capability to retrieve.\n   * @return {*} The capability value.\n   */\n  getCapability(key) {\n    return this.caps_.get(key);\n  }\n\n  /**\n   * Returns the JSON representation of this object, which is just the string\n   * session ID.\n   * @return {string} The JSON representation of this Session.\n   */\n  toJSON() {\n    return this.getId();\n  }\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {Session: Session};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/session.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/symbols.js":
/*!*********************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/symbols.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\n/**\n * @fileoverview Defines well-known symbols used within the selenium-webdriver\n * library.\n */\n\n\nmodule.exports = {\n  /**\n   * The serialize symbol specifies a method that returns an object's serialized\n   * representation. If an object's serialized form is not immediately\n   * available, the serialize method will return a promise that will be resolved\n   * with the serialized form.\n   *\n   * Note that the described method is analogous to objects that define a\n   * `toJSON()` method, except the serialized result may be a promise, or\n   * another object with a promised property.\n   */\n  serialize: Symbol('serialize')\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/symbols.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/until.js":
/*!*******************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/until.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines common conditions for use with\n * {@link webdriver.WebDriver#wait WebDriver wait}.\n *\n * Sample usage:\n *\n *     driver.get('http://www.google.com/ncr');\n *\n *     var query = driver.wait(until.elementLocated(By.name('q')));\n *     query.sendKeys('webdriver\\n');\n *\n *     driver.wait(until.titleIs('webdriver - Google Search'));\n *\n * To define a custom condition, simply call WebDriver.wait with a function\n * that will eventually return a truthy-value (neither null, undefined, false,\n * 0, or the empty string):\n *\n *     driver.wait(function() {\n *       return driver.getTitle().then(function(title) {\n *         return title === 'webdriver - Google Search';\n *       });\n *     }, 1000);\n */\n\n\n\nconst by = __webpack_require__(/*! ./by */ \"../node_modules/selenium-webdriver/lib/by.js\");\nconst By = __webpack_require__(/*! ./by */ \"../node_modules/selenium-webdriver/lib/by.js\").By;\nconst error = __webpack_require__(/*! ./error */ \"../node_modules/selenium-webdriver/lib/error.js\");\nconst webdriver = __webpack_require__(/*! ./webdriver */ \"../node_modules/selenium-webdriver/lib/webdriver.js\"),\n    Condition = webdriver.Condition,\n    WebElementCondition = webdriver.WebElementCondition;\n\n\n/**\n * Creates a condition that will wait until the input driver is able to switch\n * to the designated frame. The target frame may be specified as\n *\n * 1. a numeric index into\n *     [window.frames](https://developer.mozilla.org/en-US/docs/Web/API/Window.frames)\n *     for the currently selected frame.\n * 2. a {@link ./webdriver.WebElement}, which must reference a FRAME or IFRAME\n *     element on the current page.\n * 3. a locator which may be used to first locate a FRAME or IFRAME on the\n *     current page before attempting to switch to it.\n *\n * Upon successful resolution of this condition, the driver will be left\n * focused on the new frame.\n *\n * @param {!(number|./webdriver.WebElement|By|\n *           function(!./webdriver.WebDriver): !./webdriver.WebElement)} frame\n *     The frame identifier.\n * @return {!Condition<boolean>} A new condition.\n */\nexports.ableToSwitchToFrame = function ableToSwitchToFrame(frame) {\n  var condition;\n  if (typeof frame === 'number' || frame instanceof webdriver.WebElement) {\n    condition = driver => attemptToSwitchFrames(driver, frame);\n  } else {\n    condition = function(driver) {\n      let locator = /** @type {!(By|Function)} */(frame);\n      return driver.findElements(locator).then(function(els) {\n        if (els.length) {\n          return attemptToSwitchFrames(driver, els[0]);\n        }\n      });\n    };\n  }\n\n  return new Condition('to be able to switch to frame', condition);\n\n  function attemptToSwitchFrames(driver, frame) {\n    return driver.switchTo().frame(frame).then(\n        function() { return true; },\n        function(e) {\n          if (!(e instanceof error.NoSuchFrameError)) {\n            throw e;\n          }\n        });\n  }\n};\n\n\n/**\n * Creates a condition that waits for an alert to be opened. Upon success, the\n * returned promise will be fulfilled with the handle for the opened alert.\n *\n * @return {!Condition<!./webdriver.Alert>} The new condition.\n */\nexports.alertIsPresent = function alertIsPresent() {\n  return new Condition('for alert to be present', function(driver) {\n    return driver.switchTo().alert().catch(function(e) {\n      if (!(e instanceof error.NoSuchAlertError\n        // XXX: Workaround for GeckoDriver error `TypeError: can't convert null\n        // to object`. For more details, see\n        // https://github.com/SeleniumHQ/selenium/pull/2137\n        || (e instanceof error.WebDriverError\n          && e.message === `can't convert null to object`)\n        )) {\n        throw e;\n      }\n    });\n  });\n};\n\n\n/**\n * Creates a condition that will wait for the current page's title to match the\n * given value.\n *\n * @param {string} title The expected page title.\n * @return {!Condition<boolean>} The new condition.\n */\nexports.titleIs = function titleIs(title) {\n  return new Condition(\n      'for title to be ' + JSON.stringify(title),\n      function(driver) {\n        return driver.getTitle().then(function(t) {\n          return t === title;\n        });\n      });\n};\n\n\n/**\n * Creates a condition that will wait for the current page's title to contain\n * the given substring.\n *\n * @param {string} substr The substring that should be present in the page\n *     title.\n * @return {!Condition<boolean>} The new condition.\n */\nexports.titleContains = function titleContains(substr) {\n  return new Condition(\n      'for title to contain ' + JSON.stringify(substr),\n      function(driver) {\n        return driver.getTitle().then(function(title) {\n          return title.indexOf(substr) !== -1;\n        });\n      });\n};\n\n\n/**\n * Creates a condition that will wait for the current page's title to match the\n * given regular expression.\n *\n * @param {!RegExp} regex The regular expression to test against.\n * @return {!Condition<boolean>} The new condition.\n */\nexports.titleMatches = function titleMatches(regex) {\n  return new Condition('for title to match ' + regex, function(driver) {\n    return driver.getTitle().then(function(title) {\n      return regex.test(title);\n    });\n  });\n};\n\n\n/**\n * Creates a condition that will wait for the current page's url to match the\n * given value.\n *\n * @param {string} url The expected page url.\n * @return {!Condition<boolean>} The new condition.\n */\nexports.urlIs = function urlIs(url) {\n  return new Condition(\n      'for URL to be ' + JSON.stringify(url),\n      function(driver) {\n        return driver.getCurrentUrl().then(function(u) {\n          return u === url;\n        });\n      });\n};\n\n\n/**\n * Creates a condition that will wait for the current page's url to contain\n * the given substring.\n *\n * @param {string} substrUrl The substring that should be present in the current\n *     URL.\n * @return {!Condition<boolean>} The new condition.\n */\nexports.urlContains = function urlContains(substrUrl) {\n  return new Condition(\n      'for URL to contain ' + JSON.stringify(substrUrl),\n      function(driver) {\n        return driver.getCurrentUrl().then(function(url) {\n          return url.indexOf(substrUrl) !== -1;\n        });\n      });\n};\n\n\n/**\n * Creates a condition that will wait for the current page's url to match the\n * given regular expression.\n *\n * @param {!RegExp} regex The regular expression to test against.\n * @return {!Condition<boolean>} The new condition.\n */\nexports.urlMatches = function urlMatches(regex) {\n  return new Condition('for URL to match ' + regex, function(driver) {\n    return driver.getCurrentUrl().then(function(url) {\n      return regex.test(url);\n    });\n  });\n};\n\n\n/**\n * Creates a condition that will loop until an element is\n * {@link ./webdriver.WebDriver#findElement found} with the given locator.\n *\n * @param {!(By|Function)} locator The locator to use.\n * @return {!WebElementCondition} The new condition.\n */\nexports.elementLocated = function elementLocated(locator) {\n  locator = by.checkedLocator(locator);\n  let locatorStr =\n      typeof locator === 'function' ? 'by function()' : locator + '';\n  return new WebElementCondition('for element to be located ' + locatorStr,\n      function(driver) {\n        return driver.findElements(locator).then(function(elements) {\n          return elements[0];\n        });\n      });\n};\n\n\n/**\n * Creates a condition that will loop until at least one element is\n * {@link ./webdriver.WebDriver#findElement found} with the given locator.\n *\n * @param {!(By|Function)} locator The locator to use.\n * @return {!Condition<!Array<!./webdriver.WebElement>>} The new\n *     condition.\n */\nexports.elementsLocated = function elementsLocated(locator) {\n  locator = by.checkedLocator(locator);\n  let locatorStr =\n      typeof locator === 'function' ? 'by function()' : locator + '';\n  return new Condition(\n      'for at least one element to be located ' + locatorStr,\n      function(driver) {\n        return driver.findElements(locator).then(function(elements) {\n          return elements.length > 0 ? elements : null;\n        });\n      });\n};\n\n\n/**\n * Creates a condition that will wait for the given element to become stale. An\n * element is considered stale once it is removed from the DOM, or a new page\n * has loaded.\n *\n * @param {!./webdriver.WebElement} element The element that should become stale.\n * @return {!Condition<boolean>} The new condition.\n */\nexports.stalenessOf = function stalenessOf(element) {\n  return new Condition('element to become stale', function() {\n    return element.getTagName().then(\n        function() { return false; },\n        function(e) {\n          if (e instanceof error.StaleElementReferenceError) {\n            return true;\n          }\n          throw e;\n        });\n  });\n};\n\n\n/**\n * Creates a condition that will wait for the given element to become visible.\n *\n * @param {!./webdriver.WebElement} element The element to test.\n * @return {!WebElementCondition} The new condition.\n * @see ./webdriver.WebDriver#isDisplayed\n */\nexports.elementIsVisible = function elementIsVisible(element) {\n  return new WebElementCondition('until element is visible', function() {\n    return element.isDisplayed().then(v => v ? element : null);\n  });\n};\n\n\n/**\n * Creates a condition that will wait for the given element to be in the DOM,\n * yet not visible to the user.\n *\n * @param {!./webdriver.WebElement} element The element to test.\n * @return {!WebElementCondition} The new condition.\n * @see ./webdriver.WebDriver#isDisplayed\n */\nexports.elementIsNotVisible = function elementIsNotVisible(element) {\n  return new WebElementCondition('until element is not visible', function() {\n    return element.isDisplayed().then(v => v ? null : element);\n  });\n};\n\n\n/**\n * Creates a condition that will wait for the given element to be enabled.\n *\n * @param {!./webdriver.WebElement} element The element to test.\n * @return {!WebElementCondition} The new condition.\n * @see webdriver.WebDriver#isEnabled\n */\nexports.elementIsEnabled = function elementIsEnabled(element) {\n  return new WebElementCondition('until element is enabled', function() {\n    return element.isEnabled().then(v => v ? element : null);\n  });\n};\n\n\n/**\n * Creates a condition that will wait for the given element to be disabled.\n *\n * @param {!./webdriver.WebElement} element The element to test.\n * @return {!WebElementCondition} The new condition.\n * @see webdriver.WebDriver#isEnabled\n */\nexports.elementIsDisabled = function elementIsDisabled(element) {\n  return new WebElementCondition('until element is disabled', function() {\n    return element.isEnabled().then(v => v ? null : element);\n  });\n};\n\n\n/**\n * Creates a condition that will wait for the given element to be selected.\n * @param {!./webdriver.WebElement} element The element to test.\n * @return {!WebElementCondition} The new condition.\n * @see webdriver.WebDriver#isSelected\n */\nexports.elementIsSelected = function elementIsSelected(element) {\n  return new WebElementCondition('until element is selected', function() {\n    return element.isSelected().then(v => v ? element : null);\n  });\n};\n\n\n/**\n * Creates a condition that will wait for the given element to be deselected.\n *\n * @param {!./webdriver.WebElement} element The element to test.\n * @return {!WebElementCondition} The new condition.\n * @see webdriver.WebDriver#isSelected\n */\nexports.elementIsNotSelected = function elementIsNotSelected(element) {\n  return new WebElementCondition('until element is not selected', function() {\n    return element.isSelected().then(v => v ? null : element);\n  });\n};\n\n\n/**\n * Creates a condition that will wait for the given element's\n * {@link webdriver.WebDriver#getText visible text} to match the given\n * {@code text} exactly.\n *\n * @param {!./webdriver.WebElement} element The element to test.\n * @param {string} text The expected text.\n * @return {!WebElementCondition} The new condition.\n * @see webdriver.WebDriver#getText\n */\nexports.elementTextIs = function elementTextIs(element, text) {\n  return new WebElementCondition('until element text is', function() {\n    return element.getText().then(t => t === text ? element : null);\n  });\n};\n\n\n/**\n * Creates a condition that will wait for the given element's\n * {@link webdriver.WebDriver#getText visible text} to contain the given\n * substring.\n *\n * @param {!./webdriver.WebElement} element The element to test.\n * @param {string} substr The substring to search for.\n * @return {!WebElementCondition} The new condition.\n * @see webdriver.WebDriver#getText\n */\nexports.elementTextContains = function elementTextContains(element, substr) {\n  return new WebElementCondition('until element text contains', function() {\n    return element.getText()\n        .then(t => t.indexOf(substr) != -1 ? element : null);\n  });\n};\n\n\n/**\n * Creates a condition that will wait for the given element's\n * {@link webdriver.WebDriver#getText visible text} to match a regular\n * expression.\n *\n * @param {!./webdriver.WebElement} element The element to test.\n * @param {!RegExp} regex The regular expression to test against.\n * @return {!WebElementCondition} The new condition.\n * @see webdriver.WebDriver#getText\n */\nexports.elementTextMatches = function elementTextMatches(element, regex) {\n  return new WebElementCondition('until element text matches', function() {\n    return element.getText().then(t => regex.test(t) ? element : null);\n  });\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/until.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/lib/webdriver.js":
/*!***********************************************************!*\
  !*** ../node_modules/selenium-webdriver/lib/webdriver.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview The heart of the WebDriver JavaScript API.\n */\n\n\n\nconst by = __webpack_require__(/*! ./by */ \"../node_modules/selenium-webdriver/lib/by.js\");\nconst command = __webpack_require__(/*! ./command */ \"../node_modules/selenium-webdriver/lib/command.js\");\nconst error = __webpack_require__(/*! ./error */ \"../node_modules/selenium-webdriver/lib/error.js\");\nconst input = __webpack_require__(/*! ./input */ \"../node_modules/selenium-webdriver/lib/input.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"../node_modules/selenium-webdriver/lib/logging.js\");\nconst promise = __webpack_require__(/*! ./promise */ \"../node_modules/selenium-webdriver/lib/promise.js\");\nconst Symbols = __webpack_require__(/*! ./symbols */ \"../node_modules/selenium-webdriver/lib/symbols.js\");\nconst {Capabilities} = __webpack_require__(/*! ./capabilities */ \"../node_modules/selenium-webdriver/lib/capabilities.js\");\nconst {Session} = __webpack_require__(/*! ./session */ \"../node_modules/selenium-webdriver/lib/session.js\");\n\n\n// Capability names that are defined in the W3C spec.\nconst W3C_CAPABILITY_NAMES = new Set([\n    'acceptInsecureCerts',\n    'browserName',\n    'browserVersion',\n    'platformName',\n    'pageLoadStrategy',\n    'proxy',\n    'setWindowRect',\n    'timeouts',\n    'unhandledPromptBehavior',\n]);\n\n\n/**\n * Defines a condition for use with WebDriver's {@linkplain WebDriver#wait wait\n * command}.\n *\n * @template OUT\n */\nclass Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): OUT} fn The condition function to\n   *     evaluate on each iteration of the wait loop.\n   */\n  constructor(message, fn) {\n    /** @private {string} */\n    this.description_ = 'Waiting ' + message;\n\n    /** @type {function(!WebDriver): OUT} */\n    this.fn = fn;\n  }\n\n  /** @return {string} A description of this condition. */\n  description() {\n    return this.description_;\n  }\n}\n\n\n/**\n * Defines a condition that will result in a {@link WebElement}.\n *\n * @extends {Condition<!(WebElement|IThenable<!WebElement>)>}\n */\nclass WebElementCondition extends Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): !(WebElement|IThenable<!WebElement>)}\n   *     fn The condition function to evaluate on each iteration of the wait\n   *     loop.\n   */\n  constructor(message, fn) {\n    super(message, fn);\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebDriver\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Translates a command to its wire-protocol representation before passing it\n * to the given `executor` for execution.\n * @param {!command.Executor} executor The executor to use.\n * @param {!command.Command} command The command to execute.\n * @return {!Promise} A promise that will resolve with the command response.\n */\nfunction executeCommand(executor, command) {\n  return toWireValue(command.getParameters()).\n      then(function(parameters) {\n        command.setParameters(parameters);\n        return executor.execute(command);\n      });\n}\n\n\n/**\n * Converts an object to its JSON representation in the WebDriver wire protocol.\n * When converting values of type object, the following steps will be taken:\n * <ol>\n * <li>if the object is a WebElement, the return value will be the element's\n *     server ID\n * <li>if the object defines a {@link Symbols.serialize} method, this algorithm\n *     will be recursively applied to the object's serialized representation\n * <li>if the object provides a \"toJSON\" function, this algorithm will\n *     recursively be applied to the result of that function\n * <li>otherwise, the value of each key will be recursively converted according\n *     to the rules above.\n * </ol>\n *\n * @param {*} obj The object to convert.\n * @return {!Promise<?>} A promise that will resolve to the input value's JSON\n *     representation.\n */\nasync function toWireValue(obj) {\n  let value = await Promise.resolve(obj);\n  if (value === void 0 || value === null) {\n    return value;\n  }\n\n  if (typeof value === 'boolean'\n      || typeof value === 'number'\n      || typeof value === 'string') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return convertKeys(value);\n  }\n\n  if (typeof value === 'function') {\n    return '' + value;\n  }\n\n  if (typeof value[Symbols.serialize] === 'function') {\n    return toWireValue(value[Symbols.serialize]());\n  } else if (typeof value.toJSON === 'function') {\n    return toWireValue(value.toJSON());\n  }\n  return convertKeys(value);\n}\n\n\nasync function convertKeys(obj) {\n  const isArray = Array.isArray(obj);\n  const numKeys = isArray ? obj.length : Object.keys(obj).length;\n  const ret = isArray ? new Array(numKeys) : {};\n  if (!numKeys) {\n    return ret;\n  }\n\n  let numResolved = 0;\n\n  async function forEachKey(obj, fn) {\n    if (Array.isArray(obj)) {\n      for (let i = 0, n = obj.length; i < n; i++) {\n        await fn(obj[i], i);\n      }\n    } else {\n      for (let key in obj) {\n        await fn(obj[key], key);\n      }\n    }\n  }\n\n  await forEachKey(obj, async function(value, key) {\n    ret[key] = await toWireValue(value);\n  });\n\n  return ret;\n}\n\n\n/**\n * Converts a value from its JSON representation according to the WebDriver wire\n * protocol. Any JSON object that defines a WebElement ID will be decoded to a\n * {@link WebElement} object. All other values will be passed through as is.\n *\n * @param {!WebDriver} driver The driver to use as the parent of any unwrapped\n *     {@link WebElement} values.\n * @param {*} value The value to convert.\n * @return {*} The converted value.\n */\nfunction fromWireValue(driver, value) {\n  if (Array.isArray(value)) {\n    value = value.map(v => fromWireValue(driver, v));\n  } else if (WebElement.isId(value)) {\n    let id = WebElement.extractId(value);\n    value = new WebElement(driver, id);\n  } else if (value && typeof value === 'object') {\n    let result = {};\n    for (let key in value) {\n      if (value.hasOwnProperty(key)) {\n        result[key] = fromWireValue(driver, value[key]);\n      }\n    }\n    value = result;\n  }\n  return value;\n}\n\n\n/**\n * Structural interface for a WebDriver client.\n *\n * @record\n */\nclass IWebDriver {\n\n  /**\n   * Executes the provided {@link command.Command} using this driver's\n   * {@link command.Executor}.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the command\n   *     result.\n   * @template T\n   */\n  execute(command) {}\n\n  /**\n   * Sets the {@linkplain input.FileDetector file detector} that should be\n   * used with this instance.\n   * @param {input.FileDetector} detector The detector to use or `null`.\n   */\n  setFileDetector(detector) {}\n\n  /**\n   * @return {!command.Executor} The command executor used by this instance.\n   */\n  getExecutor() {}\n\n  /**\n   * @return {!Promise<!Session>} A promise for this client's session.\n   */\n  getSession() {}\n\n  /**\n   * @return {!Promise<!Capabilities>} A promise that will resolve with\n   *     the this instance's capabilities.\n   */\n  getCapabilities() {}\n\n  /**\n   * Terminates the browser session. After calling quit, this instance will be\n   * invalidated and may no longer be used to issue commands against the\n   * browser.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     command has completed.\n   */\n  quit() {}\n\n  /**\n   * Creates a new action sequence using this driver. The sequence will not be\n   * submitted for execution until\n   * {@link ./input.Actions#perform Actions.perform()} is called.\n   *\n   * @param {{async: (boolean|undefined),\n   *          bridge: (boolean|undefined)}=} options Configuration options for\n   *     the action sequence (see {@link ./input.Actions Actions} documentation\n   *     for details).\n   * @return {!input.Actions} A new action sequence for this instance.\n   */\n  actions(options) {}\n\n  /**\n   * Executes a snippet of JavaScript in the context of the currently selected\n   * frame or window. The script fragment will be executed as the body of an\n   * anonymous function. If the script is provided as a function object, that\n   * function will be converted to a string for injection into the target\n   * window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the `arguments` object. Arguments may\n   * be a boolean, number, string, or {@linkplain WebElement}. Arrays and\n   * objects may also be used as script arguments as long as each item adheres\n   * to the types previously mentioned.\n   *\n   * The script may refer to any variables accessible from the current window.\n   * Furthermore, the script will execute in the window's context, thus\n   * `document` may be used to refer to the current document. Any local\n   * variables will not be available once the script has finished executing,\n   * though global variables will persist.\n   *\n   * If the script has a return value (i.e. if the script contains a return\n   * statement), then the following steps will be taken for resolving this\n   * functions return value:\n   *\n   * - For a HTML element, the value will resolve to a {@linkplain WebElement}\n   * - Null and undefined return values will resolve to null</li>\n   * - Booleans, numbers, and strings will resolve as is</li>\n   * - Functions will resolve to their string representation</li>\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} args The arguments to pass to the script.\n   * @return {!IThenable<T>} A promise that will resolve to the\n   *    scripts return value.\n   * @template T\n   */\n  executeScript(script, ...args) {}\n\n  /**\n   * Executes a snippet of asynchronous JavaScript in the context of the\n   * currently selected frame or window. The script fragment will be executed as\n   * the body of an anonymous function. If the script is provided as a function\n   * object, that function will be converted to a string for injection into the\n   * target window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the `arguments` object. Arguments may\n   * be a boolean, number, string, or {@linkplain WebElement}. Arrays and\n   * objects may also be used as script arguments as long as each item adheres\n   * to the types previously mentioned.\n   *\n   * Unlike executing synchronous JavaScript with {@link #executeScript},\n   * scripts executed with this function must explicitly signal they are\n   * finished by invoking the provided callback. This callback will always be\n   * injected into the executed function as the last argument, and thus may be\n   * referenced with  `arguments[arguments.length - 1]`. The following steps\n   * will be taken for resolving this functions return value against the first\n   * argument to the script's callback function:\n   *\n   * - For a HTML element, the value will resolve to a {@link WebElement}\n   * - Null and undefined return values will resolve to null\n   * - Booleans, numbers, and strings will resolve as is\n   * - Functions will resolve to their string representation\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * __Example #1:__ Performing a sleep that is synchronized with the currently\n   * selected window:\n   *\n   *     var start = new Date().getTime();\n   *     driver.executeAsyncScript(\n   *         'window.setTimeout(arguments[arguments.length - 1], 500);').\n   *         then(function() {\n   *           console.log(\n   *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');\n   *         });\n   *\n   * __Example #2:__ Synchronizing a test with an AJAX application:\n   *\n   *     var button = driver.findElement(By.id('compose-button'));\n   *     button.click();\n   *     driver.executeAsyncScript(\n   *         'var callback = arguments[arguments.length - 1];' +\n   *         'mailClient.getComposeWindowWidget().onload(callback);');\n   *     driver.switchTo().frame('composeWidget');\n   *     driver.findElement(By.id('to')).sendKeys('dog@example.com');\n   *\n   * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In\n   * this example, the inject script is specified with a function literal. When\n   * using this format, the function is converted to a string for injection, so\n   * it should not reference any symbols not defined in the scope of the page\n   * under test.\n   *\n   *     driver.executeAsyncScript(function() {\n   *       var callback = arguments[arguments.length - 1];\n   *       var xhr = new XMLHttpRequest();\n   *       xhr.open(\"GET\", \"/resource/data.json\", true);\n   *       xhr.onreadystatechange = function() {\n   *         if (xhr.readyState == 4) {\n   *           callback(xhr.responseText);\n   *         }\n   *       };\n   *       xhr.send('');\n   *     }).then(function(str) {\n   *       console.log(JSON.parse(str)['food']);\n   *     });\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} args The arguments to pass to the script.\n   * @return {!IThenable<T>} A promise that will resolve to the scripts return\n   *     value.\n   * @template T\n   */\n  executeAsyncScript(script, ...args) {}\n\n  /**\n   * Waits for a condition to evaluate to a \"truthy\" value. The condition may be\n   * specified by a {@link Condition}, as a custom function, or as any\n   * promise-like thenable.\n   *\n   * For a {@link Condition} or function, the wait will repeatedly\n   * evaluate the condition until it returns a truthy value. If any errors occur\n   * while evaluating the condition, they will be allowed to propagate. In the\n   * event a condition returns a {@linkplain Promise}, the polling loop will\n   * wait for it to be resolved and use the resolved value for whether the\n   * condition has been satisfied. The resolution time for a promise is always\n   * factored into whether a wait has timed out.\n   *\n   * If the provided condition is a {@link WebElementCondition}, then\n   * the wait will return a {@link WebElementPromise} that will resolve to the\n   * element that satisfied the condition.\n   *\n   * _Example:_ waiting up to 10 seconds for an element to be present on the\n   * page.\n   *\n   *     async function example() {\n   *       let button =\n   *           await driver.wait(until.elementLocated(By.id('foo')), 10000);\n   *       await button.click();\n   *     }\n   *\n   * @param {!(IThenable<T>|\n   *           Condition<T>|\n   *           function(!WebDriver): T)} condition The condition to\n   *     wait on, defined as a promise, condition object, or  a function to\n   *     evaluate as a condition.\n   * @param {number=} timeout How long to wait for the condition to be true.\n   * @param {string=} message An optional message to use if the wait times out.\n   * @return {!(IThenable<T>|WebElementPromise)} A promise that will be\n   *     resolved with the first truthy value returned by the condition\n   *     function, or rejected if the condition times out. If the input\n   *     input condition is an instance of a {@link WebElementCondition},\n   *     the returned value will be a {@link WebElementPromise}.\n   * @throws {TypeError} if the provided `condition` is not a valid type.\n   * @template T\n   */\n  wait(condition, timeout = undefined, message = undefined) {}\n\n  /**\n   * Makes the driver sleep for the given amount of time.\n   *\n   * @param {number} ms The amount of time, in milliseconds, to sleep.\n   * @return {!Promise<void>} A promise that will be resolved when the sleep has\n   *     finished.\n   */\n  sleep(ms) {}\n\n  /**\n   * Retrieves the current window handle.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     window handle.\n   */\n  getWindowHandle() {}\n\n  /**\n   * Retrieves a list of all available window handles.\n   *\n   * @return {!Promise<!Array<string>>} A promise that will be resolved with an\n   *     array of window handles.\n   */\n  getAllWindowHandles() {}\n\n  /**\n   * Retrieves the current page's source. The returned souce is a representation\n   * of the underlying DOM: do not expect it to be formatted or escaped in the\n   * same way as the raw response sent from the web server.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     page source.\n   */\n  getPageSource() {}\n\n  /**\n   * Closes the current window.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when this command\n   *     has completed.\n   */\n  close() {}\n\n  /**\n   * Navigates to the given URL.\n   *\n   * @param {string} url The fully qualified URL to open.\n   * @return {!Promise<void>} A promise that will be resolved when the document\n   *     has finished loading.\n   */\n  get(url) {}\n\n  /**\n   * Retrieves the URL for the current page.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     current URL.\n   */\n  getCurrentUrl() {}\n\n  /**\n   * Retrieves the current page title.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     page's title.\n   */\n  getTitle() {}\n\n  /**\n   * Locates an element on the page. If the element cannot be found, a\n   * {@link error.NoSuchEementError} will be returned by the driver.\n   *\n   * This function should not be used to test whether an element is present on\n   * the page. Rather, you should use {@link #findElements}:\n   *\n   *     driver.findElements(By.id('foo'))\n   *         .then(found => console.log('Element found? %s', !!found.length));\n   *\n   * The search criteria for an element may be defined using one of the\n   * factories in the {@link webdriver.By} namespace, or as a short-hand\n   * {@link webdriver.By.Hash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = driver.findElement(By.id('foo'));\n   *     var e2 = driver.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = driver.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(driver) {\n   *       var links = driver.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {}\n\n  /**\n   * Search for multiple elements on the page. Refer to the documentation on\n   * {@link #findElement(by)} for information on element locator strategies.\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  findElements(locator) {}\n\n  /**\n   * Takes a screenshot of the current page. The driver makes a best effort to\n   * return a screenshot of the following, in order of preference:\n   *\n   * 1. Entire page\n   * 2. Current window\n   * 3. Visible portion of the current frame\n   * 4. The entire display containing the browser\n   *\n   * @return {!Promise<string>} A promise that will be resolved to the\n   *     screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot() {}\n\n  /**\n   * @return {!Options} The options interface for this instance.\n   */\n  manage() {}\n\n  /**\n   * @return {!Navigation} The navigation interface for this instance.\n   */\n  navigate() {}\n\n  /**\n   * @return {!TargetLocator} The target locator interface for this\n   *     instance.\n   */\n  switchTo() {}\n}\n\n\n/**\n * @param {!Capabilities} capabilities A capabilities object.\n * @return {!Capabilities} A copy of the parameter capabilities, omitting\n *     capability names that are not valid W3C names.\n */\nfunction filterNonW3CCaps(capabilities) {\n  let newCaps = new Capabilities(capabilities);\n  for (let k of newCaps.keys()) {\n    // Any key containing a colon is a vendor-prefixed capability.\n    if (!(W3C_CAPABILITY_NAMES.has(k) || k.indexOf(':') >= 0)) {\n      newCaps.delete(k);\n    }\n  }\n  return newCaps;\n}\n\n\n/**\n * Each WebDriver instance provides automated control over a browser session.\n *\n * @implements {IWebDriver}\n */\nclass WebDriver {\n  /**\n   * @param {!(Session|IThenable<!Session>)} session Either a known session or a\n   *     promise that will be resolved to a session.\n   * @param {!command.Executor} executor The executor to use when sending\n   *     commands to the browser.\n   * @param {(function(this: void): ?)=} onQuit A function to call, if any,\n   *     when the session is terminated.\n   */\n  constructor(session, executor, onQuit = undefined) {\n    /** @private {!Promise<!Session>} */\n    this.session_ = Promise.resolve(session);\n\n    // If session is a rejected promise, add a no-op rejection handler.\n    // This effectively hides setup errors until users attempt to interact\n    // with the session.\n    this.session_.catch(function() {});\n\n    /** @private {!command.Executor} */\n    this.executor_ = executor;\n\n    /** @private {input.FileDetector} */\n    this.fileDetector_ = null;\n\n    /** @private @const {(function(this: void): ?|undefined)} */\n    this.onQuit_ = onQuit;\n  }\n\n  /**\n   * Creates a new WebDriver session.\n   *\n   * This function will always return a WebDriver instance. If there is an error\n   * creating the session, such as the aforementioned SessionNotCreatedError,\n   * the driver will have a rejected {@linkplain #getSession session} promise.\n   * This rejection will propagate through any subsequent commands scheduled\n   * on the returned WebDriver instance.\n   *\n   *     let required = Capabilities.firefox();\n   *     let driver = WebDriver.createSession(executor, {required});\n   *\n   *     // If the createSession operation failed, then this command will also\n   *     // also fail, propagating the creation failure.\n   *     driver.get('http://www.google.com').catch(e => console.log(e));\n   *\n   * @param {!command.Executor} executor The executor to create the new session\n   *     with.\n   * @param {!Capabilities} capabilities The desired capabilities for the new\n   *     session.\n   * @param {(function(this: void): ?)=} onQuit A callback to invoke when\n   *    the newly created session is terminated. This should be used to clean\n   *    up any resources associated with the session.\n   * @return {!WebDriver} The driver for the newly created session.\n   */\n  static createSession(executor, capabilities, onQuit = undefined) {\n    let cmd = new command.Command(command.Name.NEW_SESSION);\n\n    // For OSS remote ends.\n    cmd.setParameter('desiredCapabilities', capabilities);\n    // For W3C remote ends.\n    cmd.setParameter('capabilities', {\n      alwaysMatch: filterNonW3CCaps(capabilities),\n    });\n\n    let session = executeCommand(executor, cmd);\n    if (typeof onQuit === 'function') {\n      session = session.catch(err => {\n        return Promise.resolve(onQuit.call(void 0)).then(_ => {throw err;});\n      });\n    }\n    return new this(session, executor, onQuit);\n  }\n\n  /** @override */\n  async execute(command) {\n    command.setParameter('sessionId', this.session_);\n    let parameters = await toWireValue(command.getParameters());\n    command.setParameters(parameters);\n    let value = await this.executor_.execute(command);\n    return fromWireValue(this, value);\n  }\n\n  /** @override */\n  setFileDetector(detector) {\n    this.fileDetector_ = detector;\n  }\n\n  /** @override */\n  getExecutor() {\n    return this.executor_;\n  }\n\n  /** @override */\n  getSession() {\n    return this.session_;\n  }\n\n  /** @override */\n  getCapabilities() {\n    return this.session_.then(s => s.getCapabilities());\n  }\n\n  /** @override */\n  quit() {\n    let result = this.execute(new command.Command(command.Name.QUIT));\n    // Delete our session ID when the quit command finishes; this will allow us\n    // to throw an error when attempting to use a driver post-quit.\n    return promise.finally(result, () => {\n      this.session_ = Promise.reject(new error.NoSuchSessionError(\n            'This driver instance does not have a valid session ID ' +\n            '(did you call WebDriver.quit()?) and may no longer be used.'));\n\n      // Only want the session rejection to bubble if accessed.\n      this.session_.catch(function() {});\n\n      if (this.onQuit_) {\n        return this.onQuit_.call(void 0);\n      }\n    });\n  }\n\n  /** @override */\n  actions(options) {\n    return new input.Actions(this, options || undefined);\n  }\n\n  /** @override */\n  executeScript(script, ...args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n   return this.execute(\n        new command.Command(command.Name.EXECUTE_SCRIPT).\n            setParameter('script', script).\n            setParameter('args', args));\n  }\n\n  /** @override */\n  executeAsyncScript(script, ...args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n    return this.execute(\n        new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT).\n            setParameter('script', script).\n            setParameter('args', args));\n  }\n\n  /** @override */\n  wait(condition, timeout = 0, message = undefined) {\n    if (typeof timeout !== 'number' || timeout < 0) {\n      throw TypeError('timeout must be a number >= 0: ' + timeout);\n    }\n\n    if (promise.isPromise(condition)) {\n      return new Promise((resolve, reject) => {\n        if (!timeout) {\n          resolve(condition);\n          return;\n        }\n\n        let start = Date.now();\n        let timer = setTimeout(function() {\n          timer = null;\n          reject(\n              new error.TimeoutError(\n                  (message ? `${message}\\n` : '')\n                      + 'Timed out waiting for promise to resolve after '\n                      + (Date.now() - start) + 'ms'));\n        }, timeout);\n        const clearTimer = () => timer && clearTimeout(timer);\n\n        /** @type {!IThenable} */(condition).then(\n            function(value) {\n              clearTimer();\n              resolve(value);\n            },\n            function(error) {\n              clearTimer();\n              reject(error);\n            });\n      });\n    }\n\n    let fn = /** @type {!Function} */(condition);\n    if (condition instanceof Condition) {\n      message = message || condition.description();\n      fn = condition.fn;\n    }\n\n    if (typeof fn !== 'function') {\n      throw TypeError(\n          'Wait condition must be a promise-like object, function, or a '\n              + 'Condition object');\n    }\n\n    const driver = this;\n    function evaluateCondition() {\n      return new Promise((resolve, reject) => {\n        try {\n          resolve(fn(driver));\n        } catch (ex) {\n          reject(ex);\n        }\n      });\n    }\n\n    let result = new Promise((resolve, reject) => {\n      const startTime = Date.now();\n      const pollCondition = async () => {\n        evaluateCondition().then(function(value) {\n          const elapsed = Date.now() - startTime;\n          if (!!value) {\n            resolve(value);\n          } else if (timeout && elapsed >= timeout) {\n            reject(\n                new error.TimeoutError(\n                  (message ? `${message}\\n` : '')\n                        + `Wait timed out after ${elapsed}ms`));\n          } else {\n            setTimeout(pollCondition, 0);\n          }\n        }, reject);\n      };\n      pollCondition();\n    });\n\n    if (condition instanceof WebElementCondition) {\n      result = new WebElementPromise(this, result.then(function(value) {\n        if (!(value instanceof WebElement)) {\n          throw TypeError(\n              'WebElementCondition did not resolve to a WebElement: '\n                  + Object.prototype.toString.call(value));\n        }\n        return value;\n      }));\n    }\n    return result;\n  }\n\n  /** @override */\n  sleep(ms) {\n    return new Promise(resolve => setTimeout(() => resolve(), ms));\n  }\n\n  /** @override */\n  getWindowHandle() {\n    return this.execute(\n        new command.Command(command.Name.GET_CURRENT_WINDOW_HANDLE));\n  }\n\n  /** @override */\n  getAllWindowHandles() {\n    return this.execute(\n        new command.Command(command.Name.GET_WINDOW_HANDLES));\n  }\n\n  /** @override */\n  getPageSource() {\n    return this.execute(\n        new command.Command(command.Name.GET_PAGE_SOURCE));\n  }\n\n  /** @override */\n  close() {\n    return this.execute(new command.Command(command.Name.CLOSE));\n  }\n\n  /** @override */\n  get(url) {\n    return this.navigate().to(url);\n  }\n\n  /** @override */\n  getCurrentUrl() {\n    return this.execute(new command.Command(command.Name.GET_CURRENT_URL));\n  }\n\n  /** @override */\n  getTitle() {\n    return this.execute(new command.Command(command.Name.GET_TITLE));\n  }\n\n  /** @override */\n  findElement(locator) {\n    let id;\n    locator = by.checkedLocator(locator);\n    if (typeof locator === 'function') {\n      id = this.findElementInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENT).\n          setParameter('using', locator.using).\n          setParameter('value', locator.value);\n      id = this.execute(cmd);\n    }\n    return new WebElementPromise(this, id);\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!Promise<!WebElement>} A promise that will resolve to a list of\n   *     WebElements.\n   * @private\n   */\n  async findElementInternal_(locatorFn, context) {\n    let result = await locatorFn(context);\n    if (Array.isArray(result)) {\n      result = result[0];\n    }\n    if (!(result instanceof WebElement)) {\n      throw new TypeError('Custom locator did not return a WebElement');\n    }\n    return result;\n  }\n\n  /** @override */\n  async findElements(locator) {\n    locator = by.checkedLocator(locator);\n    if (typeof locator === 'function') {\n      return this.findElementsInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENTS).\n          setParameter('using', locator.using).\n          setParameter('value', locator.value);\n      try {\n        let res = await this.execute(cmd);\n        return Array.isArray(res) ? res : [];\n      } catch (ex) {\n        if (ex instanceof error.NoSuchElementError) {\n          return [];\n        }\n        throw ex;\n      }\n    }\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   * @private\n   */\n  async findElementsInternal_(locatorFn, context) {\n    const result = await locatorFn(context);\n    if (result instanceof WebElement) {\n      return [result];\n    }\n\n    if (!Array.isArray(result)) {\n      return [];\n    }\n\n    return result.filter(function(item) {\n      return item instanceof WebElement;\n    });\n  }\n\n  /** @override */\n  takeScreenshot() {\n    return this.execute(new command.Command(command.Name.SCREENSHOT));\n  }\n\n  /** @override */\n  manage() {\n    return new Options(this);\n  }\n\n  /** @override */\n  navigate() {\n    return new Navigation(this);\n  }\n\n  /** @override */\n  switchTo() {\n    return new TargetLocator(this);\n  }\n}\n\n\n/**\n * Interface for navigating back and forth in the browser history.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.navigate()\n *\n * @see WebDriver#navigate()\n */\nclass Navigation {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Navigates to a new URL.\n   *\n   * @param {string} url The URL to navigate to.\n   * @return {!Promise<void>} A promise that will be resolved when the URL\n   *     has been loaded.\n   */\n  to(url) {\n    return this.driver_.execute(\n        new command.Command(command.Name.GET).\n            setParameter('url', url));\n  }\n\n  /**\n   * Moves backwards in the browser history.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  back() {\n    return this.driver_.execute(new command.Command(command.Name.GO_BACK));\n  }\n\n  /**\n   * Moves forwards in the browser history.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  forward() {\n    return this.driver_.execute(new command.Command(command.Name.GO_FORWARD));\n  }\n\n  /**\n   * Refreshes the current page.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  refresh() {\n    return this.driver_.execute(new command.Command(command.Name.REFRESH));\n  }\n}\n\n\n/**\n * Provides methods for managing browser and driver state.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with {@linkplain WebDriver#manage() webdriver.manage()}.\n */\nclass Options {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Adds a cookie.\n   *\n   * __Sample Usage:__\n   *\n   *     // Set a basic cookie.\n   *     driver.manage().addCookie({name: 'foo', value: 'bar'});\n   *\n   *     // Set a cookie that expires in 10 minutes.\n   *     let expiry = new Date(Date.now() + (10 * 60 * 1000));\n   *     driver.manage().addCookie({name: 'foo', value: 'bar', expiry});\n   *\n   *     // The cookie expiration may also be specified in seconds since epoch.\n   *     driver.manage().addCookie({\n   *       name: 'foo',\n   *       value: 'bar',\n   *       expiry: Math.floor(Date.now() / 1000)\n   *     });\n   *\n   * @param {!Options.Cookie} spec Defines the cookie to add.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the cookie has been added to the page.\n   * @throws {error.InvalidArgumentError} if any of the cookie parameters are\n   *     invalid.\n   * @throws {TypeError} if `spec` is not a cookie object.\n   */\n  addCookie({name, value, path, domain, secure, httpOnly, expiry}) {\n    // We do not allow '=' or ';' in the name.\n    if (/[;=]/.test(name)) {\n      throw new error.InvalidArgumentError(\n          'Invalid cookie name \"' + name + '\"');\n    }\n\n    // We do not allow ';' in value.\n    if (/;/.test(value)) {\n      throw new error.InvalidArgumentError(\n          'Invalid cookie value \"' + value + '\"');\n    }\n\n    if (typeof expiry === 'number') {\n      expiry = Math.floor(expiry);\n    } else if (expiry instanceof Date) {\n      let date = /** @type {!Date} */(expiry);\n      expiry = Math.floor(date.getTime() / 1000);\n    }\n\n    return this.driver_.execute(\n        new command.Command(command.Name.ADD_COOKIE).\n            setParameter('cookie', {\n              'name': name,\n              'value': value,\n              'path': path,\n              'domain': domain,\n              'secure': !!secure,\n              'httpOnly': !!httpOnly,\n              'expiry': expiry\n            }));\n  }\n\n  /**\n   * Deletes all cookies visible to the current page.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when all cookies have been deleted.\n   */\n  deleteAllCookies() {\n    return this.driver_.execute(\n        new command.Command(command.Name.DELETE_ALL_COOKIES));\n  }\n\n  /**\n   * Deletes the cookie with the given name. This command is a no-op if there is\n   * no cookie with the given name visible to the current page.\n   *\n   * @param {string} name The name of the cookie to delete.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the cookie has been deleted.\n   */\n  deleteCookie(name) {\n    return this.driver_.execute(\n        new command.Command(command.Name.DELETE_COOKIE).\n            setParameter('name', name));\n  }\n\n  /**\n   * Retrieves all cookies visible to the current page. Each cookie will be\n   * returned as a JSON object as described by the WebDriver wire protocol.\n   *\n   * @return {!Promise<!Array<!Options.Cookie>>} A promise that will be\n   *     resolved with the cookies visible to the current browsing context.\n   */\n  getCookies() {\n    return this.driver_.execute(\n        new command.Command(command.Name.GET_ALL_COOKIES));\n  }\n\n  /**\n   * Retrieves the cookie with the given name. Returns null if there is no such\n   * cookie. The cookie will be returned as a JSON object as described by the\n   * WebDriver wire protocol.\n   *\n   * @param {string} name The name of the cookie to retrieve.\n   * @return {!Promise<?Options.Cookie>} A promise that will be resolved\n   *     with the named cookie, or `null` if there is no such cookie.\n   */\n  async getCookie(name) {\n    try {\n      const cookie =\n          await this.driver_.execute(\n              new command.Command(command.Name.GET_COOKIE)\n                  .setParameter('name', name));\n      return cookie;\n    } catch (err) {\n      if (!(err instanceof error.UnknownCommandError)\n          && !(err instanceof error.UnsupportedOperationError)) {\n        throw err;\n      }\n\n      const cookies = await this.getCookies();\n      for (let cookie of cookies) {\n        if (cookie && cookie['name'] === name) {\n          return cookie;\n        }\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Fetches the timeouts currently configured for the current session.\n   *\n   * @return {!Promise<{script: number,\n   *                             pageLoad: number,\n   *                             implicit: number}>} A promise that will be\n   *     resolved with the timeouts currently configured for the current\n   *     session.\n   * @see #setTimeouts()\n   */\n  getTimeouts() {\n    return this.driver_.execute(new command.Command(command.Name.GET_TIMEOUT));\n  }\n\n  /**\n   * Sets the timeout durations associated with the current session.\n   *\n   * The following timeouts are supported (all timeouts are specified in\n   * milliseconds):\n   *\n   * -  `implicit` specifies the maximum amount of time to wait for an element\n   *    locator to succeed when {@linkplain WebDriver#findElement locating}\n   *    {@linkplain WebDriver#findElements elements} on the page.\n   *    Defaults to 0 milliseconds.\n   *\n   * -  `pageLoad` specifies the maximum amount of time to wait for a page to\n   *    finishing loading. Defaults to 300000 milliseconds.\n   *\n   * -  `script` specifies the maximum amount of time to wait for an\n   *    {@linkplain WebDriver#executeScript evaluated script} to run. If set to\n   *    `null`, the script timeout will be indefinite.\n   *    Defaults to 30000 milliseconds.\n   *\n   * @param {{script: (number|null|undefined),\n   *          pageLoad: (number|null|undefined),\n   *          implicit: (number|null|undefined)}} conf\n   *     The desired timeout configuration.\n   * @return {!Promise<void>} A promise that will be resolved when the timeouts\n   *     have been set.\n   * @throws {!TypeError} if an invalid options object is provided.\n   * @see #getTimeouts()\n   * @see <https://w3c.github.io/webdriver/webdriver-spec.html#dfn-set-timeouts>\n   */\n  setTimeouts({script, pageLoad, implicit} = {}) {\n    let cmd = new command.Command(command.Name.SET_TIMEOUT);\n\n    let valid = false;\n    function setParam(key, value) {\n      if (value === null || typeof value === 'number') {\n        valid = true;\n        cmd.setParameter(key, value);\n      } else if (typeof value !== 'undefined') {\n        throw TypeError(\n            'invalid timeouts configuration:'\n                + ` expected \"${key}\" to be a number, got ${typeof value}`);\n      }\n    }\n    setParam('implicit', implicit);\n    setParam('pageLoad', pageLoad);\n    setParam('script', script);\n\n    if (valid) {\n      return this.driver_.execute(cmd)\n          .catch(() => {\n            // Fallback to the legacy method.\n            let cmds = [];\n            if (typeof script === 'number') {\n              cmds.push(legacyTimeout(this.driver_, 'script', script));\n            }\n            if (typeof implicit === 'number') {\n              cmds.push(legacyTimeout(this.driver_, 'implicit', implicit));\n            }\n            if (typeof pageLoad === 'number') {\n              cmds.push(legacyTimeout(this.driver_, 'page load', pageLoad));\n            }\n            return Promise.all(cmds);\n          });\n    }\n    throw TypeError('no timeouts specified');\n  }\n\n  /**\n   * @return {!Logs} The interface for managing driver logs.\n   */\n  logs() {\n    return new Logs(this.driver_);\n  }\n\n  /**\n   * @return {!Window} The interface for managing the current window.\n   */\n  window() {\n    return new Window(this.driver_);\n  }\n}\n\n\n/**\n * @param {!WebDriver} driver\n * @param {string} type\n * @param {number} ms\n * @return {!Promise<void>}\n */\nfunction legacyTimeout(driver, type, ms) {\n  return driver.execute(\n      new command.Command(command.Name.SET_TIMEOUT)\n          .setParameter('type', type)\n          .setParameter('ms', ms));\n}\n\n\n\n/**\n * A record object describing a browser cookie.\n *\n * @record\n */\nOptions.Cookie = function() {};\n\n\n/**\n * The name of the cookie.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.name;\n\n\n/**\n * The cookie value.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.value;\n\n\n/**\n * The cookie path. Defaults to \"/\" when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.path;\n\n\n/**\n * The domain the cookie is visible to. Defaults to the current browsing\n * context's document's URL when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.domain;\n\n\n/**\n * Whether the cookie is a secure cookie. Defaults to false when adding a new\n * cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.secure;\n\n\n/**\n * Whether the cookie is an HTTP only cookie. Defaults to false when adding a\n * new cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.httpOnly;\n\n\n/**\n * When the cookie expires.\n *\n * When {@linkplain Options#addCookie() adding a cookie}, this may be specified\n * as a {@link Date} object, or in _seconds_ since Unix epoch (January 1, 1970).\n *\n * The expiry is always returned in seconds since epoch when\n * {@linkplain Options#getCookies() retrieving cookies} from the browser.\n *\n * @type {(!Date|number|undefined)}\n */\nOptions.Cookie.prototype.expiry;\n\n\n/**\n * An interface for managing the current window.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.manage().window()\n *\n * @see WebDriver#manage()\n * @see Options#window()\n */\nclass Window {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Retrieves the a rect describing the current top-level window's size and\n   * position.\n   *\n   * @return {!Promise<{x: number, y: number, width: number, height: number}>}\n   *     A promise that will resolve to the window rect of the current window.\n   */\n  async getRect() {\n    try {\n      return await this.driver_.execute(\n          new command.Command(command.Name.GET_WINDOW_RECT));\n    } catch (ex) {\n      if (ex instanceof error.UnknownCommandError) {\n        let {width, height} =\n            await this.driver_.execute(\n                new command.Command(command.Name.GET_WINDOW_SIZE)\n                    .setParameter('windowHandle', 'current'));\n        let {x, y} =\n            await this.driver_.execute(\n                new command.Command(command.Name.GET_WINDOW_POSITION)\n                    .setParameter('windowHandle', 'current'));\n        return {x, y, width, height};\n      }\n      throw ex;\n    }\n  }\n\n  /**\n   * Sets the current top-level window's size and position. You may update just\n   * the size by omitting `width` & `height`, or just the position by omitting\n   * `x` & `y` options.\n   *\n   * @param {{x: (number|undefined),\n   *          y: (number|undefined),\n   *          width: (number|undefined),\n   *          height: (number|undefined)}} options\n   *     The desired window size and position.\n   * @return {!Promise<{x: number, y: number, width: number, height: number}>}\n   *     A promise that will resolve to the current widnow's updated window\n   *     rect.\n   */\n  async setRect({x, y, width, height}) {\n    try {\n      return await this.driver_.execute(\n          new command.Command(command.Name.SET_WINDOW_RECT)\n              .setParameters({x, y, width, height}));\n    } catch (ex) {\n      if (ex instanceof error.UnknownCommandError) {\n        if (typeof x === 'number' && typeof y === 'number') {\n          await this.driver_.execute(\n              new command.Command(command.Name.SET_WINDOW_POSITION)\n                  .setParameter('windowHandle', 'current')\n                  .setParameter('x', x)\n                  .setParameter('y', y));\n        }\n\n        if (typeof  width === 'number' && typeof height === 'number') {\n          await this.driver_.execute(\n              new command.Command(command.Name.SET_WINDOW_SIZE)\n                  .setParameter('windowHandle', 'current')\n                  .setParameter('width', width)\n                  .setParameter('height', height));\n        }\n        return this.getRect();\n      }\n      throw ex;\n    }\n  }\n\n  /**\n   * Maximizes the current window. The exact behavior of this command is\n   * specific to individual window managers, but typically involves increasing\n   * the window to the maximum available size without going full-screen.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  maximize() {\n    return this.driver_.execute(\n        new command.Command(command.Name.MAXIMIZE_WINDOW).\n            setParameter('windowHandle', 'current'));\n  }\n\n  /**\n   * Minimizes the current window. The exact behavior of this command is\n   * specific to individual window managers, but typicallly involves hiding\n   * the window in the system tray.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  minimize() {\n    return this.driver_.execute(\n        new command.Command(command.Name.MINIMIZE_WINDOW));\n  }\n\n  /**\n   * Invokes the \"full screen\" operation on the current window. The exact\n   * behavior of this command is specific to individual window managers, but\n   * this will typically increase the window size to the size of the physical\n   * display and hide the browser chrome.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   * @see <https://fullscreen.spec.whatwg.org/#fullscreen-an-element>\n   */\n  fullscreen() {\n    return this.driver_.execute(\n        new command.Command(command.Name.FULLSCREEN_WINDOW));\n  }\n}\n\n\n/**\n * Interface for managing WebDriver log records.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.manage().logs()\n *\n * @see WebDriver#manage()\n * @see Options#logs()\n */\nclass Logs {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Fetches available log entries for the given type.\n   *\n   * Note that log buffers are reset after each call, meaning that available\n   * log entries correspond to those entries not yet returned for a given log\n   * type. In practice, this means that this call will return the available log\n   * entries since the last call, or from the start of the session.\n   *\n   * @param {!logging.Type} type The desired log type.\n   * @return {!Promise<!Array.<!logging.Entry>>} A\n   *   promise that will resolve to a list of log entries for the specified\n   *   type.\n   */\n  get(type) {\n    let cmd = new command.Command(command.Name.GET_LOG).\n        setParameter('type', type);\n    return this.driver_.execute(cmd).\n        then(function(entries) {\n          return entries.map(function(entry) {\n            if (!(entry instanceof logging.Entry)) {\n              return new logging.Entry(\n                  entry['level'], entry['message'], entry['timestamp'],\n                  entry['type']);\n            }\n            return entry;\n          });\n        });\n  }\n\n  /**\n   * Retrieves the log types available to this driver.\n   * @return {!Promise<!Array<!logging.Type>>} A\n   *     promise that will resolve to a list of available log types.\n   */\n  getAvailableLogTypes() {\n    return this.driver_.execute(\n        new command.Command(command.Name.GET_AVAILABLE_LOG_TYPES));\n  }\n}\n\n\n/**\n * An interface for changing the focus of the driver to another frame or window.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.switchTo()\n *\n * @see WebDriver#switchTo()\n */\nclass TargetLocator {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Locates the DOM element on the current page that corresponds to\n   * `document.activeElement` or `document.body` if the active element is not\n   * available.\n   *\n   * @return {!WebElementPromise} The active element.\n   */\n  activeElement() {\n    var id = this.driver_.execute(\n        new command.Command(command.Name.GET_ACTIVE_ELEMENT));\n    return new WebElementPromise(this.driver_, id);\n  }\n\n  /**\n   * Switches focus of all future commands to the topmost frame in the current\n   * window.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the default content.\n   */\n  defaultContent() {\n    return this.driver_.execute(\n        new command.Command(command.Name.SWITCH_TO_FRAME).\n            setParameter('id', null));\n  }\n\n  /**\n   * Changes the focus of all future commands to another frame on the page. The\n   * target frame may be specified as one of the following:\n   *\n   * - A number that specifies a (zero-based) index into [window.frames](\n   *   https://developer.mozilla.org/en-US/docs/Web/API/Window.frames).\n   * - A {@link WebElement} reference, which correspond to a `frame` or `iframe`\n   *   DOM element.\n   * - The `null` value, to select the topmost frame on the page. Passing `null`\n   *   is the same as calling {@link #defaultContent defaultContent()}.\n   *\n   * If the specified frame can not be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchFrameError}.\n   *\n   * @param {(number|WebElement|null)} id The frame locator.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified frame.\n   */\n  frame(id) {\n    return this.driver_.execute(\n        new command.Command(command.Name.SWITCH_TO_FRAME).\n            setParameter('id', id));\n  }\n\n  /**\n   * Changes the focus of all future commands to the parent frame of the\n   * currently selected frame. This command has no effect if the driver is\n   * already focused on the top-level browsing context.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  parentFrame() {\n    return this.driver_.execute(\n        new command.Command(command.Name.SWITCH_TO_FRAME_PARENT));\n  }\n\n  /**\n   * Changes the focus of all future commands to another window. Windows may be\n   * specified by their {@code window.name} attribute or by its handle\n   * (as returned by {@link WebDriver#getWindowHandles}).\n   *\n   * If the specified window cannot be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchWindowError}.\n   *\n   * @param {string} nameOrHandle The name or window handle of the window to\n   *     switch focus to.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified window.\n   */\n  window(nameOrHandle) {\n    return this.driver_.execute(\n        new command.Command(command.Name.SWITCH_TO_WINDOW).\n            // \"name\" supports the legacy drivers. \"handle\" is the W3C\n            // compliant parameter.\n            setParameter('name', nameOrHandle).\n            setParameter('handle', nameOrHandle));\n  }\n\n  /**\n   * Changes focus to the active modal dialog, such as those opened by\n   * `window.alert()`, `window.confirm()`, and `window.prompt()`. The returned\n   * promise will be rejected with a\n   * {@linkplain error.NoSuchAlertError} if there are no open alerts.\n   *\n   * @return {!AlertPromise} The open alert.\n   */\n  alert() {\n    var text = this.driver_.execute(\n        new command.Command(command.Name.GET_ALERT_TEXT));\n    var driver = this.driver_;\n    return new AlertPromise(driver, text.then(function(text) {\n      return new Alert(driver, text);\n    }));\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebElement\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\nconst LEGACY_ELEMENT_ID_KEY = 'ELEMENT';\nconst ELEMENT_ID_KEY = 'element-6066-11e4-a52e-4f735466cecf';\n\n\n/**\n * Represents a DOM element. WebElements can be found by searching from the\n * document root using a {@link WebDriver} instance, or by searching\n * under another WebElement:\n *\n *     driver.get('http://www.google.com');\n *     var searchForm = driver.findElement(By.tagName('form'));\n *     var searchBox = searchForm.findElement(By.name('q'));\n *     searchBox.sendKeys('webdriver');\n */\nclass WebElement {\n  /**\n   * @param {!WebDriver} driver the parent WebDriver instance for this element.\n   * @param {(!IThenable<string>|string)} id The server-assigned opaque ID for\n   *     the underlying DOM element.\n   */\n  constructor(driver, id) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n\n    /** @private {!Promise<string>} */\n    this.id_ = Promise.resolve(id);\n  }\n\n  /**\n   * @param {string} id The raw ID.\n   * @param {boolean=} noLegacy Whether to exclude the legacy element key.\n   * @return {!Object} The element ID for use with WebDriver's wire protocol.\n   */\n  static buildId(id, noLegacy = false) {\n    return noLegacy\n        ? {[ELEMENT_ID_KEY]: id}\n        : {[ELEMENT_ID_KEY]: id, [LEGACY_ELEMENT_ID_KEY]: id};\n  }\n\n  /**\n   * Extracts the encoded WebElement ID from the object.\n   *\n   * @param {?} obj The object to extract the ID from.\n   * @return {string} the extracted ID.\n   * @throws {TypeError} if the object is not a valid encoded ID.\n   */\n  static extractId(obj) {\n    if (obj && typeof obj === 'object') {\n      if (typeof obj[ELEMENT_ID_KEY] === 'string') {\n        return obj[ELEMENT_ID_KEY];\n      } else if (typeof obj[LEGACY_ELEMENT_ID_KEY] === 'string') {\n        return obj[LEGACY_ELEMENT_ID_KEY];\n      }\n    }\n    throw new TypeError('object is not a WebElement ID');\n  }\n\n  /**\n   * @param {?} obj the object to test.\n   * @return {boolean} whether the object is a valid encoded WebElement ID.\n   */\n  static isId(obj) {\n    return obj && typeof obj === 'object'\n        && (typeof obj[ELEMENT_ID_KEY] === 'string'\n            || typeof obj[LEGACY_ELEMENT_ID_KEY] === 'string');\n  }\n\n  /**\n   * Compares two WebElements for equality.\n   *\n   * @param {!WebElement} a A WebElement.\n   * @param {!WebElement} b A WebElement.\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved to whether the two WebElements are equal.\n   */\n  static async equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    return a.driver_.executeScript('arguments[0] === arguments[1]', a, b);\n  }\n\n  /** @return {!WebDriver} The parent driver for this instance. */\n  getDriver() {\n    return this.driver_;\n  }\n\n  /**\n   * @return {!Promise<string>} A promise that resolves to\n   *     the server-assigned opaque ID assigned to this element.\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {!Object} Returns the serialized representation of this WebElement.\n   */\n  [Symbols.serialize]() {\n    return this.getId().then(WebElement.buildId);\n  }\n\n  /**\n   * Schedules a command that targets this element with the parent WebDriver\n   * instance. Will ensure this element's ID is included in the command\n   * parameters under the \"id\" key.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the result.\n   * @template T\n   * @see WebDriver#schedule\n   * @private\n   */\n  execute_(command) {\n    command.setParameter('id', this);\n    return this.driver_.execute(command);\n  }\n\n  /**\n   * Schedule a command to find a descendant of this element. If the element\n   * cannot be found, the returned promise will be rejected with a\n   * {@linkplain error.NoSuchElementError NoSuchElementError}.\n   *\n   * The search criteria for an element may be defined using one of the static\n   * factories on the {@link by.By} class, or as a short-hand\n   * {@link ./by.ByHash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = element.findElement(By.id('foo'));\n   *     var e2 = element.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = element.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(element) {\n   *       var links = element.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {\n    locator = by.checkedLocator(locator);\n    let id;\n    if (typeof locator === 'function') {\n      id = this.driver_.findElementInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(\n          command.Name.FIND_CHILD_ELEMENT).\n          setParameter('using', locator.using).\n          setParameter('value', locator.value);\n      id = this.execute_(cmd);\n    }\n    return new WebElementPromise(this.driver_, id);\n  }\n\n  /**\n   * Locates all of the descendants of this element that match the given search\n   * criteria.\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  async findElements(locator) {\n    locator = by.checkedLocator(locator);\n    let id;\n    if (typeof locator === 'function') {\n      return this.driver_.findElementsInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENTS)\n          .setParameter('using', locator.using)\n          .setParameter('value', locator.value);\n      let result = await this.execute_(cmd);\n      return Array.isArray(result) ? result : [];\n    }\n  }\n\n  /**\n   * Clicks on this element.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the click\n   *     command has completed.\n   */\n  click() {\n    return this.execute_(new command.Command(command.Name.CLICK_ELEMENT));\n  }\n\n  /**\n   * Types a key sequence on the DOM element represented by this instance.\n   *\n   * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is\n   * processed in the key sequence, that key state is toggled until one of the\n   * following occurs:\n   *\n   * - The modifier key is encountered again in the sequence. At this point the\n   *   state of the key is toggled (along with the appropriate keyup/down\n   *   events).\n   * - The {@link input.Key.NULL} key is encountered in the sequence. When\n   *   this key is encountered, all modifier keys current in the down state are\n   *   released (with accompanying keyup events). The NULL key can be used to\n   *   simulate common keyboard shortcuts:\n   *\n   *         element.sendKeys(\"text was\",\n   *                          Key.CONTROL, \"a\", Key.NULL,\n   *                          \"now text is\");\n   *         // Alternatively:\n   *         element.sendKeys(\"text was\",\n   *                          Key.chord(Key.CONTROL, \"a\"),\n   *                          \"now text is\");\n   *\n   * - The end of the key sequence is encountered. When there are no more keys\n   *   to type, all depressed modifier keys are released (with accompanying\n   *   keyup events).\n   *\n   * If this element is a file input ({@code <input type=\"file\">}), the\n   * specified key sequence should specify the path to the file to attach to\n   * the element. This is analogous to the user clicking \"Browse...\" and entering\n   * the path into the file select dialog.\n   *\n   *     var form = driver.findElement(By.css('form'));\n   *     var element = form.findElement(By.css('input[type=file]'));\n   *     element.sendKeys('/path/to/file.txt');\n   *     form.submit();\n   *\n   * For uploads to function correctly, the entered path must reference a file\n   * on the _browser's_ machine, not the local machine running this script. When\n   * running against a remote Selenium server, a {@link input.FileDetector}\n   * may be used to transparently copy files to the remote machine before\n   * attempting to upload them in the browser.\n   *\n   * __Note:__ On browsers where native keyboard events are not supported\n   * (e.g. Firefox on OS X), key events will be synthesized. Special\n   * punctuation keys will be synthesized according to a standard QWERTY en-us\n   * keyboard layout.\n   *\n   * @param {...(number|string|!IThenable<(number|string)>)} args The\n   *     sequence of keys to type. Number keys may be referenced numerically or\n   *     by string (1 or '1'). All arguments will be joined into a single\n   *     sequence.\n   * @return {!Promise<void>} A promise that will be resolved when all keys\n   *     have been typed.\n   */\n  async sendKeys(...args) {\n    let keys = [];\n    (await Promise.all(args)).forEach(key => {\n      let type = typeof key;\n      if (type === 'number') {\n        key = String(key);\n      } else if (type !== 'string') {\n        throw TypeError('each key must be a number of string; got ' + type);\n      }\n\n      // The W3C protocol requires keys to be specified as an array where\n      // each element is a single key.\n      keys.push(...key.split(''));\n    });\n\n    if (!this.driver_.fileDetector_) {\n      return this.execute_(\n          new command.Command(command.Name.SEND_KEYS_TO_ELEMENT)\n              .setParameter('text', keys.join(''))\n              .setParameter('value', keys));\n    }\n\n    keys =\n        await this.driver_.fileDetector_.handleFile(\n            this.driver_, keys.join(''));\n    return this.execute_(\n        new command.Command(command.Name.SEND_KEYS_TO_ELEMENT)\n            .setParameter('text', keys)\n            .setParameter('value', keys.split('')));\n  }\n\n  /**\n   * Retrieves the element's tag name.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     element's tag name.\n   */\n  getTagName() {\n    return this.execute_(\n        new command.Command(command.Name.GET_ELEMENT_TAG_NAME));\n  }\n\n  /**\n   * Retrieves the value of a computed style property for this instance. If\n   * the element inherits the named style from its parent, the parent will be\n   * queried for its value.  Where possible, color values will be converted to\n   * their hex representation (e.g. #00ff00 instead of rgb(0, 255, 0)).\n   *\n   * _Warning:_ the value returned will be as the browser interprets it, so\n   * it may be tricky to form a proper assertion.\n   *\n   * @param {string} cssStyleProperty The name of the CSS style property to look\n   *     up.\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     requested CSS value.\n   */\n  getCssValue(cssStyleProperty) {\n    var name = command.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY;\n    return this.execute_(\n        new command.Command(name).\n            setParameter('propertyName', cssStyleProperty));\n  }\n\n  /**\n   * Retrieves the current value of the given attribute of this element.\n   * Will return the current value, even if it has been modified after the page\n   * has been loaded. More exactly, this method will return the value\n   * of the given attribute, unless that attribute is not present, in which case\n   * the value of the property with the same name is returned. If neither value\n   * is set, null is returned (for example, the \"value\" property of a textarea\n   * element). The \"style\" attribute is converted as best can be to a\n   * text representation with a trailing semi-colon. The following are deemed to\n   * be \"boolean\" attributes and will return either \"true\" or null:\n   *\n   * async, autofocus, autoplay, checked, compact, complete, controls, declare,\n   * defaultchecked, defaultselected, defer, disabled, draggable, ended,\n   * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,\n   * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,\n   * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,\n   * selected, spellcheck, truespeed, willvalidate\n   *\n   * Finally, the following commonly mis-capitalized attribute/property names\n   * are evaluated as expected:\n   *\n   * - \"class\"\n   * - \"readonly\"\n   *\n   * @param {string} attributeName The name of the attribute to query.\n   * @return {!Promise<?string>} A promise that will be\n   *     resolved with the attribute's value. The returned value will always be\n   *     either a string or null.\n   */\n  getAttribute(attributeName) {\n    return this.execute_(\n        new command.Command(command.Name.GET_ELEMENT_ATTRIBUTE).\n            setParameter('name', attributeName));\n  }\n\n  /**\n   * Get the visible (i.e. not hidden by CSS) innerText of this element,\n   * including sub-elements, without any leading or trailing whitespace.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's visible text.\n   */\n  getText() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_TEXT));\n  }\n\n  /**\n   * Returns an object describing an element's location, in pixels relative to\n   * the document element, and the element's size in pixels.\n   *\n   * @return {!Promise<{width: number, height: number, x: number, y: number}>}\n   *     A promise that will resolve with the element's rect.\n   */\n  async getRect() {\n    try {\n      return await this.execute_(\n          new command.Command(command.Name.GET_ELEMENT_RECT));\n    } catch (err) {\n      if (err instanceof error.UnknownCommandError) {\n        const {width, height} =\n            await this.execute_(\n                new command.Command(command.Name.GET_ELEMENT_SIZE));\n        const {x, y} =\n            await this.execute_(\n                new command.Command(command.Name.GET_ELEMENT_LOCATION));\n        return {x, y, width, height};\n      }\n    }\n  }\n\n  /**\n   * Tests whether this element is enabled, as dictated by the `disabled`\n   * attribute.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently enabled.\n   */\n  isEnabled() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_ENABLED));\n  }\n\n  /**\n   * Tests whether this element is selected.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently selected.\n   */\n  isSelected() {\n    return this.execute_(\n        new command.Command(command.Name.IS_ELEMENT_SELECTED));\n  }\n\n  /**\n   * Submits the form containing this element (or this element if it is itself\n   * a FORM element). his command is a no-op if the element is not contained in\n   * a form.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the form has been submitted.\n   */\n  submit() {\n    return this.execute_(new command.Command(command.Name.SUBMIT_ELEMENT));\n  }\n\n  /**\n   * Clear the `value` of this element. This command has no effect if the\n   * underlying DOM element is neither a text INPUT element nor a TEXTAREA\n   * element.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the element has been cleared.\n   */\n  clear() {\n    return this.execute_(new command.Command(command.Name.CLEAR_ELEMENT));\n  }\n\n  /**\n   * Test whether this element is currently displayed.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently visible on the page.\n   */\n  isDisplayed() {\n    return this.execute_(\n        new command.Command(command.Name.IS_ELEMENT_DISPLAYED));\n  }\n\n  /**\n   * Take a screenshot of the visible region encompassed by this element's\n   * bounding rectangle.\n   *\n   * @param {boolean=} scroll Optional argument that indicates whether the\n   *     element should be scrolled into view before taking a screenshot.\n   *     Defaults to false.\n   * @return {!Promise<string>} A promise that will be\n   *     resolved to the screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot(scroll = false) {\n    return this.execute_(\n        new command.Command(command.Name.TAKE_ELEMENT_SCREENSHOT)\n            .setParameter('scroll', scroll));\n  }\n}\n\n\n/**\n * WebElementPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on WebElement, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * WebElement has been fulfilled. In other words, the following two statements\n * are equivalent:\n *\n *     driver.findElement({id: 'my-button'}).click();\n *     driver.findElement({id: 'my-button'}).then(function(el) {\n *       return el.click();\n *     });\n *\n * @implements {IThenable<!WebElement>}\n * @final\n */\nclass WebElementPromise extends WebElement {\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!Promise<!WebElement>} el A promise\n   *     that will resolve to the promised element.\n   */\n  constructor(driver, el) {\n    super(driver, 'unused');\n\n    /** @override */\n    this.then = el.then.bind(el);\n\n    /** @override */\n    this.catch = el.catch.bind(el);\n\n    /**\n     * Defers returning the element ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n    this.getId = function() {\n      return el.then(function(el) {\n        return el.getId();\n      });\n    };\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  Alert\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\n/**\n * Represents a modal dialog such as {@code alert}, {@code confirm}, or\n * {@code prompt}. Provides functions to retrieve the message displayed with\n * the alert, accept or dismiss the alert, and set the response text (in the\n * case of {@code prompt}).\n */\nclass Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this alert\n   *     is attached to.\n   * @param {string} text The message text displayed with this alert.\n   */\n  constructor(driver, text) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n\n    /** @private {!Promise<string>} */\n    this.text_ = Promise.resolve(text);\n  }\n\n  /**\n   * Retrieves the message text displayed with this alert. For instance, if the\n   * alert were opened with alert(\"hello\"), then this would return \"hello\".\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved to the text displayed with this alert.\n   */\n  getText() {\n    return this.text_;\n  }\n\n  /**\n   * Accepts this alert.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  accept() {\n    return this.driver_.execute(\n        new command.Command(command.Name.ACCEPT_ALERT));\n  }\n\n  /**\n   * Dismisses this alert.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  dismiss() {\n    return this.driver_.execute(\n        new command.Command(command.Name.DISMISS_ALERT));\n  }\n\n  /**\n   * Sets the response text on this alert. This command will return an error if\n   * the underlying alert does not support response text (e.g. window.alert and\n   * window.confirm).\n   *\n   * @param {string} text The text to set.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  sendKeys(text) {\n    return this.driver_.execute(\n        new command.Command(command.Name.SET_ALERT_TEXT).\n            setParameter('text', text));\n  }\n}\n\n\n/**\n * AlertPromise is a promise that will be fulfilled with an Alert. This promise\n * serves as a forward proxy on an Alert, allowing calls to be scheduled\n * directly on this instance before the underlying Alert has been fulfilled. In\n * other words, the following two statements are equivalent:\n *\n *     driver.switchTo().alert().dismiss();\n *     driver.switchTo().alert().then(function(alert) {\n *       return alert.dismiss();\n *     });\n *\n * @implements {IThenable<!Alert>}\n * @final\n */\nclass AlertPromise extends Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this\n   *     alert is attached to.\n   * @param {!Promise<!Alert>} alert A thenable\n   *     that will be fulfilled with the promised alert.\n   */\n  constructor(driver, alert) {\n    super(driver, 'unused');\n\n    /** @override */\n    this.then = alert.then.bind(alert);\n\n    /** @override */\n    this.catch = alert.catch.bind(alert);\n\n    /**\n     * Defer returning text until the promised alert has been resolved.\n     * @override\n     */\n    this.getText = function() {\n      return alert.then(function(alert) {\n        return alert.getText();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.accept = function() {\n      return alert.then(function(alert) {\n        return alert.accept();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.dismiss = function() {\n      return alert.then(function(alert) {\n        return alert.dismiss();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.sendKeys = function(text) {\n      return alert.then(function(alert) {\n        return alert.sendKeys(text);\n      });\n    };\n  }\n}\n\n\n// PUBLIC API\n\n\nmodule.exports = {\n  Alert,\n  AlertPromise,\n  Condition,\n  Logs,\n  Navigation,\n  Options,\n  TargetLocator,\n  IWebDriver,\n  WebDriver,\n  WebElement,\n  WebElementCondition,\n  WebElementPromise,\n  Window\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/lib/webdriver.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/net/index.js":
/*!*******************************************************!*\
  !*** ../node_modules/selenium-webdriver/net/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\nconst os = __webpack_require__(/*! os */ \"os\");\n\n\nfunction getLoInterface() {\n  let name;\n  if (process.platform === 'darwin') {\n    name = 'lo0';\n  } else if (process.platform === 'linux') {\n    name = 'lo';\n  }\n  return name ? os.networkInterfaces()[name] : null;\n}\n\n\n/**\n * Queries the system network interfaces for an IP address.\n * @param {boolean} loopback Whether to find a loopback address.\n * @param {string} family The IP family (IPv4 or IPv6). Defaults to IPv4.\n * @return {(string|undefined)} The located IP address or undefined.\n */\nfunction getAddress(loopback, family) {\n  let interfaces;\n  if (loopback) {\n    let lo = getLoInterface();\n    interfaces = lo ? [lo] : null;\n  }\n  interfaces = interfaces || os.networkInterfaces();\n  for (let key in interfaces) {\n    if (!interfaces.hasOwnProperty(key)) {\n      continue;\n    }\n\n    for (let ipAddress of interfaces[key]) {\n      if (ipAddress.family === family && ipAddress.internal === loopback) {\n        return ipAddress.address;\n      }\n    }\n  }\n  return undefined;\n}\n\n\n// PUBLIC API\n\n\n/**\n * Retrieves the external IP address for this host.\n * @param {string=} family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {(string|undefined)} The IP address or undefined if not available.\n */\nexports.getAddress = function(family = 'IPv4') {\n  return getAddress(false, family);\n};\n\n\n/**\n * Retrieves a loopback address for this machine.\n * @param {string=} family The IP family to retrieve. Defaults to \"IPv4\".\n * @return {(string|undefined)} The IP address or undefined if not available.\n */\nexports.getLoopbackAddress = function(family = 'IPv4') {\n  return getAddress(true, family);\n};\n\n\n/**\n * Splits a hostport string, e.g. \"www.example.com:80\", into its component\n * parts.\n *\n * @param {string} hostport The string to split.\n * @return {{host: string, port: ?number}} A host and port. If no port is\n *     present in the argument `hostport`, port is null.\n */\nexports.splitHostAndPort = function(hostport) {\n  let lastIndex = hostport.lastIndexOf(':');\n  if (lastIndex < 0) {\n    return {host: hostport, port: null};\n  }\n\n  let firstIndex = hostport.indexOf(':');\n  if (firstIndex != lastIndex && !hostport.includes('[')) {\n    // Multiple colons but no brackets, so assume the string is an IPv6 address\n    // with no port (e.g. \"1234:5678:9:0:1234:5678:9:0\").\n    return {host: hostport, port: null};\n  }\n\n  let host = hostport.slice(0, lastIndex);\n  if (host.startsWith('[') && host.endsWith(']')) {\n    host = host.slice(1, -1);\n  }\n\n  let port = parseInt(hostport.slice(lastIndex + 1), 10);\n  return {host, port};\n};\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/net/index.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/net/portprober.js":
/*!************************************************************!*\
  !*** ../node_modules/selenium-webdriver/net/portprober.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst {exec} = __webpack_require__(/*! child_process */ \"child_process\");\n\n\n/**\n * The IANA suggested ephemeral port range.\n * @type {{min: number, max: number}}\n * @const\n * @see http://en.wikipedia.org/wiki/Ephemeral_ports\n */\nconst DEFAULT_IANA_RANGE = {min: 49152, max: 65535};\n\n\n/**\n * The epheremal port range for the current system. Lazily computed on first\n * access.\n * @type {Promise<{min: number, max: number}>}\n */\nlet systemRange = null;\n\n\n/**\n * Computes the ephemeral port range for the current system. This is based on\n * http://stackoverflow.com/a/924337.\n * @return {!Promise<{min: number, max: number}>} A promise that will resolve to\n *     the ephemeral port range of the current system.\n */\nfunction findSystemPortRange() {\n  if (systemRange) {\n    return systemRange;\n  }\n  let range =\n      process.platform === 'win32'\n          ? findWindowsPortRange() : findUnixPortRange();\n  return systemRange = range.catch(() => DEFAULT_IANA_RANGE);\n}\n\n\n/**\n * Executes a command and returns its output if it succeeds.\n * @param {string} cmd The command to execute.\n * @return {!Promise<string>} A promise that will resolve with the command's\n *     stdout data.\n */\nfunction execute(cmd) {\n  return new Promise((resolve, reject) => {\n    exec(cmd, function(err, stdout) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(stdout);\n      }\n    });\n  });\n}\n\n\n/**\n * Computes the ephemeral port range for a Unix-like system.\n * @return {!Promise<{min: number, max: number}>} A promise that will resolve\n *     with the ephemeral port range on the current system.\n */\nasync function findUnixPortRange() {\n  var cmd;\n  if (process.platform === 'sunos') {\n    cmd =\n        '/usr/sbin/ndd /dev/tcp tcp_smallest_anon_port tcp_largest_anon_port';\n  } else if (fs.existsSync('/proc/sys/net/ipv4/ip_local_port_range')) {\n    // Linux\n    cmd = 'cat /proc/sys/net/ipv4/ip_local_port_range';\n  } else {\n    cmd = 'sysctl net.inet.ip.portrange.first net.inet.ip.portrange.last' +\n        ' | sed -e \"s/.*:\\\\s*//\"';\n  }\n\n  let stdout = await execute(cmd);\n  if (!stdout || !stdout.length) {\n    return DEFAULT_IANA_RANGE;\n  };\n\n  let range = stdout.trim().split(/\\s+/).map(Number);\n  if (range.some(isNaN)) {\n    return DEFAULT_IANA_RANGE;\n  };\n\n  return {min: range[0], max: range[1]};\n}\n\n\n/**\n * Computes the ephemeral port range for a Windows system.\n * @return {!Promise<{min: number, max: number}>} A promise that will resolve\n *     with the ephemeral port range on the current system.\n */\nasync function findWindowsPortRange() {\n  // First, check if we're running on XP.  If this initial command fails,\n  // we just fallback on the default IANA range.\n  let stdout = await execute('cmd.exe /c ver');\n  if (/Windows XP/.test(stdout)) {\n    // TODO: Try to read these values from the registry.\n    return {min: 1025, max: 5000};\n  } else {\n    stdout = await execute('netsh int ipv4 show dynamicport tcp');\n    /* > netsh int ipv4 show dynamicport tcp\n      Protocol tcp Dynamic Port Range\n      ---------------------------------\n      Start Port : 49152\n      Number of Ports : 16384\n     */\n    let range = stdout.split(/\\n/)\n        .filter((line) => /.*:\\s*\\d+/.test(line))\n        .map((line) => Number(line.split(/:\\s*/)[1]));\n    return {\n      min: range[0],\n      max: range[0] + range[1]\n    };\n  }\n}\n\n\n/**\n * Tests if a port is free.\n * @param {number} port The port to test.\n * @param {string=} opt_host The bound host to test the {@code port} against.\n *     Defaults to {@code INADDR_ANY}.\n * @return {!Promise<boolean>} A promise that will resolve with whether the port\n *     is free.\n */\nfunction isFree(port, opt_host) {\n  return new Promise((resolve, reject) => {\n    let server = net.createServer().on('error', function(e) {\n      if (e.code === 'EADDRINUSE') {\n        resolve(false);\n      } else {\n        reject(e);\n      }\n    });\n\n    server.listen(port, opt_host, function() {\n      server.close(() => resolve(true));\n    });\n  });\n}\n\n\n/**\n * @param {string=} opt_host The bound host to test the {@code port} against.\n *     Defaults to {@code INADDR_ANY}.\n * @return {!Promise<number>} A promise that will resolve to a free port. If a\n *     port cannot be found, the promise will be rejected.\n */\nasync function findFreePort(opt_host) {\n  let range = await findSystemPortRange();\n  for (let i = 0; i < 100; i++) {\n    let port = Math.floor(Math.random() * (range.max - range.min) + range.min);\n    if (await isFree(port, opt_host)) {\n      return port;\n    }\n  }\n  throw Error('Unable to find a free port');\n}\n\n\n// PUBLIC API\n\n\nexports.findFreePort = findFreePort;\nexports.isFree = isFree;\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/net/portprober.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/remote/index.js":
/*!**********************************************************!*\
  !*** ../node_modules/selenium-webdriver/remote/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst httpUtil = __webpack_require__(/*! ../http/util */ \"../node_modules/selenium-webdriver/http/util.js\");\nconst io = __webpack_require__(/*! ../io */ \"../node_modules/selenium-webdriver/io/index.js\");\nconst exec = __webpack_require__(/*! ../io/exec */ \"../node_modules/selenium-webdriver/io/exec.js\");\nconst {Zip} = __webpack_require__(/*! ../io/zip */ \"../node_modules/selenium-webdriver/io/zip.js\");\nconst cmd = __webpack_require__(/*! ../lib/command */ \"../node_modules/selenium-webdriver/lib/command.js\");\nconst input = __webpack_require__(/*! ../lib/input */ \"../node_modules/selenium-webdriver/lib/input.js\");\nconst webdriver = __webpack_require__(/*! ../lib/webdriver */ \"../node_modules/selenium-webdriver/lib/webdriver.js\");\nconst net = __webpack_require__(/*! ../net */ \"../node_modules/selenium-webdriver/net/index.js\");\nconst portprober = __webpack_require__(/*! ../net/portprober */ \"../node_modules/selenium-webdriver/net/portprober.js\");\n\n\n/**\n * @typedef {(string|!Array<string|number|!stream.Stream|null|undefined>)}\n */\nvar StdIoOptions;\n\n\n/**\n * @typedef {(string|!IThenable<string>)}\n */\nvar CommandLineFlag;\n\n\n/**\n * A record object that defines the configuration options for a DriverService\n * instance.\n *\n * @record\n */\nfunction ServiceOptions() {}\n\n/**\n * Whether the service should only be accessed on this host's loopback address.\n *\n * @type {(boolean|undefined)}\n */\nServiceOptions.prototype.loopback;\n\n/**\n * The host name to access the server on. If this option is specified, the\n * {@link #loopback} option will be ignored.\n *\n * @type {(string|undefined)}\n */\nServiceOptions.prototype.hostname;\n\n/**\n * The port to start the server on (must be > 0). If the port is provided as a\n * promise, the service will wait for the promise to resolve before starting.\n *\n * @type {(number|!IThenable<number>)}\n */\nServiceOptions.prototype.port;\n\n/**\n * The arguments to pass to the service. If a promise is provided, the service\n * will wait for it to resolve before starting.\n *\n * @type {!(Array<CommandLineFlag>|IThenable<!Array<CommandLineFlag>>)}\n */\nServiceOptions.prototype.args;\n\n/**\n * The base path on the server for the WebDriver wire protocol (e.g. '/wd/hub').\n * Defaults to '/'.\n *\n * @type {(string|undefined|null)}\n */\nServiceOptions.prototype.path;\n\n/**\n * The environment variables that should be visible to the server process.\n * Defaults to inheriting the current process's environment.\n *\n * @type {(Object<string, string>|undefined)}\n */\nServiceOptions.prototype.env;\n\n/**\n * IO configuration for the spawned server process. For more information, refer\n * to the documentation of `child_process.spawn`.\n *\n * @type {(StdIoOptions|undefined)}\n * @see https://nodejs.org/dist/latest-v4.x/docs/api/child_process.html#child_process_options_stdio\n */\nServiceOptions.prototype.stdio;\n\n\n/**\n * Manages the life and death of a native executable WebDriver server.\n *\n * It is expected that the driver server implements the\n * https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol.\n * Furthermore, the managed server should support multiple concurrent sessions,\n * so that this class may be reused for multiple clients.\n */\nclass DriverService {\n  /**\n   * @param {string} executable Path to the executable to run.\n   * @param {!ServiceOptions} options Configuration options for the service.\n   */\n  constructor(executable, options) {\n    /** @private {string} */\n    this.executable_ = executable;\n\n    /** @private {boolean} */\n    this.loopbackOnly_ = !!options.loopback;\n\n    /** @private {(string|undefined)} */\n    this.hostname_ = options.hostname;\n\n    /** @private {(number|!IThenable<number>)} */\n    this.port_ = options.port;\n\n    /**\n     * @private {!(Array<CommandLineFlag>|\n     *             IThenable<!Array<CommandLineFlag>>)}\n     */\n    this.args_ = options.args;\n\n    /** @private {string} */\n    this.path_ = options.path || '/';\n\n    /** @private {!Object<string, string>} */\n    this.env_ = options.env || process.env;\n\n    /**\n     * @private {(string|!Array<string|number|!stream.Stream|null|undefined>)}\n     */\n    this.stdio_ = options.stdio || 'ignore';\n\n    /**\n     * A promise for the managed subprocess, or null if the server has not been\n     * started yet. This promise will never be rejected.\n     * @private {Promise<!exec.Command>}\n     */\n    this.command_ = null;\n\n    /**\n     * Promise that resolves to the server's address or null if the server has\n     * not been started. This promise will be rejected if the server terminates\n     * before it starts accepting WebDriver requests.\n     * @private {Promise<string>}\n     */\n    this.address_ = null;\n  }\n\n  /**\n   * @return {!Promise<string>} A promise that resolves to the server's address.\n   * @throws {Error} If the server has not been started.\n   */\n  address() {\n    if (this.address_) {\n      return this.address_;\n    }\n    throw Error('Server has not been started.');\n  }\n\n  /**\n   * Returns whether the underlying process is still running. This does not take\n   * into account whether the process is in the process of shutting down.\n   * @return {boolean} Whether the underlying service process is running.\n   */\n  isRunning() {\n    return !!this.address_;\n  }\n\n  /**\n   * Starts the server if it is not already running.\n   * @param {number=} opt_timeoutMs How long to wait, in milliseconds, for the\n   *     server to start accepting requests. Defaults to 30 seconds.\n   * @return {!Promise<string>} A promise that will resolve to the server's base\n   *     URL when it has started accepting requests. If the timeout expires\n   *     before the server has started, the promise will be rejected.\n   */\n  start(opt_timeoutMs) {\n    if (this.address_) {\n      return this.address_;\n    }\n\n    var timeout = opt_timeoutMs || DriverService.DEFAULT_START_TIMEOUT_MS;\n    var self = this;\n\n    let resolveCommand;\n    this.command_ = new Promise(resolve => resolveCommand = resolve);\n\n    this.address_ = new Promise((resolveAddress, rejectAddress) => {\n      resolveAddress(Promise.resolve(this.port_).then(port => {\n        if (port <= 0) {\n          throw Error('Port must be > 0: ' + port);\n        }\n\n        return resolveCommandLineFlags(this.args_).then(args => {\n          var command = exec(self.executable_, {\n            args: args,\n            env: self.env_,\n            stdio: self.stdio_\n          });\n\n          resolveCommand(command);\n\n          var earlyTermination = command.result().then(function(result) {\n            var error = result.code == null ?\n                Error('Server was killed with ' + result.signal) :\n                Error('Server terminated early with status ' + result.code);\n            rejectAddress(error);\n            self.address_ = null;\n            self.command_ = null;\n            throw error;\n          });\n\n          var hostname = self.hostname_;\n          if (!hostname) {\n            hostname = !self.loopbackOnly_ && net.getAddress()\n                || net.getLoopbackAddress();\n          }\n\n          var serverUrl = url.format({\n            protocol: 'http',\n            hostname: hostname,\n            port: port + '',\n            pathname: self.path_\n          });\n\n          return new Promise((fulfill, reject) => {\n            let cancelToken =\n                earlyTermination.catch(e => reject(Error(e.message)));\n\n            httpUtil.waitForServer(serverUrl, timeout, cancelToken)\n                .then(_ => fulfill(serverUrl), err => {\n                  if (err instanceof httpUtil.CancellationError) {\n                    fulfill(serverUrl);\n                  } else {\n                    reject(err);\n                  }\n                });\n          });\n        });\n      }));\n    });\n\n    return this.address_;\n  }\n\n  /**\n   * Stops the service if it is not currently running. This function will kill\n   * the server immediately. To synchronize with the active control flow, use\n   * {@link #stop()}.\n   * @return {!Promise} A promise that will be resolved when the server has been\n   *     stopped.\n   */\n  kill() {\n    if (!this.address_ || !this.command_) {\n      return Promise.resolve(); // Not currently running.\n    }\n    let cmd = this.command_;\n    this.address_ = null;\n    this.command_ = null;\n    return cmd.then(c => c.kill('SIGTERM'));\n  }\n}\n\n\n/**\n * @param {!(Array<CommandLineFlag>|IThenable<!Array<CommandLineFlag>>)} args\n * @return {!Promise<!Array<string>>}\n */\nfunction resolveCommandLineFlags(args) {\n  // Resolve the outer array, then the individual flags.\n  return Promise.resolve(args)\n      .then(/** !Array<CommandLineFlag> */args => Promise.all(args));\n}\n\n\n/**\n * The default amount of time, in milliseconds, to wait for the server to\n * start.\n * @const {number}\n */\nDriverService.DEFAULT_START_TIMEOUT_MS = 30 * 1000;\n\n\n/**\n * Creates {@link DriverService} objects that manage a WebDriver server in a\n * child process.\n */\nDriverService.Builder = class {\n  /**\n   * @param {string} exe Path to the executable to use. This executable must\n   *     accept the `--port` flag for defining the port to start the server on.\n   * @throws {Error} If the provided executable path does not exist.\n   */\n  constructor(exe) {\n    if (!fs.existsSync(exe)) {\n      throw Error(`The specified executable path does not exist: ${exe}`);\n    }\n\n    /** @private @const {string} */\n    this.exe_ = exe;\n\n    /** @private {!ServiceOptions} */\n    this.options_ = {\n      args: [],\n      port: 0,\n      env: null,\n      stdio: 'ignore'\n    };\n  }\n\n  /**\n   * Define additional command line arguments to use when starting the server.\n   *\n   * @param {...CommandLineFlag} var_args The arguments to include.\n   * @return {!THIS} A self reference.\n   * @this {THIS}\n   * @template THIS\n   */\n  addArguments(var_args) {\n    let args = Array.prototype.slice.call(arguments, 0);\n    this.options_.args = this.options_.args.concat(args);\n    return this;\n  }\n\n  /**\n   * Sets the host name to access the server on. If specified, the\n   * {@linkplain #setLoopback() loopback} setting will be ignored.\n   *\n   * @param {string} hostname\n   * @return {!DriverService.Builder} A self reference.\n   */\n  setHostname(hostname) {\n    this.options_.hostname = hostname;\n    return this;\n  }\n\n  /**\n   * Sets whether the service should be accessed at this host's loopback\n   * address.\n   *\n   * @param {boolean} loopback\n   * @return {!DriverService.Builder} A self reference.\n   */\n  setLoopback(loopback) {\n    this.options_.loopback = loopback;\n    return this;\n  }\n\n  /**\n   * Sets the base path for WebDriver REST commands (e.g. \"/wd/hub\").\n   * By default, the driver will accept commands relative to \"/\".\n   *\n   * @param {?string} basePath The base path to use, or `null` to use the\n   *     default.\n   * @return {!DriverService.Builder} A self reference.\n   */\n  setPath(basePath) {\n    this.options_.path = basePath;\n    return this;\n  }\n\n  /**\n   * Sets the port to start the server on.\n   *\n   * @param {number} port The port to use, or 0 for any free port.\n   * @return {!DriverService.Builder} A self reference.\n   * @throws {Error} If an invalid port is specified.\n   */\n  setPort(port) {\n    if (port < 0) {\n      throw Error(`port must be >= 0: ${port}`);\n    }\n    this.options_.port = port;\n    return this;\n  }\n\n  /**\n   * Defines the environment to start the server under. This setting will be\n   * inherited by every browser session started by the server. By default, the\n   * server will inherit the enviroment of the current process.\n   *\n   * @param {(Map<string, string>|Object<string, string>|null)} env The desired\n   *     environment to use, or `null` if the server should inherit the\n   *     current environment.\n   * @return {!DriverService.Builder} A self reference.\n   */\n  setEnvironment(env) {\n    if (env instanceof Map) {\n      let tmp = {};\n      env.forEach((value, key) => tmp[key] = value);\n      env = tmp;\n    }\n    this.options_.env = env;\n    return this;\n  }\n\n  /**\n   * IO configuration for the spawned server process. For more information,\n   * refer to the documentation of `child_process.spawn`.\n   *\n   * @param {StdIoOptions} config The desired IO configuration.\n   * @return {!DriverService.Builder} A self reference.\n   * @see https://nodejs.org/dist/latest-v4.x/docs/api/child_process.html#child_process_options_stdio\n   */\n  setStdio(config) {\n    this.options_.stdio = config;\n    return this;\n  }\n\n  /**\n   * Creates a new DriverService using this instance's current configuration.\n   *\n   * @return {!DriverService} A new driver service.\n   */\n  build() {\n    let port = this.options_.port || portprober.findFreePort();\n    let args = Promise.resolve(port).then(port => {\n      return this.options_.args.concat('--port=' + port);\n    });\n\n    let options =\n        /** @type {!ServiceOptions} */\n        (Object.assign({}, this.options_, {args, port}));\n    return new DriverService(this.exe_, options);\n  }\n};\n\n\n/**\n * Manages the life and death of the\n * <a href=\"http://selenium-release.storage.googleapis.com/index.html\">\n * standalone Selenium server</a>.\n */\nclass SeleniumServer extends DriverService {\n  /**\n   * @param {string} jar Path to the Selenium server jar.\n   * @param {SeleniumServer.Options=} opt_options Configuration options for the\n   *     server.\n   * @throws {Error} If the path to the Selenium jar is not specified or if an\n   *     invalid port is specified.\n   */\n  constructor(jar, opt_options) {\n    if (!jar) {\n      throw Error('Path to the Selenium jar not specified');\n    }\n\n    var options = opt_options || {};\n\n    if (options.port < 0) {\n      throw Error('Port must be >= 0: ' + options.port);\n    }\n\n    let port = options.port || portprober.findFreePort();\n    let args = Promise.all([port, options.jvmArgs || [], options.args || []])\n        .then(resolved => {\n          let port = resolved[0];\n          let jvmArgs = resolved[1];\n          let args = resolved[2];\n          return jvmArgs.concat('-jar', jar, '-port', port).concat(args);\n        });\n\n    let java = 'java';\n    if (process.env['JAVA_HOME']) {\n      java = path.join(process.env['JAVA_HOME'], 'bin/java');\n    }\n\n    super(java, {\n      loopback: options.loopback,\n      port: port,\n      args: args,\n      path: '/wd/hub',\n      env: options.env,\n      stdio: options.stdio\n    });\n  }\n}\n\n\n/**\n * Options for the Selenium server:\n *\n * - `loopback` - Whether the server should only be accessed on this host's\n *     loopback address.\n * - `port` - The port to start the server on (must be > 0). If the port is\n *     provided as a promise, the service will wait for the promise to resolve\n *     before starting.\n * - `args` - The arguments to pass to the service. If a promise is provided,\n *     the service will wait for it to resolve before starting.\n * - `jvmArgs` - The arguments to pass to the JVM. If a promise is provided,\n *     the service will wait for it to resolve before starting.\n * - `env` - The environment variables that should be visible to the server\n *     process. Defaults to inheriting the current process's environment.\n * - `stdio` - IO configuration for the spawned server process. For more\n *     information, refer to the documentation of `child_process.spawn`.\n *\n * @typedef {{\n *   loopback: (boolean|undefined),\n *   port: (number|!IThenable<number>),\n *   args: !(Array<string>|IThenable<!Array<string>>),\n *   jvmArgs: (!Array<string>|!IThenable<!Array<string>>|undefined),\n *   env: (!Object<string, string>|undefined),\n *   stdio: (string|!Array<string|number|!stream.Stream|null|undefined>|\n *           undefined)\n * }}\n */\nSeleniumServer.Options;\n\n\n\n/**\n * A {@link webdriver.FileDetector} that may be used when running\n * against a remote\n * [Selenium server](http://selenium-release.storage.googleapis.com/index.html).\n *\n * When a file path on the local machine running this script is entered with\n * {@link webdriver.WebElement#sendKeys WebElement#sendKeys}, this file detector\n * will transfer the specified file to the Selenium server's host; the sendKeys\n * command will be updated to use the transfered file's path.\n *\n * __Note:__ This class depends on a non-standard command supported on the\n * Java Selenium server. The file detector will fail if used with a server that\n * only supports standard WebDriver commands (such as the ChromeDriver).\n *\n * @final\n */\nclass FileDetector extends input.FileDetector {\n  /**\n   * Prepares a `file` for use with the remote browser. If the provided path\n   * does not reference a normal file (i.e. it does not exist or is a\n   * directory), then the promise returned by this method will be resolved with\n   * the original file path. Otherwise, this method will upload the file to the\n   * remote server, which will return the file's path on the remote system so\n   * it may be referenced in subsequent commands.\n   *\n   * @override\n   */\n  handleFile(driver, file) {\n    return io.stat(file).then(function(stats) {\n      if (stats.isDirectory()) {\n        return file;  // Not a valid file, return original input.\n      }\n\n      let zip = new Zip;\n      return zip.addFile(file)\n          .then(() => zip.toBuffer())\n          .then(buf => buf.toString('base64'))\n          .then(encodedZip => {\n            let command = new cmd.Command(cmd.Name.UPLOAD_FILE)\n                .setParameter('file', encodedZip);\n            return driver.execute(command);\n          });\n    }, function(err) {\n      if (err.code === 'ENOENT') {\n        return file;  // Not a file; return original input.\n      }\n      throw err;\n    });\n  }\n}\n\n\n// PUBLIC API\n\nexports.DriverService = DriverService;\nexports.FileDetector = FileDetector;\nexports.SeleniumServer = SeleniumServer;\nexports.ServiceOptions = ServiceOptions;  // Exported for API docs.\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/remote/index.js?");

/***/ }),

/***/ "../node_modules/selenium-webdriver/safari.js":
/*!****************************************************!*\
  !*** ../node_modules/selenium-webdriver/safari.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a WebDriver client for Safari.\n */\n\n\n\nconst command = __webpack_require__(/*! ./lib/command */ \"../node_modules/selenium-webdriver/lib/command.js\");\nconst error = __webpack_require__(/*! ./lib/error */ \"../node_modules/selenium-webdriver/lib/error.js\");\nconst http = __webpack_require__(/*! ./http */ \"../node_modules/selenium-webdriver/http/index.js\");\nconst io = __webpack_require__(/*! ./io */ \"../node_modules/selenium-webdriver/io/index.js\");\nconst portprober = __webpack_require__(/*! ./net/portprober */ \"../node_modules/selenium-webdriver/net/portprober.js\");\nconst promise = __webpack_require__(/*! ./lib/promise */ \"../node_modules/selenium-webdriver/lib/promise.js\");\nconst remote = __webpack_require__(/*! ./remote */ \"../node_modules/selenium-webdriver/remote/index.js\");\nconst Symbols = __webpack_require__(/*! ./lib/symbols */ \"../node_modules/selenium-webdriver/lib/symbols.js\");\nconst webdriver = __webpack_require__(/*! ./lib/webdriver */ \"../node_modules/selenium-webdriver/lib/webdriver.js\");\nconst {Browser, Capabilities, Capability} = __webpack_require__(/*! ./lib/capabilities */ \"../node_modules/selenium-webdriver/lib/capabilities.js\");\n\n\n/**\n * _Synchronously_ attempts to locate the IE driver executable on the current\n * system.\n *\n * @return {?string} the located executable, or `null`.\n */\nfunction locateSynchronously() {\n  return process.platform === 'darwin'\n      ? io.findInPath('safaridriver', true) : null;\n}\n\n\n/**\n * @return {string} .\n * @throws {Error}\n */\nfunction findSafariDriver() {\n  let exe = locateSynchronously();\n  if (!exe) {\n    throw Error(\n      `The safaridriver executable could not be found on the current PATH.\n      Please ensure you are using Safari 10.0 or above.`);\n  }\n  return exe;\n}\n\n\n/**\n * Creates {@link selenium-webdriver/remote.DriverService} instances that manage\n * a [safaridriver] server in a child process.\n *\n * [safaridriver]: https://developer.apple.com/library/prerelease/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_10_0.html#//apple_ref/doc/uid/TP40014305-CH11-DontLinkElementID_28\n */\nclass ServiceBuilder extends remote.DriverService.Builder {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *     the builder will attempt to locate the safaridriver on the system PATH.\n   */\n  constructor(opt_exe) {\n    super(opt_exe || findSafariDriver());\n    this.setLoopback(true);  // Required.\n  }\n}\n\n\nconst OPTIONS_CAPABILITY_KEY = 'safari.options';\nconst TECHNOLOGY_PREVIEW_OPTIONS_KEY = 'technologyPreview';\n\n/**\n * Configuration options specific to the {@link Driver SafariDriver}.\n */\nclass Options extends Capabilities {\n  /**\n   * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of\n   *     capabilities to initialize this instance from.\n   */\n  constructor(other = undefined) {\n    super(other);\n\n    /** @private {!Object} */\n    this.options_ = this.get(OPTIONS_CAPABILITY_KEY) || {};\n\n    this.set(OPTIONS_CAPABILITY_KEY, this.options_);\n    this.setBrowserName(Browser.SAFARI);\n  }\n\n  /**\n   * Instruct the SafariDriver to use the Safari Technology Preview if true.\n   * Otherwise, use the release version of Safari. Defaults to using the release version of Safari.\n   *\n   * @param {boolean} useTechnologyPreview\n   * @return {!Options} A self reference.\n   */\n  setTechnologyPreview(useTechnologyPreview) {\n    this.options_[TECHNOLOGY_PREVIEW_OPTIONS_KEY] = !!useTechnologyPreview;\n    return this;\n  }\n}\n\n/**\n * @param  {(Capabilities|Object<string, *>)=} o The options object\n * @return {boolean}\n */\nfunction useTechnologyPreview(o) {\n  if (o instanceof Capabilities) {\n    let options = o.get(OPTIONS_CAPABILITY_KEY);\n    return !!(options && options[TECHNOLOGY_PREVIEW_OPTIONS_KEY]);\n  }\n\n  if (o && typeof o === 'object') {\n    return !!o[TECHNOLOGY_PREVIEW_OPTIONS_KEY];\n  }\n\n  return false;\n}\n\n\nconst SAFARIDRIVER_TECHNOLOGY_PREVIEW_EXE =\n    '/Applications/Safari Technology Preview.app/Contents/MacOS/safaridriver';\n\n\n/**\n * A WebDriver client for Safari. This class should never be instantiated\n * directly; instead, use the {@linkplain ./builder.Builder Builder}:\n *\n *     var driver = new Builder()\n *         .forBrowser('safari')\n *         .build();\n *\n */\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new Safari session.\n   *\n   * @param {(Options|Capabilities)=} options The configuration options.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(options) {\n    let caps = options || new Options();\n\n    let exe;\n    if (useTechnologyPreview(caps.get(OPTIONS_CAPABILITY_KEY))) {\n      exe = SAFARIDRIVER_TECHNOLOGY_PREVIEW_EXE;\n    }\n\n    let service = new ServiceBuilder(exe).build();\n    let executor = new http.Executor(\n        service.start().then(url => new http.HttpClient(url)));\n\n    return /** @type {!Driver} */(super.createSession(\n        executor, caps, () => service.kill()));\n  }\n}\n\n\n// Public API\n\n\nexports.Driver = Driver;\nexports.Options = Options;\nexports.ServiceBuilder = ServiceBuilder;\nexports.locateSynchronously = locateSynchronously;\n\n\n//# sourceURL=webpack:///../node_modules/selenium-webdriver/safari.js?");

/***/ }),

/***/ "../node_modules/supports-color/index.js":
/*!***********************************************!*\
  !*** ../node_modules/supports-color/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst hasFlag = __webpack_require__(/*! has-flag */ \"../node_modules/supports-color/node_modules/has-flag/index.js\");\n\nconst env = process.env;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor ? 1 : 0;\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors. Windows 10 build 14931 is the first release\n\t\t// that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\n\n\n//# sourceURL=webpack:///../node_modules/supports-color/index.js?");

/***/ }),

/***/ "../node_modules/supports-color/node_modules/has-flag/index.js":
/*!*********************************************************************!*\
  !*** ../node_modules/supports-color/node_modules/has-flag/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n\n\n//# sourceURL=webpack:///../node_modules/supports-color/node_modules/has-flag/index.js?");

/***/ }),

/***/ "../node_modules/tmp/lib/tmp.js":
/*!**************************************!*\
  !*** ../node_modules/tmp/lib/tmp.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Tmp\n *\n * Copyright (c) 2011-2015 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar\n  fs     = __webpack_require__(/*! fs */ \"fs\"),\n  path   = __webpack_require__(/*! path */ \"path\"),\n  crypto = __webpack_require__(/*! crypto */ \"crypto\"),\n  tmpDir = __webpack_require__(/*! os-tmpdir */ \"../node_modules/os-tmpdir/index.js\"),\n  _c     = process.binding('constants');\n\n\n/**\n * The working inner variables.\n */\nvar\n  // store the actual TMP directory\n  _TMP = tmpDir(),\n\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n\n  DIR_MODE = 448 /* 0700 */,\n  FILE_MODE = 384 /* 0600 */,\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n\n  _gracefulCleanup = false,\n  _uncaughtException = false;\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {Number} howMany\n * @return {String}\n * @api private\n */\nfunction _randomChars(howMany) {\n  var\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api private\n */\nfunction _parseArguments(options, callback) {\n  if (typeof options == 'function') {\n    var\n      tmp = options,\n      options = callback || {},\n      callback = tmp;\n  } else if (typeof options == 'undefined') {\n    options = {};\n  }\n\n  return [options, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {String}\n * @api private\n */\nfunction _generateTmpName(opts) {\n  if (opts.name) {\n    return path.join(opts.dir || _TMP, opts.name);\n  }\n\n  // mkstemps like template\n  if (opts.template) {\n    return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));\n  }\n\n  // prefix and postfix\n  var name = [\n    opts.prefix || 'tmp-',\n    process.pid,\n    _randomChars(12),\n    opts.postfix || ''\n  ].join('');\n\n  return path.join(opts.dir || _TMP, name);\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api private\n */\nfunction _getTmpName(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1],\n    tries = opts.tries || DEFAULT_TRIES;\n\n  if (isNaN(tries) || tries < 0)\n    return cb(new Error('Invalid tries'));\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    return cb(new Error('Invalid template provided'));\n\n  (function _getUniqueName() {\n    var name = _generateTmpName(opts);\n\n    // check whether the path exists then retry if needed\n    fs.stat(name, function (err) {\n      if (!err) {\n        if (tries-- > 0) return _getUniqueName();\n\n        return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n      }\n\n      cb(null, name);\n    });\n  }());\n}\n\n/**\n * Synchronous version of _getTmpName.\n *\n * @param {Object} options\n * @returns {String}\n * @api private\n */\nfunction _getTmpNameSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0],\n    tries = opts.tries || DEFAULT_TRIES;\n\n  if (isNaN(tries) || tries < 0)\n    throw new Error('Invalid tries');\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    throw new Error('Invalid template provided');\n\n  do {\n    var name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api public\n */\nfunction _createTmpFile(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  opts.postfix = (_isUndefined(opts.postfix)) ? '.tmp' : opts.postfix;\n\n  // gets a temporary filename\n  _getTmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      if (err) return cb(err);\n\n      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of _createTmpFile.\n *\n * @param {Object} options\n * @returns {Object} object consists of name, fd and removeCallback\n * @api private\n */\nfunction _createTmpFileSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  opts.postfix = opts.postfix || '.tmp';\n\n  var name = _getTmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n\n  return {\n    name : name,\n    fd : fd,\n    removeCallback : _prepareTmpFileRemoveCallback(name, fd, opts)\n  };\n}\n\n/**\n * Removes files and folders in a directory recursively.\n *\n * @param {String} root\n * @api private\n */\nfunction _rmdirRecursiveSync(root) {\n  var dirs = [root];\n\n  do {\n    var\n      dir = dirs.pop(),\n      deferred = false,\n      files = fs.readdirSync(dir);\n\n    for (var i = 0, length = files.length; i < length; i++) {\n      var\n        file = path.join(dir, files[i]),\n        stat = fs.lstatSync(file); // lstat so we don't recurse into symlinked directories\n\n      if (stat.isDirectory()) {\n        if (!deferred) {\n          deferred = true;\n          dirs.push(dir);\n        }\n        dirs.push(file);\n      } else {\n        fs.unlinkSync(file);\n      }\n    }\n\n    if (!deferred) {\n      fs.rmdirSync(dir);\n    }\n  } while (dirs.length !== 0);\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api public\n */\nfunction _createTmpDir(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  _getTmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of _createTmpDir.\n *\n * @param {Object} options\n * @returns {Object} object consists of name and removeCallback\n * @api private\n */\nfunction _createTmpDirSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  var name = _getTmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name : name,\n    removeCallback : _prepareTmpDirRemoveCallback(name, opts)\n  };\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * @param {String} name\n * @param {int} fd\n * @param {Object} opts\n * @api private\n * @returns {Function} the callback\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts) {\n  var removeCallback = _prepareRemoveCallback(function _removeCallback(fdPath) {\n    try {\n      fs.closeSync(fdPath[0]);\n    }\n    catch (e) {\n      // under some node/windows related circumstances, a temporary file\n      // may have not be created as expected or the file was already closed\n      // by the user, in which case we will simply ignore the error\n      if (e.errno != -(_c.EBADF || _c.os.errno.EBADF) && e.errno != -(_c.ENOENT || _c.os.errno.ENOENT)) {\n        // reraise any unanticipated error\n        throw e;\n      }\n    }\n    fs.unlinkSync(fdPath[1]);\n  }, [fd, name]);\n\n  if (!opts.keep) {\n    _removeObjects.unshift(removeCallback);\n  }\n\n  return removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * @param {String} name\n * @param {Object} opts\n * @returns {Function} the callback\n * @api private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts) {\n  var removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs.rmdirSync.bind(fs);\n  var removeCallback = _prepareRemoveCallback(removeFunction, name);\n\n  if (!opts.keep) {\n    _removeObjects.unshift(removeCallback);\n  }\n\n  return removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * @param {Function} removeFunction\n * @param {Object} arg\n * @returns {Function}\n * @api private\n */\nfunction _prepareRemoveCallback(removeFunction, arg) {\n  var called = false;\n\n  return function _cleanupCallback() {\n    if (called) return;\n\n    var index = _removeObjects.indexOf(_cleanupCallback);\n    if (index >= 0) {\n      _removeObjects.splice(index, 1);\n    }\n\n    called = true;\n    removeFunction(arg);\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @api private\n */\nfunction _garbageCollector() {\n  if (_uncaughtException && !_gracefulCleanup) {\n    return;\n  }\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0].call(null);\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\nfunction _setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\nvar version = process.versions.node.split('.').map(function (value) {\n  return parseInt(value, 10);\n});\n\nif (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {\n  process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {\n    _uncaughtException = true;\n    _garbageCollector();\n\n    throw err;\n  });\n}\n\nprocess.addListener('exit', function _exit(code) {\n  if (code) _uncaughtException = true;\n  _garbageCollector();\n});\n\n// exporting all the needed methods\nmodule.exports.tmpdir = _TMP;\nmodule.exports.dir = _createTmpDir;\nmodule.exports.dirSync = _createTmpDirSync;\nmodule.exports.file = _createTmpFile;\nmodule.exports.fileSync = _createTmpFileSync;\nmodule.exports.tmpName = _getTmpName;\nmodule.exports.tmpNameSync = _getTmpNameSync;\nmodule.exports.setGracefulCleanup = _setGracefulCleanup;\n\n\n//# sourceURL=webpack:///../node_modules/tmp/lib/tmp.js?");

/***/ }),

/***/ "../node_modules/universalify/index.js":
/*!*********************************************!*\
  !*** ../node_modules/universalify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function () {\n    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)\n    else {\n      return new Promise((resolve, reject) => {\n        arguments[arguments.length] = (err, res) => {\n          if (err) return reject(err)\n          resolve(res)\n        }\n        arguments.length++\n        fn.apply(this, arguments)\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function () {\n    const cb = arguments[arguments.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, arguments)\n    else fn.apply(this, arguments).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n\n\n//# sourceURL=webpack:///../node_modules/universalify/index.js?");

/***/ }),

/***/ "../node_modules/util-deprecate/node.js":
/*!**********************************************!*\
  !*** ../node_modules/util-deprecate/node.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nmodule.exports = __webpack_require__(/*! util */ \"util\").deprecate;\n\n\n//# sourceURL=webpack:///../node_modules/util-deprecate/node.js?");

/***/ }),

/***/ "../node_modules/uuid/index.js":
/*!*************************************!*\
  !*** ../node_modules/uuid/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var v1 = __webpack_require__(/*! ./v1 */ \"../node_modules/uuid/v1.js\");\nvar v4 = __webpack_require__(/*! ./v4 */ \"../node_modules/uuid/v4.js\");\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n//# sourceURL=webpack:///../node_modules/uuid/index.js?");

/***/ }),

/***/ "../node_modules/uuid/lib/bytesToUuid.js":
/*!***********************************************!*\
  !*** ../node_modules/uuid/lib/bytesToUuid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n\n\n//# sourceURL=webpack:///../node_modules/uuid/lib/bytesToUuid.js?");

/***/ }),

/***/ "../node_modules/uuid/lib/rng.js":
/*!***************************************!*\
  !*** ../node_modules/uuid/lib/rng.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n\n\n//# sourceURL=webpack:///../node_modules/uuid/lib/rng.js?");

/***/ }),

/***/ "../node_modules/uuid/v1.js":
/*!**********************************!*\
  !*** ../node_modules/uuid/v1.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"../node_modules/uuid/lib/rng.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"../node_modules/uuid/lib/bytesToUuid.js\");\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n//# sourceURL=webpack:///../node_modules/uuid/v1.js?");

/***/ }),

/***/ "../node_modules/uuid/v4.js":
/*!**********************************!*\
  !*** ../node_modules/uuid/v4.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"../node_modules/uuid/lib/rng.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"../node_modules/uuid/lib/bytesToUuid.js\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n//# sourceURL=webpack:///../node_modules/uuid/v4.js?");

/***/ }),

/***/ "../node_modules/webpack/buildin/module.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/module.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///../node_modules/webpack/buildin/module.js?");

/***/ }),

/***/ "../node_modules/wrappy/wrappy.js":
/*!****************************************!*\
  !*** ../node_modules/wrappy/wrappy.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n\n//# sourceURL=webpack:///../node_modules/wrappy/wrappy.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLAttribute.js":
/*!******************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLAttribute.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLAttribute, create;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  module.exports = XMLAttribute = (function() {\n    function XMLAttribute(parent, name, value) {\n      this.stringify = parent.stringify;\n      if (name == null) {\n        throw new Error(\"Missing attribute name of element \" + parent.name);\n      }\n      if (value == null) {\n        throw new Error(\"Missing attribute value for attribute \" + name + \" of element \" + parent.name);\n      }\n      this.name = this.stringify.attName(name);\n      this.value = this.stringify.attValue(value);\n    }\n\n    XMLAttribute.prototype.clone = function() {\n      return create(XMLAttribute.prototype, this);\n    };\n\n    XMLAttribute.prototype.toString = function(options, level) {\n      return ' ' + this.name + '=\"' + this.value + '\"';\n    };\n\n    return XMLAttribute;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLAttribute.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLBuilder.js":
/*!****************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLBuilder.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLBuilder, XMLDeclaration, XMLDocType, XMLElement, XMLStringifier;\n\n  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ \"../node_modules/xmlbuilder/lib/XMLStringifier.js\");\n\n  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ \"../node_modules/xmlbuilder/lib/XMLDeclaration.js\");\n\n  XMLDocType = __webpack_require__(/*! ./XMLDocType */ \"../node_modules/xmlbuilder/lib/XMLDocType.js\");\n\n  XMLElement = __webpack_require__(/*! ./XMLElement */ \"../node_modules/xmlbuilder/lib/XMLElement.js\");\n\n  module.exports = XMLBuilder = (function() {\n    function XMLBuilder(name, options) {\n      var root, temp;\n      if (name == null) {\n        throw new Error(\"Root element needs a name\");\n      }\n      if (options == null) {\n        options = {};\n      }\n      this.options = options;\n      this.stringify = new XMLStringifier(options);\n      temp = new XMLElement(this, 'doc');\n      root = temp.element(name);\n      root.isRoot = true;\n      root.documentObject = this;\n      this.rootObject = root;\n      if (!options.headless) {\n        root.declaration(options);\n        if ((options.pubID != null) || (options.sysID != null)) {\n          root.doctype(options);\n        }\n      }\n    }\n\n    XMLBuilder.prototype.root = function() {\n      return this.rootObject;\n    };\n\n    XMLBuilder.prototype.end = function(options) {\n      return this.toString(options);\n    };\n\n    XMLBuilder.prototype.toString = function(options) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      r = '';\n      if (this.xmldec != null) {\n        r += this.xmldec.toString(options);\n      }\n      if (this.doctype != null) {\n        r += this.doctype.toString(options);\n      }\n      r += this.rootObject.toString(options);\n      if (pretty && r.slice(-newline.length) === newline) {\n        r = r.slice(0, -newline.length);\n      }\n      return r;\n    };\n\n    return XMLBuilder;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLBuilder.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLCData.js":
/*!**************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLCData.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLCData, XMLNode, create,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"../node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLCData = (function(superClass) {\n    extend(XMLCData, superClass);\n\n    function XMLCData(parent, text) {\n      XMLCData.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing CDATA text\");\n      }\n      this.text = this.stringify.cdata(text);\n    }\n\n    XMLCData.prototype.clone = function() {\n      return create(XMLCData.prototype, this);\n    };\n\n    XMLCData.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      if (pretty) {\n        r += space;\n      }\n      r += '<![CDATA[' + this.text + ']]>';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLCData;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLCData.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLComment.js":
/*!****************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLComment.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLComment, XMLNode, create,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"../node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLComment = (function(superClass) {\n    extend(XMLComment, superClass);\n\n    function XMLComment(parent, text) {\n      XMLComment.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing comment text\");\n      }\n      this.text = this.stringify.comment(text);\n    }\n\n    XMLComment.prototype.clone = function() {\n      return create(XMLComment.prototype, this);\n    };\n\n    XMLComment.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      if (pretty) {\n        r += space;\n      }\n      r += '<!-- ' + this.text + ' -->';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLComment;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLComment.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLDTDAttList.js":
/*!*******************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLDTDAttList.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLDTDAttList, create;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  module.exports = XMLDTDAttList = (function() {\n    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      this.stringify = parent.stringify;\n      if (elementName == null) {\n        throw new Error(\"Missing DTD element name\");\n      }\n      if (attributeName == null) {\n        throw new Error(\"Missing DTD attribute name\");\n      }\n      if (!attributeType) {\n        throw new Error(\"Missing DTD attribute type\");\n      }\n      if (!defaultValueType) {\n        throw new Error(\"Missing DTD attribute default\");\n      }\n      if (defaultValueType.indexOf('#') !== 0) {\n        defaultValueType = '#' + defaultValueType;\n      }\n      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT\");\n      }\n      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Default value only applies to #FIXED or #DEFAULT\");\n      }\n      this.elementName = this.stringify.eleName(elementName);\n      this.attributeName = this.stringify.attName(attributeName);\n      this.attributeType = this.stringify.dtdAttType(attributeType);\n      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);\n      this.defaultValueType = defaultValueType;\n    }\n\n    XMLDTDAttList.prototype.clone = function() {\n      return create(XMLDTDAttList.prototype, this);\n    };\n\n    XMLDTDAttList.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      if (pretty) {\n        r += space;\n      }\n      r += '<!ATTLIST ' + this.elementName + ' ' + this.attributeName + ' ' + this.attributeType;\n      if (this.defaultValueType !== '#DEFAULT') {\n        r += ' ' + this.defaultValueType;\n      }\n      if (this.defaultValue) {\n        r += ' \"' + this.defaultValue + '\"';\n      }\n      r += '>';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLDTDAttList;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLDTDAttList.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLDTDElement.js":
/*!*******************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLDTDElement.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLDTDElement, create;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  module.exports = XMLDTDElement = (function() {\n    function XMLDTDElement(parent, name, value) {\n      this.stringify = parent.stringify;\n      if (name == null) {\n        throw new Error(\"Missing DTD element name\");\n      }\n      if (!value) {\n        value = '(#PCDATA)';\n      }\n      if (Array.isArray(value)) {\n        value = '(' + value.join(',') + ')';\n      }\n      this.name = this.stringify.eleName(name);\n      this.value = this.stringify.dtdElementValue(value);\n    }\n\n    XMLDTDElement.prototype.clone = function() {\n      return create(XMLDTDElement.prototype, this);\n    };\n\n    XMLDTDElement.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      if (pretty) {\n        r += space;\n      }\n      r += '<!ELEMENT ' + this.name + ' ' + this.value + '>';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLDTDElement;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLDTDElement.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLDTDEntity.js":
/*!******************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLDTDEntity.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLDTDEntity, create, isObject;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  isObject = __webpack_require__(/*! lodash/lang/isObject */ \"../node_modules/lodash/lang/isObject.js\");\n\n  module.exports = XMLDTDEntity = (function() {\n    function XMLDTDEntity(parent, pe, name, value) {\n      this.stringify = parent.stringify;\n      if (name == null) {\n        throw new Error(\"Missing entity name\");\n      }\n      if (value == null) {\n        throw new Error(\"Missing entity value\");\n      }\n      this.pe = !!pe;\n      this.name = this.stringify.eleName(name);\n      if (!isObject(value)) {\n        this.value = this.stringify.dtdEntityValue(value);\n      } else {\n        if (!value.pubID && !value.sysID) {\n          throw new Error(\"Public and/or system identifiers are required for an external entity\");\n        }\n        if (value.pubID && !value.sysID) {\n          throw new Error(\"System identifier is required for a public external entity\");\n        }\n        if (value.pubID != null) {\n          this.pubID = this.stringify.dtdPubID(value.pubID);\n        }\n        if (value.sysID != null) {\n          this.sysID = this.stringify.dtdSysID(value.sysID);\n        }\n        if (value.nData != null) {\n          this.nData = this.stringify.dtdNData(value.nData);\n        }\n        if (this.pe && this.nData) {\n          throw new Error(\"Notation declaration is not allowed in a parameter entity\");\n        }\n      }\n    }\n\n    XMLDTDEntity.prototype.clone = function() {\n      return create(XMLDTDEntity.prototype, this);\n    };\n\n    XMLDTDEntity.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      if (pretty) {\n        r += space;\n      }\n      r += '<!ENTITY';\n      if (this.pe) {\n        r += ' %';\n      }\n      r += ' ' + this.name;\n      if (this.value) {\n        r += ' \"' + this.value + '\"';\n      } else {\n        if (this.pubID && this.sysID) {\n          r += ' PUBLIC \"' + this.pubID + '\" \"' + this.sysID + '\"';\n        } else if (this.sysID) {\n          r += ' SYSTEM \"' + this.sysID + '\"';\n        }\n        if (this.nData) {\n          r += ' NDATA ' + this.nData;\n        }\n      }\n      r += '>';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLDTDEntity;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLDTDEntity.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLDTDNotation.js":
/*!********************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLDTDNotation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLDTDNotation, create;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  module.exports = XMLDTDNotation = (function() {\n    function XMLDTDNotation(parent, name, value) {\n      this.stringify = parent.stringify;\n      if (name == null) {\n        throw new Error(\"Missing notation name\");\n      }\n      if (!value.pubID && !value.sysID) {\n        throw new Error(\"Public or system identifiers are required for an external entity\");\n      }\n      this.name = this.stringify.eleName(name);\n      if (value.pubID != null) {\n        this.pubID = this.stringify.dtdPubID(value.pubID);\n      }\n      if (value.sysID != null) {\n        this.sysID = this.stringify.dtdSysID(value.sysID);\n      }\n    }\n\n    XMLDTDNotation.prototype.clone = function() {\n      return create(XMLDTDNotation.prototype, this);\n    };\n\n    XMLDTDNotation.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      if (pretty) {\n        r += space;\n      }\n      r += '<!NOTATION ' + this.name;\n      if (this.pubID && this.sysID) {\n        r += ' PUBLIC \"' + this.pubID + '\" \"' + this.sysID + '\"';\n      } else if (this.pubID) {\n        r += ' PUBLIC \"' + this.pubID + '\"';\n      } else if (this.sysID) {\n        r += ' SYSTEM \"' + this.sysID + '\"';\n      }\n      r += '>';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLDTDNotation;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLDTDNotation.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLDeclaration.js":
/*!********************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLDeclaration.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLDeclaration, XMLNode, create, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  isObject = __webpack_require__(/*! lodash/lang/isObject */ \"../node_modules/lodash/lang/isObject.js\");\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"../node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLDeclaration = (function(superClass) {\n    extend(XMLDeclaration, superClass);\n\n    function XMLDeclaration(parent, version, encoding, standalone) {\n      var ref;\n      XMLDeclaration.__super__.constructor.call(this, parent);\n      if (isObject(version)) {\n        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;\n      }\n      if (!version) {\n        version = '1.0';\n      }\n      if (version != null) {\n        this.version = this.stringify.xmlVersion(version);\n      }\n      if (encoding != null) {\n        this.encoding = this.stringify.xmlEncoding(encoding);\n      }\n      if (standalone != null) {\n        this.standalone = this.stringify.xmlStandalone(standalone);\n      }\n    }\n\n    XMLDeclaration.prototype.clone = function() {\n      return create(XMLDeclaration.prototype, this);\n    };\n\n    XMLDeclaration.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      if (pretty) {\n        r += space;\n      }\n      r += '<?xml';\n      if (this.version != null) {\n        r += ' version=\"' + this.version + '\"';\n      }\n      if (this.encoding != null) {\n        r += ' encoding=\"' + this.encoding + '\"';\n      }\n      if (this.standalone != null) {\n        r += ' standalone=\"' + this.standalone + '\"';\n      }\n      r += '?>';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLDeclaration;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLDeclaration.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLDocType.js":
/*!****************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLDocType.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLProcessingInstruction, create, isObject;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  isObject = __webpack_require__(/*! lodash/lang/isObject */ \"../node_modules/lodash/lang/isObject.js\");\n\n  XMLCData = __webpack_require__(/*! ./XMLCData */ \"../node_modules/xmlbuilder/lib/XMLCData.js\");\n\n  XMLComment = __webpack_require__(/*! ./XMLComment */ \"../node_modules/xmlbuilder/lib/XMLComment.js\");\n\n  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ \"../node_modules/xmlbuilder/lib/XMLDTDAttList.js\");\n\n  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ \"../node_modules/xmlbuilder/lib/XMLDTDEntity.js\");\n\n  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ \"../node_modules/xmlbuilder/lib/XMLDTDElement.js\");\n\n  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ \"../node_modules/xmlbuilder/lib/XMLDTDNotation.js\");\n\n  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ \"../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js\");\n\n  module.exports = XMLDocType = (function() {\n    function XMLDocType(parent, pubID, sysID) {\n      var ref, ref1;\n      this.documentObject = parent;\n      this.stringify = this.documentObject.stringify;\n      this.children = [];\n      if (isObject(pubID)) {\n        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;\n      }\n      if (sysID == null) {\n        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];\n      }\n      if (pubID != null) {\n        this.pubID = this.stringify.dtdPubID(pubID);\n      }\n      if (sysID != null) {\n        this.sysID = this.stringify.dtdSysID(sysID);\n      }\n    }\n\n    XMLDocType.prototype.clone = function() {\n      return create(XMLDocType.prototype, this);\n    };\n\n    XMLDocType.prototype.element = function(name, value) {\n      var child;\n      child = new XMLDTDElement(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var child;\n      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.entity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, false, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.pEntity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, true, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.notation = function(name, value) {\n      var child;\n      child = new XMLDTDNotation(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.cdata = function(value) {\n      var child;\n      child = new XMLCData(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.comment = function(value) {\n      var child;\n      child = new XMLComment(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.instruction = function(target, value) {\n      var child;\n      child = new XMLProcessingInstruction(this, target, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.root = function() {\n      return this.documentObject.root();\n    };\n\n    XMLDocType.prototype.document = function() {\n      return this.documentObject;\n    };\n\n    XMLDocType.prototype.toString = function(options, level) {\n      var child, i, indent, len, newline, offset, pretty, r, ref, ref1, ref2, ref3, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      if (pretty) {\n        r += space;\n      }\n      r += '<!DOCTYPE ' + this.root().name;\n      if (this.pubID && this.sysID) {\n        r += ' PUBLIC \"' + this.pubID + '\" \"' + this.sysID + '\"';\n      } else if (this.sysID) {\n        r += ' SYSTEM \"' + this.sysID + '\"';\n      }\n      if (this.children.length > 0) {\n        r += ' [';\n        if (pretty) {\n          r += newline;\n        }\n        ref3 = this.children;\n        for (i = 0, len = ref3.length; i < len; i++) {\n          child = ref3[i];\n          r += child.toString(options, level + 1);\n        }\n        r += ']';\n      }\n      r += '>';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    XMLDocType.prototype.ele = function(name, value) {\n      return this.element(name, value);\n    };\n\n    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);\n    };\n\n    XMLDocType.prototype.ent = function(name, value) {\n      return this.entity(name, value);\n    };\n\n    XMLDocType.prototype.pent = function(name, value) {\n      return this.pEntity(name, value);\n    };\n\n    XMLDocType.prototype.not = function(name, value) {\n      return this.notation(name, value);\n    };\n\n    XMLDocType.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLDocType.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLDocType.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLDocType.prototype.up = function() {\n      return this.root();\n    };\n\n    XMLDocType.prototype.doc = function() {\n      return this.document();\n    };\n\n    return XMLDocType;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLDocType.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLElement.js":
/*!****************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLElement.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLAttribute, XMLElement, XMLNode, XMLProcessingInstruction, create, every, isFunction, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  isObject = __webpack_require__(/*! lodash/lang/isObject */ \"../node_modules/lodash/lang/isObject.js\");\n\n  isFunction = __webpack_require__(/*! lodash/lang/isFunction */ \"../node_modules/lodash/lang/isFunction.js\");\n\n  every = __webpack_require__(/*! lodash/collection/every */ \"../node_modules/lodash/collection/every.js\");\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"../node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ \"../node_modules/xmlbuilder/lib/XMLAttribute.js\");\n\n  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ \"../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js\");\n\n  module.exports = XMLElement = (function(superClass) {\n    extend(XMLElement, superClass);\n\n    function XMLElement(parent, name, attributes) {\n      XMLElement.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing element name\");\n      }\n      this.name = this.stringify.eleName(name);\n      this.children = [];\n      this.instructions = [];\n      this.attributes = {};\n      if (attributes != null) {\n        this.attribute(attributes);\n      }\n    }\n\n    XMLElement.prototype.clone = function() {\n      var att, attName, clonedSelf, i, len, pi, ref, ref1;\n      clonedSelf = create(XMLElement.prototype, this);\n      if (clonedSelf.isRoot) {\n        clonedSelf.documentObject = null;\n      }\n      clonedSelf.attributes = {};\n      ref = this.attributes;\n      for (attName in ref) {\n        if (!hasProp.call(ref, attName)) continue;\n        att = ref[attName];\n        clonedSelf.attributes[attName] = att.clone();\n      }\n      clonedSelf.instructions = [];\n      ref1 = this.instructions;\n      for (i = 0, len = ref1.length; i < len; i++) {\n        pi = ref1[i];\n        clonedSelf.instructions.push(pi.clone());\n      }\n      clonedSelf.children = [];\n      this.children.forEach(function(child) {\n        var clonedChild;\n        clonedChild = child.clone();\n        clonedChild.parent = clonedSelf;\n        return clonedSelf.children.push(clonedChild);\n      });\n      return clonedSelf;\n    };\n\n    XMLElement.prototype.attribute = function(name, value) {\n      var attName, attValue;\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (isObject(name)) {\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (!this.options.skipNullAttributes || (value != null)) {\n          this.attributes[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    };\n\n    XMLElement.prototype.removeAttribute = function(name) {\n      var attName, i, len;\n      if (name == null) {\n        throw new Error(\"Missing attribute name\");\n      }\n      name = name.valueOf();\n      if (Array.isArray(name)) {\n        for (i = 0, len = name.length; i < len; i++) {\n          attName = name[i];\n          delete this.attributes[attName];\n        }\n      } else {\n        delete this.attributes[name];\n      }\n      return this;\n    };\n\n    XMLElement.prototype.instruction = function(target, value) {\n      var i, insTarget, insValue, instruction, len;\n      if (target != null) {\n        target = target.valueOf();\n      }\n      if (value != null) {\n        value = value.valueOf();\n      }\n      if (Array.isArray(target)) {\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        instruction = new XMLProcessingInstruction(this, target, value);\n        this.instructions.push(instruction);\n      }\n      return this;\n    };\n\n    XMLElement.prototype.toString = function(options, level) {\n      var att, child, i, indent, instruction, j, len, len1, name, newline, offset, pretty, r, ref, ref1, ref2, ref3, ref4, ref5, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      ref3 = this.instructions;\n      for (i = 0, len = ref3.length; i < len; i++) {\n        instruction = ref3[i];\n        r += instruction.toString(options, level);\n      }\n      if (pretty) {\n        r += space;\n      }\n      r += '<' + this.name;\n      ref4 = this.attributes;\n      for (name in ref4) {\n        if (!hasProp.call(ref4, name)) continue;\n        att = ref4[name];\n        r += att.toString(options);\n      }\n      if (this.children.length === 0 || every(this.children, function(e) {\n        return e.value === '';\n      })) {\n        r += '/>';\n        if (pretty) {\n          r += newline;\n        }\n      } else if (pretty && this.children.length === 1 && (this.children[0].value != null)) {\n        r += '>';\n        r += this.children[0].value;\n        r += '</' + this.name + '>';\n        r += newline;\n      } else {\n        r += '>';\n        if (pretty) {\n          r += newline;\n        }\n        ref5 = this.children;\n        for (j = 0, len1 = ref5.length; j < len1; j++) {\n          child = ref5[j];\n          r += child.toString(options, level + 1);\n        }\n        if (pretty) {\n          r += space;\n        }\n        r += '</' + this.name + '>';\n        if (pretty) {\n          r += newline;\n        }\n      }\n      return r;\n    };\n\n    XMLElement.prototype.att = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    XMLElement.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLElement.prototype.a = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    XMLElement.prototype.i = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    return XMLElement;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLElement.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLNode.js":
/*!*************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLNode.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLRaw, XMLText, isEmpty, isFunction, isObject,\n    hasProp = {}.hasOwnProperty;\n\n  isObject = __webpack_require__(/*! lodash/lang/isObject */ \"../node_modules/lodash/lang/isObject.js\");\n\n  isFunction = __webpack_require__(/*! lodash/lang/isFunction */ \"../node_modules/lodash/lang/isFunction.js\");\n\n  isEmpty = __webpack_require__(/*! lodash/lang/isEmpty */ \"../node_modules/lodash/lang/isEmpty.js\");\n\n  XMLElement = null;\n\n  XMLCData = null;\n\n  XMLComment = null;\n\n  XMLDeclaration = null;\n\n  XMLDocType = null;\n\n  XMLRaw = null;\n\n  XMLText = null;\n\n  module.exports = XMLNode = (function() {\n    function XMLNode(parent) {\n      this.parent = parent;\n      this.options = this.parent.options;\n      this.stringify = this.parent.stringify;\n      if (XMLElement === null) {\n        XMLElement = __webpack_require__(/*! ./XMLElement */ \"../node_modules/xmlbuilder/lib/XMLElement.js\");\n        XMLCData = __webpack_require__(/*! ./XMLCData */ \"../node_modules/xmlbuilder/lib/XMLCData.js\");\n        XMLComment = __webpack_require__(/*! ./XMLComment */ \"../node_modules/xmlbuilder/lib/XMLComment.js\");\n        XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ \"../node_modules/xmlbuilder/lib/XMLDeclaration.js\");\n        XMLDocType = __webpack_require__(/*! ./XMLDocType */ \"../node_modules/xmlbuilder/lib/XMLDocType.js\");\n        XMLRaw = __webpack_require__(/*! ./XMLRaw */ \"../node_modules/xmlbuilder/lib/XMLRaw.js\");\n        XMLText = __webpack_require__(/*! ./XMLText */ \"../node_modules/xmlbuilder/lib/XMLText.js\");\n      }\n    }\n\n    XMLNode.prototype.clone = function() {\n      throw new Error(\"Cannot clone generic XMLNode\");\n    };\n\n    XMLNode.prototype.element = function(name, attributes, text) {\n      var item, j, key, lastChild, len, ref, val;\n      lastChild = null;\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = attributes.valueOf();\n      if (!isObject(attributes)) {\n        ref = [attributes, text], text = ref[0], attributes = ref[1];\n      }\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (Array.isArray(name)) {\n        for (j = 0, len = name.length; j < len; j++) {\n          item = name[j];\n          lastChild = this.element(item);\n        }\n      } else if (isFunction(name)) {\n        lastChild = this.element(name.apply());\n      } else if (isObject(name)) {\n        for (key in name) {\n          if (!hasProp.call(name, key)) continue;\n          val = name[key];\n          if (isFunction(val)) {\n            val = val.apply();\n          }\n          if ((isObject(val)) && (isEmpty(val))) {\n            val = null;\n          }\n          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && key.indexOf(this.stringify.convertPIKey) === 0) {\n            lastChild = this.instruction(key.substr(this.stringify.convertPIKey.length), val);\n          } else if (isObject(val)) {\n            if (!this.options.ignoreDecorators && this.stringify.convertListKey && key.indexOf(this.stringify.convertListKey) === 0 && Array.isArray(val)) {\n              lastChild = this.element(val);\n            } else {\n              lastChild = this.element(key);\n              lastChild.element(val);\n            }\n          } else {\n            lastChild = this.element(key, val);\n          }\n        }\n      } else {\n        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n          lastChild = this.text(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n          lastChild = this.cdata(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n          lastChild = this.comment(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n          lastChild = this.raw(text);\n        } else {\n          lastChild = this.node(name, attributes, text);\n        }\n      }\n      if (lastChild == null) {\n        throw new Error(\"Could not create any elements with: \" + name);\n      }\n      return lastChild;\n    };\n\n    XMLNode.prototype.insertBefore = function(name, attributes, text) {\n      var child, i, removed;\n      if (this.isRoot) {\n        throw new Error(\"Cannot insert elements at root level\");\n      }\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.element(name, attributes, text);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return child;\n    };\n\n    XMLNode.prototype.insertAfter = function(name, attributes, text) {\n      var child, i, removed;\n      if (this.isRoot) {\n        throw new Error(\"Cannot insert elements at root level\");\n      }\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.element(name, attributes, text);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return child;\n    };\n\n    XMLNode.prototype.remove = function() {\n      var i, ref;\n      if (this.isRoot) {\n        throw new Error(\"Cannot remove the root element\");\n      }\n      i = this.parent.children.indexOf(this);\n      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref = [])), ref;\n      return this.parent;\n    };\n\n    XMLNode.prototype.node = function(name, attributes, text) {\n      var child, ref;\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = attributes.valueOf();\n      if (!isObject(attributes)) {\n        ref = [attributes, text], text = ref[0], attributes = ref[1];\n      }\n      child = new XMLElement(this, name, attributes);\n      if (text != null) {\n        child.text(text);\n      }\n      this.children.push(child);\n      return child;\n    };\n\n    XMLNode.prototype.text = function(value) {\n      var child;\n      child = new XMLText(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.cdata = function(value) {\n      var child;\n      child = new XMLCData(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.comment = function(value) {\n      var child;\n      child = new XMLComment(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.raw = function(value) {\n      var child;\n      child = new XMLRaw(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.declaration = function(version, encoding, standalone) {\n      var doc, xmldec;\n      doc = this.document();\n      xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n      doc.xmldec = xmldec;\n      return doc.root();\n    };\n\n    XMLNode.prototype.doctype = function(pubID, sysID) {\n      var doc, doctype;\n      doc = this.document();\n      doctype = new XMLDocType(doc, pubID, sysID);\n      doc.doctype = doctype;\n      return doctype;\n    };\n\n    XMLNode.prototype.up = function() {\n      if (this.isRoot) {\n        throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n      }\n      return this.parent;\n    };\n\n    XMLNode.prototype.root = function() {\n      var child;\n      if (this.isRoot) {\n        return this;\n      }\n      child = this.parent;\n      while (!child.isRoot) {\n        child = child.parent;\n      }\n      return child;\n    };\n\n    XMLNode.prototype.document = function() {\n      return this.root().documentObject;\n    };\n\n    XMLNode.prototype.end = function(options) {\n      return this.document().toString(options);\n    };\n\n    XMLNode.prototype.prev = function() {\n      var i;\n      if (this.isRoot) {\n        throw new Error(\"Root node has no siblings\");\n      }\n      i = this.parent.children.indexOf(this);\n      if (i < 1) {\n        throw new Error(\"Already at the first node\");\n      }\n      return this.parent.children[i - 1];\n    };\n\n    XMLNode.prototype.next = function() {\n      var i;\n      if (this.isRoot) {\n        throw new Error(\"Root node has no siblings\");\n      }\n      i = this.parent.children.indexOf(this);\n      if (i === -1 || i === this.parent.children.length - 1) {\n        throw new Error(\"Already at the last node\");\n      }\n      return this.parent.children[i + 1];\n    };\n\n    XMLNode.prototype.importXMLBuilder = function(xmlbuilder) {\n      var clonedRoot;\n      clonedRoot = xmlbuilder.root().clone();\n      clonedRoot.parent = this;\n      clonedRoot.isRoot = false;\n      this.children.push(clonedRoot);\n      return this;\n    };\n\n    XMLNode.prototype.ele = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.nod = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.txt = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.doc = function() {\n      return this.document();\n    };\n\n    XMLNode.prototype.dec = function(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    };\n\n    XMLNode.prototype.dtd = function(pubID, sysID) {\n      return this.doctype(pubID, sysID);\n    };\n\n    XMLNode.prototype.e = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.n = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.t = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.d = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.c = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.r = function(value) {\n      return this.raw(value);\n    };\n\n    XMLNode.prototype.u = function() {\n      return this.up();\n    };\n\n    return XMLNode;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLNode.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js":
/*!******************************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLProcessingInstruction, create;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  module.exports = XMLProcessingInstruction = (function() {\n    function XMLProcessingInstruction(parent, target, value) {\n      this.stringify = parent.stringify;\n      if (target == null) {\n        throw new Error(\"Missing instruction target\");\n      }\n      this.target = this.stringify.insTarget(target);\n      if (value) {\n        this.value = this.stringify.insValue(value);\n      }\n    }\n\n    XMLProcessingInstruction.prototype.clone = function() {\n      return create(XMLProcessingInstruction.prototype, this);\n    };\n\n    XMLProcessingInstruction.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      if (pretty) {\n        r += space;\n      }\n      r += '<?';\n      r += this.target;\n      if (this.value) {\n        r += ' ' + this.value;\n      }\n      r += '?>';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLProcessingInstruction;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLProcessingInstruction.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLRaw.js":
/*!************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLRaw.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLNode, XMLRaw, create,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"../node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLRaw = (function(superClass) {\n    extend(XMLRaw, superClass);\n\n    function XMLRaw(parent, text) {\n      XMLRaw.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing raw text\");\n      }\n      this.value = this.stringify.raw(text);\n    }\n\n    XMLRaw.prototype.clone = function() {\n      return create(XMLRaw.prototype, this);\n    };\n\n    XMLRaw.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      if (pretty) {\n        r += space;\n      }\n      r += this.value;\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLRaw;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLRaw.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLStringifier.js":
/*!********************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLStringifier.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLStringifier,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    hasProp = {}.hasOwnProperty;\n\n  module.exports = XMLStringifier = (function() {\n    function XMLStringifier(options) {\n      this.assertLegalChar = bind(this.assertLegalChar, this);\n      var key, ref, value;\n      this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;\n      ref = (options != null ? options.stringify : void 0) || {};\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[key] = value;\n      }\n    }\n\n    XMLStringifier.prototype.eleName = function(val) {\n      val = '' + val || '';\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.eleText = function(val) {\n      val = '' + val || '';\n      return this.assertLegalChar(this.elEscape(val));\n    };\n\n    XMLStringifier.prototype.cdata = function(val) {\n      val = '' + val || '';\n      if (val.match(/]]>/)) {\n        throw new Error(\"Invalid CDATA text: \" + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.comment = function(val) {\n      val = '' + val || '';\n      if (val.match(/--/)) {\n        throw new Error(\"Comment text cannot contain double-hypen: \" + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.raw = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.attName = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.attValue = function(val) {\n      val = '' + val || '';\n      return this.attEscape(val);\n    };\n\n    XMLStringifier.prototype.insTarget = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.insValue = function(val) {\n      val = '' + val || '';\n      if (val.match(/\\?>/)) {\n        throw new Error(\"Invalid processing instruction value: \" + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlVersion = function(val) {\n      val = '' + val || '';\n      if (!val.match(/1\\.[0-9]+/)) {\n        throw new Error(\"Invalid version number: \" + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlEncoding = function(val) {\n      val = '' + val || '';\n      if (!val.match(/[A-Za-z](?:[A-Za-z0-9._-]|-)*/)) {\n        throw new Error(\"Invalid encoding: \" + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlStandalone = function(val) {\n      if (val) {\n        return \"yes\";\n      } else {\n        return \"no\";\n      }\n    };\n\n    XMLStringifier.prototype.dtdPubID = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdSysID = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdElementValue = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdAttType = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdAttDefault = function(val) {\n      if (val != null) {\n        return '' + val || '';\n      } else {\n        return val;\n      }\n    };\n\n    XMLStringifier.prototype.dtdEntityValue = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdNData = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.convertAttKey = '@';\n\n    XMLStringifier.prototype.convertPIKey = '?';\n\n    XMLStringifier.prototype.convertTextKey = '#text';\n\n    XMLStringifier.prototype.convertCDataKey = '#cdata';\n\n    XMLStringifier.prototype.convertCommentKey = '#comment';\n\n    XMLStringifier.prototype.convertRawKey = '#raw';\n\n    XMLStringifier.prototype.convertListKey = '#list';\n\n    XMLStringifier.prototype.assertLegalChar = function(str) {\n      var chars, chr;\n      if (this.allowSurrogateChars) {\n        chars = /[\\u0000-\\u0008\\u000B-\\u000C\\u000E-\\u001F\\uFFFE-\\uFFFF]/;\n      } else {\n        chars = /[\\u0000-\\u0008\\u000B-\\u000C\\u000E-\\u001F\\uD800-\\uDFFF\\uFFFE-\\uFFFF]/;\n      }\n      chr = str.match(chars);\n      if (chr) {\n        throw new Error(\"Invalid character (\" + chr + \") in string: \" + str + \" at index \" + chr.index);\n      }\n      return str;\n    };\n\n    XMLStringifier.prototype.elEscape = function(str) {\n      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\r/g, '&#xD;');\n    };\n\n    XMLStringifier.prototype.attEscape = function(str) {\n      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\n    };\n\n    return XMLStringifier;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLStringifier.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/XMLText.js":
/*!*************************************************!*\
  !*** ../node_modules/xmlbuilder/lib/XMLText.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLNode, XMLText, create,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = __webpack_require__(/*! lodash/object/create */ \"../node_modules/lodash/object/create.js\");\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"../node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLText = (function(superClass) {\n    extend(XMLText, superClass);\n\n    function XMLText(parent, text) {\n      XMLText.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing element text\");\n      }\n      this.value = this.stringify.eleText(text);\n    }\n\n    XMLText.prototype.clone = function() {\n      return create(XMLText.prototype, this);\n    };\n\n    XMLText.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\\n';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = '';\n      if (pretty) {\n        r += space;\n      }\n      r += this.value;\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLText;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/XMLText.js?");

/***/ }),

/***/ "../node_modules/xmlbuilder/lib/index.js":
/*!***********************************************!*\
  !*** ../node_modules/xmlbuilder/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.9.1\n(function() {\n  var XMLBuilder, assign;\n\n  assign = __webpack_require__(/*! lodash/object/assign */ \"../node_modules/lodash/object/assign.js\");\n\n  XMLBuilder = __webpack_require__(/*! ./XMLBuilder */ \"../node_modules/xmlbuilder/lib/XMLBuilder.js\");\n\n  module.exports.create = function(name, xmldec, doctype, options) {\n    options = assign({}, xmldec, doctype, options);\n    return new XMLBuilder(name, options).root();\n  };\n\n}).call(this);\n\n\n//# sourceURL=webpack:///../node_modules/xmlbuilder/lib/index.js?");

/***/ }),

/***/ "./Pixel.ts":
/*!******************!*\
  !*** ./Pixel.ts ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst pngjs_1 = __importDefault(__webpack_require__(/*! pngjs */ \"../node_modules/pngjs/lib/png.js\"));\r\nasync function getImgData(imgStr, dimensions) {\r\n    let base64Data = imgStr.replace(/^data:image\\/png;base64,/, ''), png, regionPng;\r\n    if (dimensions && dimensions.left >= 0 && dimensions.top >= 0 && dimensions.width && dimensions.height) {\r\n        png = pngjs_1.default.sync.read(new Buffer(base64Data, 'base64'));\r\n        regionPng = new pngjs_1.default({ width: dimensions.width, height: dimensions.height });\r\n        pngjs_1.default.bitblt(png, regionPng, dimensions.left, dimensions.top, dimensions.width, dimensions.height, 0, 0);\r\n        base64Data = pngjs_1.default.sync.write(regionPng).toString('base64');\r\n    }\r\n    return base64Data;\r\n}\r\nfunction highlight(dimensions, data, color) {\r\n    let png, targetHeight, targetWidth, idx, isValid = dimensions && dimensions.left >= 0 && dimensions.top >= 0 && dimensions.width && dimensions.height;\r\n    if (!isValid) {\r\n        return data;\r\n    }\r\n    png = pngjs_1.default.sync.read(new Buffer(data, 'base64'));\r\n    targetHeight = Math.min(dimensions.top + dimensions.height, png.height);\r\n    targetWidth = Math.min(dimensions.left + dimensions.width, png.width);\r\n    for (let y = dimensions.top; y < targetHeight; y += 1) {\r\n        for (let x = dimensions.left; x < targetWidth; x += 1) {\r\n            if (y > dimensions.top && y < targetHeight - 1 && x > dimensions.left && x < targetWidth - 1) {\r\n                continue;\r\n            }\r\n            idx = (png.width * y + x) << 2;\r\n            png.data[idx] = color[0];\r\n            png.data[idx + 1] = color[1];\r\n            png.data[idx + 2] = color[2];\r\n        }\r\n    }\r\n    return pngjs_1.default.sync.write(png).toString('base64');\r\n}\r\nconst Pixel = {\r\n    getImgData: getImgData,\r\n    highlight: highlight\r\n};\r\nexports.default = Pixel;\r\n\n\n//# sourceURL=webpack:///./Pixel.ts?");

/***/ }),

/***/ "./config.json":
/*!********************************!*\
  !*** external "./config.json" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"./config.json\");\n\n//# sourceURL=webpack:///external_%22./config.json%22?");

/***/ }),

/***/ "./driver-wrapper.ts":
/*!***************************!*\
  !*** ./driver-wrapper.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst selenium_webdriver_1 = __webpack_require__(/*! selenium-webdriver */ \"../node_modules/selenium-webdriver/index.js\");\r\nconst config_json_1 = __importDefault(__webpack_require__(/*! ./config.json */ \"./config.json\"));\r\nlet driver;\r\nlet isIE = config_json_1.default.brower === 'internet explorer';\r\nlet browserMargin = {\r\n    x: 0,\r\n    y: 0\r\n};\r\nlet logger;\r\nasync function init(logFunc) {\r\n    let builder = new selenium_webdriver_1.Builder().forBrowser(config_json_1.default.brower), capabilities, width = config_json_1.default.windowSize.width || 800, height = config_json_1.default.windowSize.height || 600;\r\n    logger = logFunc;\r\n    if (config_json_1.default.serverUrl) {\r\n        builder.usingServer(config_json_1.default.serverUrl);\r\n    }\r\n    if (isIE) {\r\n        capabilities = selenium_webdriver_1.Capabilities.ie();\r\n        capabilities.set('nativeEvents', false);\r\n        // capabilities.set('ie.forceCreateProcessApi', true);\r\n        // capabilities.set('ie.browserCommandLineSwitches', '-private');\r\n        builder.withCapabilities(capabilities);\r\n    }\r\n    if (config_json_1.default.headless) {\r\n        logger('running headless mode');\r\n        capabilities = selenium_webdriver_1.Capabilities.chrome();\r\n        capabilities.set('chromeOptions', { args: ['--headless'] });\r\n        builder.withCapabilities(capabilities);\r\n    }\r\n    driver = await builder.build();\r\n    await updateBrowserMargin();\r\n    driver.manage().setTimeouts({\r\n        script: 15000\r\n    });\r\n    await driver.manage().window().setRect({ width: width + browserMargin.x, height: height + browserMargin.y });\r\n}\r\nasync function updateBrowserMargin() {\r\n    let margins = await driver.executeScript('return [window.outerWidth-window.innerWidth, window.outerHeight-window.innerHeight];');\r\n    browserMargin = {\r\n        x: margins[0],\r\n        y: margins[1]\r\n    };\r\n}\r\nasync function getLogs() {\r\n    let logType = 'browser';\r\n    if (isIE || !config_json_1.default.browerLogLevel) {\r\n        return;\r\n    }\r\n    let driverLogs = await driver.manage().logs();\r\n    if (!driverLogs) {\r\n        return;\r\n    }\r\n    let types = await driverLogs.getAvailableLogTypes();\r\n    if (types.indexOf(logType) < 0) {\r\n        return;\r\n    }\r\n    return await driverLogs.get(logType);\r\n}\r\nasync function setWindowSize(sizes) {\r\n    let width = (sizes.width || config_json_1.default.windowSize.width) + browserMargin.x, height = (sizes.height || config_json_1.default.windowSize.height) + browserMargin.y;\r\n    await driver.manage().window().setRect({ width, height });\r\n}\r\nasync function goToUrl(url) {\r\n    await driver.get(url);\r\n}\r\nasync function click(cssPath, isDoubleClick = false) {\r\n    let el = await getEl(cssPath);\r\n    if (!isDoubleClick) {\r\n        await el.click(el);\r\n    }\r\n    else {\r\n        await el.doubleClick(el);\r\n    }\r\n}\r\nasync function contextClick(cssPath) {\r\n    let el = await getEl(cssPath);\r\n    await driver.actions()\r\n        .contextClick(el, 2)\r\n        .perform();\r\n}\r\nasync function getEl(cssPath) {\r\n    return await driver.findElement(selenium_webdriver_1.By.css(cssPath));\r\n}\r\nasync function sendKeys(cssPath, keys) {\r\n    let el = await getEl(cssPath);\r\n    await el.sendKeys(keys);\r\n}\r\nasync function scroll(cssPath, scrollOffset) {\r\n    let el = await getEl(cssPath);\r\n    await driver.executeScript(function () {\r\n        let args = arguments[arguments.length - 1], el = args[0], scrollOffset = args[1];\r\n        if (scrollOffset.left) {\r\n            el.scrollLeft = scrollOffset.left;\r\n        }\r\n        if (scrollOffset.top) {\r\n            el.scrollTop = scrollOffset.top;\r\n        }\r\n    }, [el, scrollOffset]);\r\n}\r\nasync function verify(cssPath, text) {\r\n    let el = await getEl(cssPath);\r\n    if (!el) {\r\n        return false;\r\n    }\r\n    if (text) {\r\n        let elText = await el.getText();\r\n        return text.trim() === (elText || '').trim();\r\n    }\r\n    return true;\r\n}\r\nasync function resetMouse() {\r\n    //await driver.actions().move({origin: 'viewport', duration: 0, x: -100000, y: -100000});\r\n}\r\nasync function screenshot() {\r\n    return await driver.takeScreenshot();\r\n}\r\nasync function close() {\r\n    driver && await driver.quit();\r\n}\r\nconst DriverWrapper = {\r\n    init: init,\r\n    getLogs: getLogs,\r\n    setWindowSize: setWindowSize,\r\n    goToUrl: goToUrl,\r\n    click: click,\r\n    contextClick: contextClick,\r\n    sendKeys: sendKeys,\r\n    scroll: scroll,\r\n    verify: verify,\r\n    resetMouse: resetMouse,\r\n    screenshot: screenshot,\r\n    close: close\r\n};\r\nexports.default = DriverWrapper;\r\n\n\n//# sourceURL=webpack:///./driver-wrapper.ts?");

/***/ }),

/***/ "./key-map.ts":
/*!********************!*\
  !*** ./key-map.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nlet KeyMap = {\r\n    8: '\\uE003',\r\n    9: '\\uE004',\r\n    13: '\\uE007',\r\n    46: '\\uE017'\r\n};\r\nexports.default = KeyMap;\r\n\n\n//# sourceURL=webpack:///./key-map.ts?");

/***/ }),

/***/ "./logger.ts":
/*!*******************!*\
  !*** ./logger.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst chalk_1 = __importDefault(__webpack_require__(/*! chalk */ \"../node_modules/chalk/index.js\"));\r\nlet isDebugging;\r\nfunction setDebugging(debugging) {\r\n    isDebugging = debugging;\r\n}\r\n;\r\nfunction success(message) {\r\n    console.log(chalk_1.default.green.bold(`Success: ${message}`));\r\n}\r\n;\r\nfunction highlight(message) {\r\n    console.log(chalk_1.default.black.bgWhite(message));\r\n}\r\n;\r\nfunction log(message, isForce = false) {\r\n    if (isDebugging || isForce) {\r\n        console.log(message);\r\n    }\r\n}\r\n;\r\nfunction warn(message, isForce) {\r\n    if (isDebugging || isForce) {\r\n        console.warn(chalk_1.default.yellow.bold(`Warn: ${message}`));\r\n    }\r\n}\r\n;\r\nfunction error(message) {\r\n    console.error(chalk_1.default.red.bold(`Error: ${message}`));\r\n}\r\n;\r\nfunction logError(errors) {\r\n    let errorsToLog = [];\r\n    if (errors) {\r\n        errorsToLog = Array.isArray(errors) ? errors : [errors];\r\n    }\r\n    errorsToLog.forEach(function (errorToLog) {\r\n        if (!errorToLog) {\r\n            error('Error occurred!');\r\n            return;\r\n        }\r\n        if (errorToLog && errorToLog.message) {\r\n            error(errorToLog.message);\r\n            return;\r\n        }\r\n        error(JSON.stringify(errorToLog));\r\n    });\r\n}\r\nfunction message(config) {\r\n    let action = Logger[config.type];\r\n    if (action) {\r\n        action(config.message, config.isForce);\r\n    }\r\n}\r\nconst Logger = {\r\n    setDebugging: setDebugging,\r\n    success: success,\r\n    highlight: highlight,\r\n    log: log,\r\n    warn: warn,\r\n    error: error,\r\n    logError: logError,\r\n    message: message\r\n};\r\nexports.default = Logger;\r\n\n\n//# sourceURL=webpack:///./logger.ts?");

/***/ }),

/***/ "./result-writer.ts":
/*!**************************!*\
  !*** ./result-writer.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\r\nconst node_trx_1 = __importDefault(__webpack_require__(/*! node-trx */ \"../node_modules/node-trx/trx.js\"));\r\nconst logger_1 = __importDefault(__webpack_require__(/*! ./logger */ \"./logger.ts\"));\r\nlet TestRun = node_trx_1.default.TestRun, UnitTest = node_trx_1.default.UnitTest;\r\nfunction writeResult(results) {\r\n    if (!results.tests.length || !results.tests.some((t) => t.results && t.results.length)) {\r\n        return;\r\n    }\r\n    try {\r\n        fs_1.default.writeFileSync('result.json', JSON.stringify(results, null, 4));\r\n        writeTrxResult(results);\r\n    }\r\n    catch (err) {\r\n        logger_1.default.error(err);\r\n    }\r\n}\r\nfunction writeTrxResult(results) {\r\n    var run, computerName = 'Autom runner';\r\n    try {\r\n        run = new TestRun({\r\n            name: 'Autom Tests',\r\n            times: {\r\n                creation: results.createTime,\r\n                queuing: results.createTime,\r\n                start: results.createTime,\r\n                finish: results.endTime\r\n            }\r\n        });\r\n        results.tests.forEach(function (test) {\r\n            var testName = test.name;\r\n            test.steps.forEach(function (step) {\r\n                var stepResults = step.results, testResult, startResult = stepResults.find((r) => r.content === 'Start'), endResult = stepResults.find((r) => r.content === 'Finish'), outcome = endResult && endResult.result ? 'Passed' : 'Failed', startTime = startResult && startResult.timeStamp, endTime = endResult && endResult.timeStamp, duration = startTime && endTime && (new Date(endTime).valueOf() - new Date(startTime).valueOf()), actions;\r\n                testResult = {\r\n                    test: new UnitTest({\r\n                        name: testName + ' - ' + step.name,\r\n                        methodName: '',\r\n                        methodCodeBase: '',\r\n                        methodClassName: step.name,\r\n                        description: `test: ${testName} - step: ${step.name}`\r\n                    }),\r\n                    computerName: computerName,\r\n                    outcome: outcome,\r\n                    duration: duration || '',\r\n                    startTime: startTime || '',\r\n                    endTime: endTime || ''\r\n                };\r\n                run.addResult(testResult);\r\n            });\r\n        });\r\n        fs_1.default.writeFileSync('result.trx', run.toXml());\r\n    }\r\n    catch (err) {\r\n        logger_1.default.error(err);\r\n    }\r\n}\r\nconst ResultWriter = {\r\n    writeResult: writeResult,\r\n    writeTrxResult: writeTrxResult\r\n};\r\nexports.default = ResultWriter;\r\n\n\n//# sourceURL=webpack:///./result-writer.ts?");

/***/ }),

/***/ "./runner.ts":
/*!*******************!*\
  !*** ./runner.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\r\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\r\nconst fs_extra_1 = __importDefault(__webpack_require__(/*! fs-extra */ \"../node_modules/fs-extra/lib/index.js\"));\r\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\r\nconst config_json_1 = __importDefault(__webpack_require__(/*! ./config.json */ \"./config.json\"));\r\nconst utility_1 = __importDefault(__webpack_require__(/*! ./utility */ \"./utility.ts\"));\r\nconst logger_1 = __importDefault(__webpack_require__(/*! ./logger */ \"./logger.ts\"));\r\nconst result_writer_1 = __importDefault(__webpack_require__(/*! ./result-writer */ \"./result-writer.ts\"));\r\nconst test_runner_1 = __importDefault(__webpack_require__(/*! ./test-runner */ \"./test-runner.ts\"));\r\nlet runnerResult = true, results = {\r\n    tests: []\r\n}, tests = [], testIdx;\r\nrun();\r\nasync function run() {\r\n    results.createTime = new Date().toISOString();\r\n    logger_1.default.setDebugging(config_json_1.default.isDebugging);\r\n    process.on('uncaughtException', onError);\r\n    process.on('exit', () => {\r\n        let exitCode = runnerResult ? 0 : 1;\r\n        logger_1.default.log('Exit with: ' + exitCode);\r\n        results.endTime = new Date().toISOString();\r\n        result_writer_1.default.writeResult(results);\r\n        process.exit(exitCode);\r\n    });\r\n    initFolders();\r\n    fetchTests();\r\n    await runTests();\r\n}\r\nfunction initFolders() {\r\n    [config_json_1.default.screenBaseFolder, config_json_1.default.screenCurrentFolder, config_json_1.default.screenDiffFolder, config_json_1.default.screenErrorFolder].forEach((folder) => {\r\n        fs_extra_1.default.ensureDirSync(folder);\r\n    });\r\n    [config_json_1.default.screenCurrentFolder, config_json_1.default.screenDiffFolder, config_json_1.default.screenErrorFolder].forEach((folder) => {\r\n        fs_extra_1.default.emptyDirSync(folder);\r\n    });\r\n}\r\nfunction fetchTests() {\r\n    let folders = utility_1.default.getFiles(config_json_1.default.sourceFolder, true) || [], testToRun = [];\r\n    tests = [];\r\n    process.argv.forEach((val, index) => {\r\n        if (index <= 1) {\r\n            return;\r\n        }\r\n        testToRun.push(path.join(config_json_1.default.sourceFolder, val));\r\n    });\r\n    folders.push(config_json_1.default.sourceFolder);\r\n    folders.forEach(function (subFolder) {\r\n        let stepsFile;\r\n        if (!utility_1.default.isOnPath(subFolder, config_json_1.default.shareFolder)\r\n            && (config_json_1.default.exclude || []).every((exd) => !utility_1.default.isOnPath(subFolder, exd))\r\n            && (!testToRun.length\r\n                || testToRun.some((toRun) => utility_1.default.isOnPath(subFolder, toRun)))) {\r\n            stepsFile = path.join(subFolder, 'steps.json');\r\n            if (fs_1.default.existsSync(stepsFile)) {\r\n                tests.push(subFolder);\r\n            }\r\n        }\r\n    });\r\n}\r\nasync function runTests() {\r\n    if (config_json_1.default.batchSize >= 2) {\r\n        runParallel();\r\n    }\r\n    else {\r\n        await runSequence();\r\n    }\r\n}\r\nasync function runSequence() {\r\n    let i = 0, len = tests.length;\r\n    for (i = 0; i < len; i += 1) {\r\n        await test_runner_1.default.runTest(tests[i], channel);\r\n    }\r\n}\r\nfunction runParallel() {\r\n    let testLen = tests.length;\r\n    for (testIdx = 0; testIdx < config_json_1.default.batchSize && testIdx < testLen; testIdx += 1) {\r\n        createChildProcess(testIdx);\r\n    }\r\n}\r\nfunction createChildProcess(idx) {\r\n    let test = tests[idx], child;\r\n    if (!test) {\r\n        return;\r\n    }\r\n    child = child_process_1.fork('./testRunner.js', [test]);\r\n    child.on('message', channel);\r\n    child.on('exit', function (exitCode) {\r\n        logger_1.default.log(\"Child exited with code: \" + exitCode);\r\n        runNextTest();\r\n    });\r\n}\r\nfunction runNextTest() {\r\n    if (testIdx >= tests.length) {\r\n        return;\r\n    }\r\n    createChildProcess(testIdx);\r\n    testIdx += 1;\r\n}\r\nfunction channel(message) {\r\n    let logAction = logger_1.default[message.type], hasStep = message.stepName, test = results.tests.find((test) => test.name === message.testName), prefix, step, receiver;\r\n    if (!test) {\r\n        test = {\r\n            name: message.testName,\r\n            results: [],\r\n            steps: [],\r\n            logs: []\r\n        };\r\n        results.tests.push(test);\r\n    }\r\n    if (hasStep) {\r\n        step = test.steps.find((step) => step.name === message.stepName);\r\n        if (!step) {\r\n            step = {\r\n                name: message.stepName,\r\n                results: [],\r\n                logs: []\r\n            };\r\n            test.steps.push(step);\r\n        }\r\n    }\r\n    prefix = `${message.testName || ''} - ${message.stepName || ''}: `;\r\n    if (logAction) {\r\n        logAction(prefix + message.content, message.isForce);\r\n    }\r\n    else if (message.type === 'result' && (message.result === true || message.result === false)) {\r\n        logAction = message.result ? logger_1.default.success : logger_1.default.error;\r\n        logAction(prefix + message.content, true);\r\n        if (!message.result) {\r\n            runnerResult = false;\r\n        }\r\n    }\r\n    receiver = hasStep ? step : test;\r\n    if (message.type !== 'result') {\r\n        receiver.logs.push(message);\r\n    }\r\n    else {\r\n        receiver.results.push(message);\r\n    }\r\n}\r\nfunction onError(errors) {\r\n    logger_1.default.logError(errors);\r\n    runnerResult = false;\r\n}\r\nlet Runner = {\r\n    run: run\r\n};\r\nexports.default = Runner;\r\n\n\n//# sourceURL=webpack:///./runner.ts?");

/***/ }),

/***/ "./step-runner.ts":
/*!************************!*\
  !*** ./step-runner.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\r\nconst fs_extra_1 = __importDefault(__webpack_require__(/*! fs-extra */ \"../node_modules/fs-extra/lib/index.js\"));\r\nconst node_resemble_js_1 = __importDefault(__webpack_require__(/*! node-resemble-js */ \"../node_modules/node-resemble-js/resemble.js\"));\r\nconst config_json_1 = __importDefault(__webpack_require__(/*! ./config.json */ \"./config.json\"));\r\nconst key_map_1 = __importDefault(__webpack_require__(/*! ./key-map */ \"./key-map.ts\"));\r\nconst utility_1 = __importDefault(__webpack_require__(/*! ./utility */ \"./utility.ts\"));\r\nconst driver_wrapper_1 = __importDefault(__webpack_require__(/*! ./driver-wrapper */ \"./driver-wrapper.ts\"));\r\nconst Pixel_1 = __importDefault(__webpack_require__(/*! ./Pixel */ \"./Pixel.ts\"));\r\nlet channel, actionMap = {\r\n    url: goToUrl,\r\n    click: doClick,\r\n    dblclick: doDblClick,\r\n    keydown: doKey,\r\n    keypress: doKey,\r\n    keyup: doKeyUp,\r\n    scroll: doScroll,\r\n    contextmenu: doContextMenu,\r\n    screenshot: doScreenShot,\r\n    verify: doVerify,\r\n    wait: doWait,\r\n    setsize: doSetSize\r\n}, currentUrl, currentTestName, currentTestResult = true, currentStep, currentStepResult = true, currentActionIdx = 0, defaultErrorWait = config_json_1.default.error && config_json_1.default.error.wait || 300, errorCount = 0, errorWait = 0, actionErrorCount = 0, isFinished = false, isRunning = false;\r\nasync function finish() {\r\n    config_json_1.default.closeOnFinish && await driver_wrapper_1.default.close();\r\n    isFinished = true;\r\n}\r\nasync function runTest(testName, steps, testChannel) {\r\n    let step, i, len = steps && steps.length;\r\n    if (!len) {\r\n        finish();\r\n        return;\r\n    }\r\n    currentUrl = null;\r\n    isRunning = true;\r\n    currentTestResult = true;\r\n    currentTestName = testName;\r\n    channel = testChannel;\r\n    await driver_wrapper_1.default.init(log);\r\n    logResult('Start', null, true);\r\n    for (i = 0; i < len; i += 1) {\r\n        step = steps[i];\r\n        currentStep = step;\r\n        currentStepResult = true;\r\n        log('');\r\n        log(`--- step: ${currentStep.name} --- `, 'highlight');\r\n        logResult('Start');\r\n        await runStepActions(step);\r\n        logResult('Finish', currentStepResult);\r\n        if (actionErrorCount >= 2) {\r\n            break;\r\n        }\r\n    }\r\n    finish();\r\n    logResult('Finish', currentTestResult, true);\r\n    isRunning = false;\r\n}\r\nasync function runStepActions(step) {\r\n    let actions = step.actions, i, errorStartIdx = null, len = actions.length;\r\n    for (i = 0; i < len; i += 1) {\r\n        currentActionIdx = i;\r\n        clearErrorCount();\r\n        await utility_1.default.sleep(config_json_1.default.wait.all);\r\n        await doAction(actions[i]);\r\n        await doCheckError();\r\n        if (actionErrorCount === 1 && errorStartIdx == null) {\r\n            errorStartIdx = i;\r\n        }\r\n        else if (actionErrorCount >= 1 && i - errorStartIdx > actionErrorCount) {\r\n            errorStartIdx = null;\r\n            actionErrorCount = 0;\r\n        }\r\n        else if (actionErrorCount >= 2) {\r\n            break;\r\n        }\r\n    }\r\n}\r\nasync function doAction(action) {\r\n    let clientAction = action && actionMap[action.type];\r\n    if (!clientAction) {\r\n        log(`No action found for: ${action.type}`, 'warn');\r\n        return;\r\n    }\r\n    try {\r\n        await utility_1.default.sleep(config_json_1.default.wait[action.type]);\r\n        await clientAction(action);\r\n    }\r\n    catch (err) {\r\n        if (errorCount >= config_json_1.default.error.retryCount) {\r\n            log(err, 'error');\r\n            updateResult('Error occured', false);\r\n            await createErrorScreenshot(action);\r\n            actionErrorCount += 1;\r\n            return;\r\n        }\r\n        errorCount += 1;\r\n        errorWait += defaultErrorWait;\r\n        log(`--- retry: ${errorCount} ---`, 'warn', true);\r\n        await utility_1.default.sleep(errorWait);\r\n        await doAction(action);\r\n    }\r\n}\r\nfunction clearErrorCount() {\r\n    errorCount = 0;\r\n    errorWait = config_json_1.default.error && config_json_1.default.error.wait || 300;\r\n}\r\nasync function doCheckError() {\r\n    let logs = await driver_wrapper_1.default.getLogs();\r\n    if (!logs) {\r\n        return;\r\n    }\r\n    let filteredLogs = logs.filter((l) => l.level.value >= config_json_1.default.browerLogLevel);\r\n    filteredLogs.forEach((filterLog) => {\r\n        if (filterLog.level.value > 900) {\r\n            log('BROWER: ' + filterLog.message, 'error');\r\n            updateResult('Error occured: ' + 'BROWER: ' + filterLog.message, false);\r\n        }\r\n        else if (filterLog.level.value > 800) {\r\n            log('BROWER: ' + filterLog.message, 'warn');\r\n        }\r\n    });\r\n}\r\nasync function doSetSize(action) {\r\n    log(`set size to: w-${action.width}, h-${action.height}`, null, errorCount);\r\n    await driver_wrapper_1.default.setWindowSize(action);\r\n}\r\nasync function doWait(action) {\r\n    log(`wait for: ${action.value} ms`, null, errorCount);\r\n    await utility_1.default.sleep(action.value);\r\n}\r\nasync function goToUrl(action) {\r\n    if (currentUrl) {\r\n        return;\r\n    }\r\n    currentUrl = config_json_1.default.startUrl || action.value;\r\n    log(currentUrl, null, errorCount);\r\n    await driver_wrapper_1.default.goToUrl(action.value);\r\n}\r\nasync function doClick(action) {\r\n    await doClickAction(action);\r\n}\r\nasync function doDblClick(action) {\r\n    await doClickAction(action, true);\r\n}\r\nasync function doClickAction(action, isDoubleClick = false) {\r\n    log(`${!isDoubleClick ? 'click' : 'double click'}:  ${action.cssPath}`, null, errorCount);\r\n    await driver_wrapper_1.default.click(action.cssPath, isDoubleClick);\r\n}\r\nasync function doContextMenu(action) {\r\n    log(`contextmenu`, null, errorCount);\r\n    await driver_wrapper_1.default.contextClick(action.cssPath);\r\n}\r\nasync function doKey(action) {\r\n    let keyCode = action.value, key = key_map_1.default[keyCode] || String.fromCharCode(keyCode);\r\n    log(`key:  ${key} : ${keyCode}`, null, errorCount);\r\n    await driver_wrapper_1.default.sendKeys(action.cssPath, key);\r\n}\r\nasync function doKeyUp(action) {\r\n    let value = action.value;\r\n    if (value === null || value === undefined) {\r\n        await doKey(action);\r\n        return;\r\n    }\r\n    log(`set value:  ${value}`, null, errorCount);\r\n    await driver_wrapper_1.default.sendKeys(action.cssPath, value);\r\n}\r\nasync function doScroll(action) {\r\n    log(`scroll: ${action.left} ${action.top}`, null, errorCount);\r\n    await driver_wrapper_1.default.scroll(action.cssPath, {\r\n        left: action.left,\r\n        top: action.top\r\n    });\r\n}\r\nasync function doVerify(action) {\r\n    let text = action.value, verifyMessage = `verify - \"${text}\"`, result;\r\n    log(verifyMessage, null, errorCount);\r\n    result = await driver_wrapper_1.default.verify(action.cssPath, text);\r\n    log(verifyMessage, !result ? 'error' : 'success');\r\n    updateResult(verifyMessage, result);\r\n}\r\nasync function resetMouse() {\r\n    log('reset mouse');\r\n    await driver_wrapper_1.default.resetMouse();\r\n}\r\nasync function createErrorScreenshot(action) {\r\n    let fileName = `${currentActionIdx}-${action.id}-${action.type || ''}.png`, errorFolder = `${config_json_1.default.screenErrorFolder}/${currentTestName}/${currentStep.name}/`, errorFile = `${errorFolder}${fileName}`;\r\n    await resetMouse();\r\n    let imgStr = await driver_wrapper_1.default.screenshot();\r\n    let data = await Pixel_1.default.getImgData(imgStr);\r\n    data = Pixel_1.default.highlight(action, data, [255, 0, 0]);\r\n    fs_extra_1.default.ensureDirSync(errorFolder);\r\n    fs_1.default.writeFileSync(errorFile, data, 'base64');\r\n}\r\nasync function doScreenShot(action) {\r\n    await resetMouse();\r\n    let imgStr = await driver_wrapper_1.default.screenshot();\r\n    let data = await Pixel_1.default.getImgData(imgStr, action);\r\n    await compareImages(action, data);\r\n}\r\nfunction compareImages(action, base64Data) {\r\n    let stepName = currentStep.name, screenShotName = `${action.screenIndex || action.id}`, fileName = `${screenShotName}.png`, baseFolder = `${config_json_1.default.screenBaseFolder}/${currentTestName}/${stepName}/`, currentFolder = `${config_json_1.default.screenCurrentFolder}/${currentTestName}/${stepName}/`, diffFolder = `${config_json_1.default.screenDiffFolder}/${currentTestName}/${stepName}/`, baseFile = `${baseFolder}${fileName}`, currentFile = `${currentFolder}${fileName}`, diffFile = `${diffFolder}${fileName}`, screenshotMessage = `screenshot \"${stepName} - ${screenShotName}\"`, ws;\r\n    log(screenshotMessage, null, errorCount);\r\n    fs_extra_1.default.ensureDirSync(baseFolder);\r\n    fs_extra_1.default.ensureDirSync(currentFolder);\r\n    fs_extra_1.default.ensureDirSync(diffFolder);\r\n    utility_1.default.ensureFile(baseFile, base64Data, 'base64');\r\n    fs_1.default.writeFileSync(currentFile, base64Data, 'base64');\r\n    return new Promise((resolve, reject) => {\r\n        node_resemble_js_1.default(baseFile).compareTo(currentFile).ignoreColors().onComplete((data) => {\r\n            let isSuccess = Number(data.misMatchPercentage) <= 0.01;\r\n            log(screenshotMessage, isSuccess ? 'success' : 'error');\r\n            updateResult(screenshotMessage, isSuccess);\r\n            if (isSuccess) {\r\n                resolve();\r\n            }\r\n            else {\r\n                ws = fs_1.default.createWriteStream(diffFile);\r\n                ws.on('finish', () => resolve());\r\n                data.getDiffImage().pack().pipe(ws);\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction updateResult(message, result) {\r\n    logResult(message, result);\r\n    if (!result) {\r\n        currentStepResult = false;\r\n        currentTestResult = false;\r\n    }\r\n}\r\nfunction log(content, type, isForce) {\r\n    channel && channel({\r\n        testName: currentTestName,\r\n        stepName: currentStep && currentStep.name,\r\n        timeStamp: new Date().toISOString(),\r\n        type: type || 'log',\r\n        content: content,\r\n        isForce: isForce\r\n    });\r\n}\r\nfunction logResult(content, result, isTestOnly) {\r\n    let message = {\r\n        testName: currentTestName,\r\n        timeStamp: new Date().toISOString(),\r\n        type: 'result',\r\n        content: content,\r\n        result: result\r\n    };\r\n    if (!isTestOnly && currentStep && currentStep.name) {\r\n        message.stepName = currentStep.name;\r\n    }\r\n    channel && channel(message);\r\n}\r\nlet StepRunner = {\r\n    runTest: runTest\r\n};\r\nexports.default = StepRunner;\r\n\n\n//# sourceURL=webpack:///./step-runner.ts?");

/***/ }),

/***/ "./test-runner.ts":
/*!************************!*\
  !*** ./test-runner.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\r\nconst fs_extra_1 = __importDefault(__webpack_require__(/*! fs-extra */ \"../node_modules/fs-extra/lib/index.js\"));\r\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\r\nconst step_runner_1 = __importDefault(__webpack_require__(/*! ./step-runner */ \"./step-runner.ts\"));\r\nconst config_json_1 = __importDefault(__webpack_require__(/*! ./config.json */ \"./config.json\"));\r\nlet screenBaseFolder, screenCurrentFolder, screenDiffFolder, screenErrorFolder, testName, isParallel;\r\ninit();\r\nfunction init() {\r\n    isParallel = false;\r\n    if (process.argv.length > 2) {\r\n        isParallel = true;\r\n        RunAsParallel(process.argv[2]);\r\n    }\r\n}\r\nfunction RunAsParallel(testFolder) {\r\n    runTest(testFolder, parallelChanel);\r\n}\r\nfunction parallelChanel(message) {\r\n    process.send(message);\r\n}\r\nasync function runTest(testFolder, channel) {\r\n    let steps;\r\n    initFolders(testFolder);\r\n    steps = getSteps(testFolder, channel);\r\n    await step_runner_1.default.runTest(testName, steps, channel);\r\n}\r\nfunction initFolders(testFolder) {\r\n    testName = path_1.default.relative(config_json_1.default.sourceFolder, testFolder);\r\n    screenBaseFolder = path_1.default.join(config_json_1.default.screenBaseFolder, testName);\r\n    screenCurrentFolder = path_1.default.join(config_json_1.default.screenCurrentFolder, testName);\r\n    screenDiffFolder = path_1.default.join(config_json_1.default.screenDiffFolder, testName);\r\n    screenErrorFolder = path_1.default.join(config_json_1.default.screenErrorFolder, testName);\r\n    [screenBaseFolder, screenCurrentFolder, screenDiffFolder, screenErrorFolder].forEach((folder) => {\r\n        fs_extra_1.default.ensureDirSync(folder);\r\n    });\r\n    [screenCurrentFolder, screenDiffFolder, screenErrorFolder].forEach((folder) => {\r\n        fs_extra_1.default.emptyDirSync(folder);\r\n    });\r\n}\r\nfunction getSteps(testFolder, channel) {\r\n    let stepsFile = path_1.default.join(testFolder, 'steps.json'), stepNames, steps, i, len, stepData, stepName, stepPath, results = [];\r\n    if (!fs_1.default.existsSync(stepsFile)) {\r\n        channel({\r\n            type: 'error',\r\n            content: testName + ': Could not find step file!'\r\n        });\r\n        return null;\r\n    }\r\n    stepNames = JSON.parse(fs_1.default.readFileSync(stepsFile, 'utf8'));\r\n    steps = stepNames && stepNames.steps;\r\n    if (!steps) {\r\n        return;\r\n    }\r\n    for (i = 0, len = steps.length; i < len; i += 1) {\r\n        stepName = steps[i] && steps[i].name;\r\n        stepPath = path_1.default.join(testFolder, `${stepName}.json`);\r\n        if (!fs_1.default.existsSync(stepPath)) {\r\n            stepPath = path_1.default.join(config_json_1.default.shareFolder, `${stepName}.json`);\r\n            if (!fs_1.default.existsSync(stepPath)) {\r\n                channel({\r\n                    type: 'error',\r\n                    content: 'Could not find step: ' + stepName\r\n                });\r\n                return null;\r\n            }\r\n        }\r\n        try {\r\n            stepData = fs_1.default.readFileSync(stepPath, 'utf8');\r\n            if (stepData) {\r\n                results.push(JSON.parse(stepData));\r\n            }\r\n        }\r\n        catch (e) {\r\n            channel({\r\n                type: 'error',\r\n                content: stepPath + ': Invalid content'\r\n            });\r\n            return null;\r\n        }\r\n    }\r\n    return results;\r\n}\r\nlet TestRunner = {\r\n    runTest: runTest\r\n};\r\nexports.default = TestRunner;\r\n\n\n//# sourceURL=webpack:///./test-runner.ts?");

/***/ }),

/***/ "./utility.ts":
/*!********************!*\
  !*** ./utility.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\r\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\r\nfunction getFiles(dir, forFolder) {\r\n    let all = [], files = fs_1.default.readdirSync(dir) || [];\r\n    for (let i in files) {\r\n        let name = dir + (dir.endsWith('/') ? '' : '/') + files[i];\r\n        if (fs_1.default.statSync(name).isDirectory()) {\r\n            forFolder && all.push(name);\r\n            all = all.concat(getFiles(name, forFolder));\r\n        }\r\n        else {\r\n            !forFolder && all.push(name);\r\n        }\r\n    }\r\n    return all;\r\n}\r\nfunction ensureFile(path, data, encoding) {\r\n    let state;\r\n    if (!fs_1.default.existsSync(path)) {\r\n        fs_1.default.writeFileSync(path, data, encoding);\r\n    }\r\n}\r\nfunction isOnPath(a, b) {\r\n    return a.startsWith(b) || !path_1.default.relative(a, b);\r\n}\r\nfunction sleep(ms = 0) {\r\n    return new Promise(r => setTimeout(r, ms));\r\n}\r\nconst Utility = {\r\n    getFiles: getFiles,\r\n    ensureFile: ensureFile,\r\n    sleep: sleep,\r\n    isOnPath: isOnPath\r\n};\r\nexports.default = Utility;\r\n\n\n//# sourceURL=webpack:///./utility.ts?");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./runner.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./runner.ts */\"./runner.ts\");\n\n\n//# sourceURL=webpack:///multi_./runner.ts?");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"assert\");\n\n//# sourceURL=webpack:///external_%22assert%22?");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"buffer\");\n\n//# sourceURL=webpack:///external_%22buffer%22?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"child_process\");\n\n//# sourceURL=webpack:///external_%22child_process%22?");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"constants\");\n\n//# sourceURL=webpack:///external_%22constants%22?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack:///external_%22events%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=webpack:///external_%22http%22?");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");\n\n//# sourceURL=webpack:///external_%22https%22?");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"net\");\n\n//# sourceURL=webpack:///external_%22net%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack:///external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");\n\n//# sourceURL=webpack:///external_%22stream%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=webpack:///external_%22url%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack:///external_%22util%22?");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"zlib\");\n\n//# sourceURL=webpack:///external_%22zlib%22?");

/***/ })

/******/ });